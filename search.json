[{"title":"table无法设置td宽度","url":"%2F2017%2F10%2F11%2Farticle-66%2F","content":"今天在修改别人的代码的时候突然遇到这么一个问题，在之前的代码中给`<table>`标签的`<td width=\"25%\">`设置了宽度，可是当`<td>`中的内容增多时，依然被撑开了，而不是设定好的`25%`。\n\n于是我试了给`<td style=\"width: 25%\">`设置样式，在css文件中设置样式，以及在标签内加入一个块级元素的方式，都失败了。。。。。。\n\n只能在网上找寻办法，发现了`table`有这么一个CSS属性：`table-layout`。\n\n<!-- more -->\n\n这个属性主要有两个属性值：\n- automatic     //默认值，列宽度由单元格内容设定\n- fixed     //列宽由表格宽度和列宽度设定\n\n从属性值我们可以知道，在我们不给`table`设置这个属性时，列宽都是由单元格内容自适应的，设定了属性值`fixed`之后，我们才可以给列宽设定值来手动更改表格的布局。\n\n不过需要知道的是，自动表格布局在计算布局时由于要自适应内容，所以会把所有的内容都遍历一遍，这样就会很慢。而固定表格的布局时，当浏览器接收到表格的第一行之后就会完成表格的布局，不会再计算后面的内容，也快速了很多。\n\n所以我们最终的解决办法就是给`table`设置这么一个样式属性，属性值为`fixed`，然后再给`td`设置宽度即可生效。\n","tags":["响应式"],"categories":["前端"]},{"title":"viewport的理解","url":"%2F2017%2F09%2F30%2Farticle-65%2F","content":"以前一直没有注意过这个属性的含义，后来在做移动端的一些设计的时候，这个属性已经成了必不可少的东西，所以才找了时间去好好理解一下。\n\n<!--more-->\n\n先提一个概念 —— *像素比*，这个东西指的是*设备物理像素与设备无关像素（dips)的比例*。设备的物理像素很好理解，就是设备的分辨率，那`dips`是什么东西呢？这个我们可以直接将其理解为屏幕的可视区域大小。比如显示器的分辨率为1600px，那么设备的物理像素就是1600px，而显示器的可视区域只有800px，那么这800px即是显示器的`dips`，于是我们可以知道该设备的像素比为2。\n\n知道了像素比和`dips`，再来说一说我们的CSS样式中的像素。在未进行任何设置的情况下，CSS中的像素与设备的物理像素保持一致。这时我们设置CSS中的1px，对应到屏幕中去实际的像素也是物理像素的1px。\n\n我们这里使用一张200 X 200的图片来演示。\n\n代码：\n```html\n<html>\n    <head>\n        <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n        <style>\n            .photo {\n                width: 200px;\n                height: 200px;\n                border: solid 1px #000;\n                background: url(./author.jpg) no-repeat;\n                background-size:  100% 100%;\n            }\n        </style>\n    </head>\n    <body>\n        <div class=\"photo\"></div>\n    </body>\n</html>\n```\n\n![未添加viewport](http://oetmrek6t.bkt.clouddn.com/article_65_1.png)\n\n上面是未添加viewport的图片，下面是添加了viewport的图片。\n\n![添加了viewport](http://oetmrek6t.bkt.clouddn.com/article_65_2.png)\n\n从上面的对比我们可以发现，在未添加viewport时，虽然设备的`dips`只有`375 X 667`，但是由于CSS中的1px是与屏幕分辨率对应的，所以我们设置的图片会显示的很小。而通过设置`viewport`我们将CSS像素与`dips`比例设置为1，这时CSS中的1px与`dips`保持一致，图片便会变大。\n\n在知道了上面的事情，我们可以大致理解`viewport`的作用，即改变CSS像素与`dips`的比例，下面是`viewport`的其他属性解析。\n\n![viewport属性表格](http://oetmrek6t.bkt.clouddn.com/article_65_3.png)\n\n需要注意的是，通常我们不会给`width`和`height`属性设置具体的数值，而是通过设置`width=device-width`来使`viewport`的大小与设备大小即`dips`一致。\n\n参考文章：\n- [响应式网页开发基础：DPR 与 viewport](https://zhuanlan.zhihu.com/p/26131956)\n- [深入了解viewport和px](http://tgideas.qq.com/webplat/info/news_version3/804/7104/7106/m5723/201509/376281.shtml)\n\n","tags":["HTML"],"categories":["前端"]},{"title":"关于p标签内容换行问题","url":"%2F2017%2F09%2F27%2Farticle-64%2F","content":"今天同事突然给我反馈了一个这样的问题，我一看，什么鬼，怎么变成这样了。就看了一下代码，发现每一行右边的p标签用了`absolute`属性，所以就导致了发生了这样的事情。\n\n![BUG图片](http://oetmrek6t.bkt.clouddn.com/article_64_1.png)\n\n<!--more-->\n\n拿到手的第一想法，把`absolute`属性去掉就是了，然后通过`margin`来控制定位与左边对齐，这样右边p标签的高度就可以跟着内容自适应了。\n\n![第一次修改后的图片](http://oetmrek6t.bkt.clouddn.com/article_64_2.png)\n\n纳尼，为什么第一行是这样的，这么难受吗。我又好好看了一下代码，好像没什么问题，就搜了一下，发现浏览器对中英文字符处理是不一样的。\n\n    准确的说是对中日韩文本和其他文本处理不一样，我上面第一行的链接会被浏览器当做一个单词展示，所以不会换行的。\n\n既然还有这种操作，那也只能默默承受了。于是我又好好去看了一下w3c的CSS文本属性，发现了解决办法。\n\n## CSS文本换行\n在文本属性的最后，我发现了有这么三个属性`text-wrap`、`word-break`、`word-wrap`。\n\n![三个属性图](http://oetmrek6t.bkt.clouddn.com/article_64_3.png)\n\n这三个属性都是规定文本的换行规则的，但是`text-wrap`属性目前主流浏览器都不支持，所以我们只关注下面的两个属性。\n\n## word-break\n从描述上已经知道了非中日韩文本的换行容易出现问题，可以使用该属性解决，它的属性值主要有以下三个：\n\n- normal    //使用浏览器默认的换行规则\n- break-all     //允许在单词内换行\n- keep-all     //只能在半角空格或连字符处换行\n\n大概是什么意思呢，`break-all`就是当一个单词在上一行显示不下时，可以在单词内换行，一部分到下一行中去；`keep-all`也是可以换行，但是不允许将一个单词折断，如果一个单词在上一行显示不下，会在单词前面的空格处换行，但是这会导致一个问题，如果单词过长的话，第二行也显示不下的时候单词是不会再换行了。\n\n## break-word\n这个属性就可以很好的解决我的问题，允许长单词或URL地址换行到下一行，它的属性值只有两个：\n\n- normal    //只在允许的断字点换行\n- break-word     //在长单词或者URL地址内部进行换行\n\n这里也需要解释一下，其实`normal`属性跟`word-break`的`keep-all`属性的功能是一致的，而`break-word`则是将`break-all`和`keep-all`的功能进行了叠加，即一行展示不下时，单词会换到下一行，如果下一行再显示不下则会在单词内进行换行处理。\n\n## 结语\n有了上面的两个属性，我们的BUG就被开心的解决了，但是对于文本换行的处理，不止这些，因为会涉及到一个空格转换的问题，浏览器对空格的处理和对`&nbsp;`的处理是不一样的。不过这里就没深究了，感兴趣的同学可以查看一下`AlloyTeam`博客的这篇文章：[【CSS单词换行and断词，你真的完全了解吗】](http://www.alloyteam.com/2016/05/css-word-for-word-breaker-do-you-really-understand/)。\n\n","tags":["CSS3"],"categories":["前端"]},{"title":"我要你","url":"%2F2017%2F09%2F23%2Fmusic-20%2F","content":"<blockquote class=\"blockquote-center\">我在他乡，望着月亮</blockquote>\n\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=100 src=\"//music.163.com/outchain/player?type=2&id=437292675&auto=0&height=66\"></iframe>\n\n<!--more-->\n\n<p style=\"text-align: center;\">我要你 - 任素汐\n\n我要 你在我身旁\n我要 你为我梳妆\n这夜的风儿吹\n吹得心痒痒 我的情郎\n我在他乡 望着月亮\n都怪这月色 撩人的疯狂\n都怪这Guitar 弹得太凄凉\n欧 我要唱着歌\n默默把你想 我的情郎\n你在何方 眼看天亮\n都怪这夜色 撩人的疯狂\n都怪这Guitar 弹得太凄凉\n欧 我要唱着歌\n默默把你想 我的情郎\n你在何方 眼看天亮\n我要 美丽的衣裳\n为你 对镜贴花黄\n这夜色太紧张\n时间太漫长 我的情郎\n我在他乡 望着月亮\n</p>","tags":["音乐"],"categories":["故事"]},{"title":"前世情人","url":"%2F2017%2F09%2F23%2Fmusic-19%2F","content":"<blockquote class=\"blockquote-center\">什么爱不说就已经存在，什么爱望着就全都明白</blockquote>\n\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=100 src=\"//music.163.com/outchain/player?type=2&id=415792918&auto=0&height=66\"></iframe>\n\n<!--more-->\n\n<p style=\"text-align: center;\">前世情人 - 周杰伦\n\n松鼠陪着核桃\n在庭院捉迷藏\n葡萄躲进橡木桶\n酿出时光\n夏日在玉米齿缝中游荡\n我为你准备的四季\n正在生长\n炼金师从故事炼出土壤\n我阖上书也闻到了花香\n草地上的你比果实芬芳\n你就像天使手里的糖\n小男孩害羞没想起\n自己是个雕像\n沉浸在芦苇跟风合奏\n用美妙歌声赞扬\n世界因为你而露出\n阳光灿烂的形状\n谢谢你不然纯真是什么\n我早已经遗忘\n什么爱不说就已经存在\n什么爱望着就全都明白\n你笑一点一点一滴漾开\n一字一句形容不来\n是星空上的银海\n月晕下的双手\n越来越来越来越依靠\n从来从来从来不知道\n原来原来原来有你很骄傲\n小公主过来过来过来\n约定好\n未来未来未来的城堡\n将来将来将来\n我们一起造\n我会当你昼夜骑士\n烈阳的树荫\n让花朵为你吟游的魔术师\n每一道有你风景\n帮你按下快门的秘密情人\n什么爱不说就已经存在\n什么爱望着就全都明白\n你笑一点一点一滴漾开\n一字一句形容不来\n是星空上的银海\n\n我后来会在纯白的礼堂\n牵好久的手交给另个他\n眼泪一点一点一滴流下\n感动也会跟着留下\n远远看着你们幸福\n像前世我们有过的模样\n</p>","tags":["音乐"],"categories":["故事"]},{"title":"失恋","url":"%2F2017%2F09%2F23%2Fmusic-18%2F","content":"<blockquote class=\"blockquote-center\">莫于孤清里自怜自挂</blockquote>\n\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=100 src=\"//music.163.com/outchain/player?type=2&id=349079&auto=0&height=66\"></iframe>\n\n<!--more-->\n\n<p style=\"text-align: center;\">失恋 - 草蜢\n\n将敌意 将身份放低些吧\n今夜里 应一起了解她\n失败过 哪用怕 即管说吧\n共于苦恋中找点潇洒\n深夜里 将一起暗恋的她\n互倾诉 不应关闭嘴巴\n遭遇也 会近似 将苦诉吧\n莫于孤清里自怜自挂\n象你这般深爱她 心里只得一个她\n她偏却 太傲气 见面也不多说话\n要坦率分析 为何没法得到她\n心里长留下旧创疤\n将阵线 将思想也统一吧\n于今晚 应一起探讨她\n假若有 结论再 一起爱吧\n莫于孤清里自怜自挂\n\n将敌意 将身份放低些吧\n今夜里 应一起了解她\n失败过 哪用怕 即管说吧\n共于苦恋中找点潇洒\n深夜时 将一起暗恋的她\n互倾诉 不应关闭嘴巴\n遭遇也 会近似 将苦诉吧\n莫于孤清里自怜自挂\n象你这般深爱她 心里只得一个她\n她偏却 太傲气 见面也不多说话\n要坦率分析 为何没法得到她\n心里长留下旧创疤\n将阵线 将思想也统一吧\n于今晚 应一起探讨她\n假若有 结论再 一起爱吧\n莫于孤清里自怜自挂\n莫于孤清里自怜自挂\n莫于孤清里自怜自挂\n</p>","tags":["音乐"],"categories":["故事"]},{"title":"电灯胆","url":"%2F2017%2F09%2F23%2Fmusic-17%2F","content":"<blockquote class=\"blockquote-center\">能回避嘛我怕了当那电灯胆</blockquote>\n\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=100 src=\"//music.163.com/outchain/player?type=2&id=224086&auto=0&height=66\"></iframe>\n\n<!--more-->\n\n<p style=\"text-align: center;\">电灯胆 - 邓丽欣\n\n假使不能公开妒忌\n学习大方接受\n同行时要殿后\n谁冷落旧朋友\n节日约我三位一体的庆祝\n沿途明亮灯饰闪映着沉重\n言谈越炽热内在更冰冻\n谁当初无心将两方撮合\n然后留低只得这寂寞人\n仍是你们密友呆望你们热吻\n应该伤感还是快感\n能回避嘛我怕了当那电灯胆\n黏着你们来来回委曲中受难\n一个我被撇低却又很不惯\n要走的一剎又折返\n能承认嘛我故意当那电灯胆\n他日你们完场时入替也不难\n善良人埋藏着最坏的心眼\n妄想一天你们会散\n会选我吗\n对换了你身份可应该满足\n情人还是知己都拥入怀抱\n同情或眼泪让别个得到\n留低的原因一世的秘密\n其实明知只得我是外人\n仍是你们密友呆望你们热吻\n应该开心还是痛心\n能回避嘛我怕了当那电灯胆\n黏着你们来来回委曲中受难\n一个我被撇低却又很不惯\n要走的一剎又折返\n能承认嘛我故意当那电灯胆\n他日你们完场时入替也不难\n善良人埋藏着最坏的心眼\n妄想一天你们会散\n会选我吗\n</p>\n","tags":["音乐"],"categories":["故事"]},{"title":"我们的歌","url":"%2F2017%2F09%2F23%2Fmusic-16%2F","content":"<blockquote class=\"blockquote-center\">情人总分分合合，可我们却越爱越深</blockquote>\n\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=100 src=\"//music.163.com/outchain/player?type=2&id=25642952&auto=0&height=66\"></iframe>\n\n<!--more-->\n\n<p style=\"text-align: center;\">我们的歌 - 王力宏\n\n已经听了一百遍 怎么听都不会倦\n从白天唱到黑夜 你一直在身边（一直在身边）\n如果世界太危险 只有音乐最安全 带着我进梦里面 让歌词都实现\n无论是开心还是难过我的爱一直不变\n（不必担心时间流逝带走一切）\n无论是HIP-HOP还是摇滚我的爱一直不变\n（所有美好回忆记录在里面）\n这种Forever Love 那么深\n我们的歌 那么真\n无国界 跨时代\n再不会叫我KISS GOODBYE\n要每一句能够动人心弦 YE~~\n情人总分分合合\n可是我们却越爱越深\n认识你让我的幸福如此 悦耳\n能不能不要切歌 继续唱我们的歌\n让感动一辈子都记得\nen heng~~~\nwo~ o~\n已经听了一百遍 怎么听都不会倦\n从白天唱到黑夜 你一直在身边（一直在身边）\n如果世界太危险 只有音乐最安全 带着我进梦里面 让歌词都实现\n无论是开心还是难过我的爱一直不变\n（不必担心时间流逝带走一切）\n无论是HIP-HOP还是摇滚我的爱一直不变\n（所有美好回忆记录在里面）\n这种Forever Love那么深 我们的歌那么真\n无国界 跨时代\n再不会叫我KISS GOODBYE\n要每一句能够动人心弦 YE~~\n情人总分分合合\n可是我们却越爱越深\n认识你让我的幸福如此 悦耳\n能不能不要切歌 继续唱我们的歌\n让感动一辈子都记得\n\n（一辈子都记得）\n情人总分分合合\n可是我们却越爱越深\n认识你让我的幸福如此 悦耳\n能不能不要切歌 继续唱我们的歌\n让感动一辈子都记得\n</p>\n","tags":["音乐"],"categories":["故事"]},{"title":"宝贝","url":"%2F2017%2F09%2F23%2Fmusic-15%2F","content":"<blockquote class=\"blockquote-center\">哎呀呀呀呀呀我的宝贝，要你知道你最美</blockquote>\n\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=100 src=\"//music.163.com/outchain/player?type=2&id=326738&auto=0&height=66\"></iframe>\n\n<!--more-->\n\n<p style=\"text-align: center;\">宝贝 - 张悬\n\n我的宝贝 宝贝\n给你一点甜甜\n让你今夜都好眠\n我的小鬼 小鬼\n逗逗你的眉眼\n让你喜欢这世界\n哇啦啦啦啦啦我的宝贝\n倦的时候有个人陪\n哎呀呀呀呀呀我的宝贝\n要你知道你最美\n我的宝贝 宝贝\n给你一点甜甜\n让你今夜很好眠\n我的小鬼 小鬼\n捏捏你的小脸\n让你喜欢整个明天\n哇啦啦啦啦啦我的宝贝\n倦的时候有个人陪\n哎呀呀呀呀呀我的宝贝\n要你知道你最美\n哇啦啦啦啦啦我的宝贝\n孤单时有人把你想念\n哎呀呀呀呀呀我的宝贝\n要你知道你最美\n哇啦啦啦啦啦Yeah...woo\nYeah...woo...\n哇啦啦啦啦啦我的宝贝\n倦的时候有个人陪\n哎呀呀呀呀呀我的宝贝\n要你知道你最美\n要你知道你最美\n</p>\n","tags":["音乐"],"categories":["故事"]},{"title":"CRSF攻击原理与防范","url":"%2F2017%2F09%2F08%2Farticle-62%2F"},{"title":"XSS攻击原理与防范","url":"%2F2017%2F09%2F08%2Farticle-61%2F"},{"title":"JS中new操作符的效果","url":"%2F2017%2F09%2F08%2Farticle-60%2F"},{"title":"viewport标签详解","url":"%2F2017%2F09%2F08%2Farticle-59%2F"},{"title":"a标签设置不跳转","url":"%2F2017%2F09%2F08%2Farticle-58%2F","content":"又是在面试的时候，被问到这个问题，看起来好像很简单，非常基础的一个问题。大家肯定也都知道有哪些方法，可是一旦细问起来，又有很多细节发现并不清楚，所以下去也好好了解了一下这个问题。\n\n<!--more-->\n\na标签设置不跳转，常见的方法有三种：\n\n- 设置`href`的值为`javascript:void(0);`\n- 设置`href`的值为`#`\n- 添加`onclick`属性并设置为`return false`\n\n接下来我们详细解释一下三个设置的原理。\n\n## href设置为javascript\n这里很多人都知道我可以设置为`javascript:void(0);`或者`javascript:;`都可以阻止a标签的跳转，那么在`javascript`的冒号后面可以接其他的内容吗？\n\n当然是可以的! `href`属性值是当前链接标签的指向，我们可以使用`javascript`加冒号开头，来将该标签指向一段javascript代码，这是点击该标签会执行指向的代码，而不是发生跳转行为。\n\n需要知道的是，因为已经通过`javascript:`开头将标签指向代码了，所以不管冒号后面填写什么标签都不会再进行跳转，而是进入浏览器的js执行环境去。\n\n## href设置为#\n将`href`的属性值设置为`#`号，其实是给标签设置了默认的锚点，指向当前页面的顶部，所以在点击时会回到当前页面的顶部。但是我们依然可以使用这种方法来阻止标签跳转！\n\n就是不要只使用`#`号，可以在`#`号后面加一个其他的值，这样页面就不会发生跳转。\n\n## onclick来阻止跳转\n使用`onclick`就是给标签绑定一个点击事件，但是这里只能在等号后面填写`return false;`，这样的话当前标签的默认事件便不会执行，从而达到阻止标签跳转的目的。\n\n这里需要注意的是，在`onclick`的等号后面填写方法名称，在方法中返回`false`的办法是不行的，只能在标签的属性值中填写`return false;`。\n","tags":["HTML"],"categories":["前端"]},{"title":"img标签的title和alt属性的区别","url":"%2F2017%2F09%2F08%2Farticle-57%2F","content":"之前一直没有注意过img标签的title属性和alt属性有什么区别，一次面试中被问到这道题，突然懵逼了，这么基础的东西却一直都不知道。\n\n<!--more-->\n\n## title属性\ntitle属性主要用来给图片进行辅助性的提示，当用户鼠标滑过或者置于img标签上时，会出现对应的提示信息。\n\n## alt属性\nalt属性是img标签的必要属性，它用于图片无法显示时的提示，可以让用户知道该未显示的图片是什么。\n\n其长度只有1024个字符，当图片描述超过1024个字符时，可以使用`longdesc`属性来指向图像描述信息页面。","tags":["SEO"],"categories":["前端"]},{"title":"【百度笔记】Spring相关注解","url":"%2F2017%2F08%2F16%2Farticle-56%2F","content":"由于突然转成RD，对于JAVA的很多知识还很欠缺，所以在学习源码的时候，记录一下必要的一些知识点。\n\n本篇主要是记录Spring的一些注解用法。\n\n<!--more-->\n\n## @Controller\n`@Controller`注解将一个类定义为`Controller`，之后可以使用`Controller`的一些方法。\n\n## @ResponseBody\n`@ResponseBody`注解用于将`Controller`的方法返回的对象，通过适当的`HttpMessageConverter`转换为指定格式后，写入到`Response`对象的body数据区。\n\n## @RestController\n`@RestController`注解相当于是`@Controller`和`@ResponseBody`合在一起使用。\n\n## @RequestMapping\n`@RequestMapping`注解用于匹配请求的URL。\n\n## @AutoWired\n`@AutoWired`注解用于Spring自动装配注解的bean。\n\n## @ApiOperation\n`@ApiOperation`注解为Swagger项目中API声明的相关注解，Swagger项目为生成Restful风格的接口文档项目。\n\n## @PathVariable\n`@PathVariable`注解用于将URL中参数绑定到控制器处理方法的入参中。\n\n## @QueryParam\n`@QueryParam`注解用于获取GET请求中的查询查询参数。\n\n## @JsonProperty\n`@JsonProperty`用于将一个属性的名称序列化成另一个名称。\n\n## @Value\n`@Value`注解用于从配置文件读取值并赋给变量。\n\n## @Qualifier\n`@Qualifier`注解指定自动注入的Bean的名称。\n\n## @ComponentScan\n`@ComponentScan`注解\b使项目运行时会自动去扫描指定包下面的\b`@Component`、`@Controller`、`@Service`等类并注册为bean。\n\n## @Repository\n`@Repository`用于将DAO层的类标识为Spring Bean。\n\n## @Deprecated\n`@Deprecated`注解告诉已经调用该方法的调用者该方法不是最佳实践。\n\n## @Retention\n`@Retention`注解标注了声明的注解会被保留到程序执行的哪个阶段。\n\n## @Target\n`@Target`用于指定注解的使用范围。\n\n## @Async\n`@Async`注解标识异步执行的方法，将开启另一线程。\n\n","tags":["百度笔记"],"categories":["百度笔记"]},{"title":"判断对象是否拥有某个属性","url":"%2F2017%2F07%2F24%2Farticle-55%2F","content":"判断对象中是否有某个属性，有两种比较常用的方法，一种是通过关键字 `in` 来进行判断，另一种是通过对象的 `hasOwnProperty()`方法进行判断。\n\n<!--more-->\n\n```js\nvar a = {\n    b: 1,\n    c: function() {}\n};\n\nconsole.log(\"b\" in a);  //true\nconsole.log(\"toString\" in a);   //true\nconsole.log(a.hasOwnProperty(\"c\"));    //true\nconsole.log(a.hasOwnProperty(\"toString\"));  //false\n```\n\n需要注意的是使用关键字 `in` 不仅可以判断对象自身的属性，也可以判断对象继承的属性\b，而`hasOwnProperty`方法的\b话只能判断对象自身的属性是否存在，对于继承的属性则会显示`false`。","tags":["JavaScript"],"categories":["前端"]},{"title":"点击空白关闭弹窗","url":"%2F2017%2F07%2F21%2Farticle-54%2F","content":"类似于模态框的操作，我们常常会用到这样的操作，除了点击弹出框的关闭按钮，我们还可以通过点击页面中非弹框的部分来关闭弹出框，这里给出两种思路与实现方法。\n\n<!-- more -->\n\n## 判断点击是否在目标区域\n判断点击是否在目标区域的条件主要有两点：\n- 判断点击事件的对象不是目标区域对象\n- 判断点击时间的对象不是目标区域的子对象\n\n下面是该方法的js代码实现：\n```js\ndialog.click = funciton(e) {\n    var target = document.getElementById('target');\n    if (!target.isEqualNode(e.target) && !target.contains(e.target)) {\n        // your close dialog code\n        this.close();\n    }\n}\n```\n## 通过添加一层使点击该层时处理事件\n这个方法稍微麻烦一些但是也是弹窗的一种常见处理方式，主要是在弹窗与页面之间加一个背景层，可以选择透明或者显示灰色等，然后点击\b该背景层的时候关闭弹窗即可。\n\n下面是该方法的js代码实现：\n```js\ndocument.getElementById('background').click = function(e) {\n    //your close dialog code\n    dialog.close();\n}\n```","tags":["JavaScript"],"categories":["前端"]},{"title":"想把我唱给你听","url":"%2F2017%2F05%2F02%2Fmusic-14%2F","content":"<blockquote class=\"blockquote-center\">想把我唱给你听，趁现在年少如花</blockquote>\n\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=100 src=\"//music.163.com/outchain/player?type=2&id=28234970&auto=0&height=66\"></iframe>\n\n<!--more-->\n\n<p style=\"text-align: center;\">想把我唱给你听 - 老狼/王婧\n作曲 : 小柯\n\n想把我唱给你听\n趁现在年少如花\n花儿尽情地开吧\n装点你的岁月我的枝桠\n谁能够代替你呢\n趁年轻尽情的爱吧\n最最亲爱的人啊\n路途遥远我们在一起吧\n我把我唱给你听\n把你纯真无邪的笑容给我吧\n我们应该有快乐的幸福的\n晴朗的时光\n我把我唱给你听\n用我炙热的感情感动你好吗\n岁月是值得怀念的留念的\n害羞的红色脸庞\n谁能够代替你呢\n趁年轻尽情的爱吧\n最最亲爱的人啊\n路途遥远我们在一起吧\n\n想把我唱给你听\n趁现在年少如花\n花儿尽情地开吧\n装点你的岁月我的枝桠\n谁能够代替你呢\n趁年轻尽情的爱吧\n最最亲爱的人啊\n路途遥远我们在一起吧\n我把我唱给你听\n把你纯真无邪的笑容给我吧\n我们应该有快乐的幸福的\n晴朗的时光\n我把我唱给你听\n用我炙热的感情感动你好吗\n岁月是值得怀念的留念的\n害羞的红色脸庞\n\n我们应该有快乐的幸福的\n晴朗的时光\n我把我唱给你听\n用我炙热的感情感动你好吗\n岁月是值得怀念的留念的\n害羞的红色脸庞\n谁能够代替你呢\n趁年轻尽情的爱吧\n最最亲爱的人啊\n路途遥远我们在一起吧\n</p>\n","tags":["音乐"],"categories":["故事"]},{"title":"关键词","url":"%2F2017%2F05%2F02%2Fmusic-13%2F","content":"<blockquote class=\"blockquote-center\">有一种踏实，是你心中有我名字</blockquote>\n\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=100 src=\"//music.163.com/outchain/player?type=2&id=40147554&auto=0&height=66\"></iframe>\n\n<!--more-->\n\n<p style=\"text-align: center;\">关键词 - 林俊杰\n作曲 : 林俊杰\n作词 : 林怡凤\n\n好好爱自己 就有人会爱你\n这乐观的说词\n幸福的样子 我感觉好真实\n找不到形容词\n沉默在掩饰 快泛滥的激情\n只剩下语助词\n有一种踏实 当你口中喊我名字\n落叶的位置 谱出一首诗\n时间在消逝 我们的故事开始\n这是第一次\n让我见识爱情 可以慷慨又自私\n你是我的关键词\n\n我不太确定 爱最好的方式\n是动词或名词\n很想告诉你 最赤裸的感情\n却又忘词\n聚散总有时 而哭笑也有时\n我不怕潜台词\n有一种踏实 是你心中有我名字\n落叶的位置 谱出一首诗\n时间在消逝 我们的故事开始\n这是第一次\n让我见识爱情 可以慷慨又自私\n你是我的关键词\n你藏在歌词\n代表的意思\n是专有名词\n落叶的位置\n谱出一首诗\n我们的故事\n才正要开始\n这是第一次\n爱一个人爱得如此慷慨又自私\n你是我的关键词\n</p>\n","tags":["音乐"],"categories":["故事"]},{"title":"残酷月光","url":"%2F2017%2F04%2F17%2Fmusic-12%2F","content":"<blockquote class=\"blockquote-center\">如果不够悲伤 就无法飞翔</blockquote>\n\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=100 src=\"//music.163.com/outchain/player?type=2&id=433059547&auto=0&height=66\"></iframe>\n\n<!--more-->\n\n<p style=\"text-align: center;\">残酷月光（Cover：林宥嘉）\n\n让我爱你 然后把我抛弃\n我只要出发 不要目的\n我会一直想你 忘记了呼吸\n孤独到底让我昏迷\n如果恨你 就能不忘记你\n所有的面目 我都不抗拒\n如果不够悲伤 就无法飞翔\n可没有梦想 何必远方\n我一直都在流浪\n可我 不曾见过海洋\n我以为的遗忘\n原来躺在你手上\n我努力微笑坚强\n寂寞筑成一道围墙\n也敌不过夜里 最温柔的月光\n我一直都在流浪\n可我 不曾见过海洋\n我以为的遗忘\n原来躺在你手上\n我努力微笑坚强\n寂寞筑成一道围墙\n也敌不过夜里 最温柔的月光\n我会一直想你 忘记了呼吸\n孤独到底让我昏迷\n</p>\n","tags":["音乐"],"categories":["故事"]},{"title":"ES6中export和export default的区别","url":"%2F2017%2F04%2F16%2Farticle-53%2F","content":"ES6的import以及export提出了一种通用的模块加载方案，export主要用于将函数、变量、模块等进行到处，而import则是用于将外部的模块导入到现有代码中。\n\n但是有时候我们发现别人的代码使用export进行导出，有时候又是使用export default进行导出，它们之间的区别是什么呢？\n\n<!--more-->\n\n## export\nexport的使用方法如下，也可以直接在变量声明前面使用export来导出该变量。在其他模块中进行import时需要使用大括号来导入多个变量或者方法。\n\n```javascript\n//a.js\nvar name = 'jack';\nfunction getName() {\n    return this.name;\n}\n\nexport {name, getName};\n```\n\n```javascript\n//b.js\nimport {name, getName} from 'a.js';\n```\n\n## export default\nexport default导出时用于将模块内部变量以default默认变量的形式导出，并且一个模块中只能存在一个default，因此在使用import导入时也不需要使用大括号。\n\n```javascript\n//a.js\nvar name = 'jack';\nexport default name;\n```\n\n```javascript\n//b.js\nimport name from 'a.js';\n```\n\n## 为什么要有export default\n从上面的例子可以知道，当使用export导出的模块变量，b.js使用import命令的时候，用户需要知道a.js所暴露出的变量标识符，否则无法加载。如果使用export default命令，为模块指定默认输出，这样就不需要知道所要加载模块的变量名。\n","tags":["ES6"],"categories":["前端"]},{"title":"oninput、onchange和onpropertychange的区别","url":"%2F2017%2F04%2F16%2Farticle-52%2F","content":"前段时间写一个WEBAPP时遇到了一个问题，就是在给Input输入框绑定oninput事件时，该事件在IOS手机浏览器里无效，后来查到网上的解决办法同时给Input绑定了oninput和onpropertychange事件才解决了该问题。\n\n所以这里总结一下oninput、onchange和onpropertychange这三个属性的区别。\n\n<!--more-->\n\n## oninput\noninput事件触发在域的文本内容发送改变时，添加或者删除字符都会触发该事件。但是通过js来动态的改版value值时不会触发该事件。但是IE9之前版本并不支持该事件。\n\n## onchange\nonchange事件触发在域的文本内容发送改变，并且失去焦点之后才会触发。\n\n## onpropertychange\nonpropertychange事件触发的情况跟oninput类似，不同的是通过js改变value的值时也会触发该事件。onpropertychange事件是IE9之前版本的特有事件。用来解决IE的兼容性问题。","tags":["HTML5"],"categories":["前端"]},{"title":"vue-weather程序实现遇到的问题","url":"%2F2017%2F04%2F16%2Farticle-51%2F","content":"之前在知乎上投了一下百度云计算的一个前端开发招聘，在通过简历筛选之后对方给出了一道笔试题，做一个关于天气的webapp或者是一个异步加载的地区选择，因为想练习一下学习的vue就做了一个webapp，四天时间实现了大部分要求的功能吧。\n\n整个界面是仿制IOS的天气APP，数据来源是使用的API（本来要求自己爬取的），其它方面使用了canvas、es6、vue-resource、vue-router、better-scroller等，整个项目使用vue-cli + webpack进行搭建。\n\n<!--more-->\n\n[ES6中export和export default的区别](2017/04/16/article-53)\n\n[JS根据数组对象的属性名进行排序]()\n\n[解决安卓和IOS不会触发onkeyup事件](2017/04/16/article-52)\n\n[vue组件之间数据传递]()\n\n[如何在vue中获取dom节点]()\n\n[如何在远程服务器挂起node程序]()\n\n主要遇到的问题就是这些。提交之后一周都没有消息，本来以为已经挂了，但还是发了封邮件问了一下，之后HR就打电话来约了面试时间。\n\n项目演示网站：http://123.207.178.23:8080/\n\n代码仓库：https://github.com/helianthuswhite/vue-weather\n","tags":["VUE"],"categories":["前端"]},{"title":"a标签的CSS伪类添加顺序","url":"%2F2017%2F04%2F16%2Farticle-50%2F","content":"a标签我们通常会通过它的四个伪类添加样式来达到一些交互效果，但是有时候我们会发现四个伪类不按照一定的顺序书写时会导致某个交互的样式不显示或者只显示一次。这是因为伪类顺序不正确的原因导致了后面的样式始终覆盖了前面的样式。因此我们需要知道a标签伪类添加样式的正确顺序。\n\n<!--more-->\n\n## 四个伪类的作用\n>:link —— a标签还未被访问时的样式\n>:visited —— a标签已经被访问后的样式\n>:hover —— 鼠标指针移到a标签上时的样式\n>:active —— a标签被点击时的样式\n\n## 书写顺序\n这四个伪类的书写顺序即为 —— `LVHA`。\n\n前两种状态为常态，即不是在触发时出现的状态，后面两个为即时态，即触发时才会出现的状态。因此要用后两个伪类的样式覆盖前两个，这样才能够在触发时显示出后两个的样式。\n\n由于访问后处于未访问之后，所以`:visited`伪类要放在`:link`之后。而鼠标点击之前，会先把指针移动到标签上，先触发`:hover`样式，所以`:active`伪类放在`:hover`之后。\n ","tags":["HTML"],"categories":["前端"]},{"title":"【2017春招】百度口碑前端","url":"%2F2017%2F04%2F16%2Farticle-49%2F","content":"下午面了一下百度地图的前端，晚上突然接到面试电话让我一激动——二面来的这么快？结果面完之后发现是我想多了，这次是百度的另一个部门。这次面试主要问的都是前端的基础知识，但是问的挺深入的，我问了一下面试官用不用什么框架，面试官告诉我框架也都用啊，但是基础很重要。看来不同部门的要求果然差别还是蛮大的。\n\n<!--more-->\n\n[标签中的title和alt有什么区别]()\n\n[a标签如何打开一个新的页面](http://www.w3school.com.cn/tags/tag_a.asp)\n\n[a标签如何设置不跳转]()\n\n[定位方式一共有几种](/2016/12/12/article-25/)\n\n[fixed定位是相对于哪里的](/2016/12/12/article-25/)\n\n[哪个标签可以改变可视区域大小]()\n\n[JavaScript的基本数据类型有哪些](http://www.w3school.com.cn/js/js_datatypes.asp)\n\n[JavaScript的继承如何实现](/2017/04/16/article-43/)\n\n[JavaScript的原型和原型链是什么](/2017/04/16/article-43/)\n\n[new 操作符做了什么事]()\n\n[JavaScript事件模型有哪些](/2017/04/16/article-46/)\n\n[跨域的解决方式](/2017/03/10/article-34/)\n\n[前端性能优化的方式](/2017/04/16/article-44/)\n","tags":["SEO"],"categories":["前端"]},{"title":"【2017春招】百度地图前端","url":"%2F2017%2F04%2F16%2Farticle-48%2F","content":"之前内推了一下百度EFE团队，所以接到面试电话时贼紧张，听说EFE很难进。面试官说他是百度地图的，我是吃了一惊，什么时候投百度地图了？面完之后我搜寻了一下，发现是之前在大街网上投的。面试时间不长，问的问题也不算难，期待一下二面。\n\n<!--more-->\n\n[什么是盒模型]()\n\n[CSS3的2D旋转如何实现](2017/04/16/article-46/)\n\n[CSS3的动画如何实现](2017/03/10/article-34/)\n\n[CSS3的过渡怎么用](http://www.w3school.com.cn/css3/css3_transition.asp)\n\n[Flex布局怎么用](2017/04/16/article-44/)\n\n[垂直居中怎么实现](2017/03/10/article-37/)\n\n[vue的组件间通信怎么实现](2017/04/06/article-41/)\n\n[Node的服务端接收怎么实现]()\n\n[express和koa框架有什么区别]()\n\n[懒加载和预加载有什么区别]()\n\n[前端性能优化有哪些](2017/04/16/article-44/)\n\n[原生的AJAX如何实现](2017/04/16/article-47/)\n\n[捕获事件和冒泡事件是怎么回事](2017/04/16/article-46/)\n\n[有没有听说过事件委托]()\n\n[什么是点透事件]()\n","tags":["Node"],"categories":["前端"]},{"title":"AJAX实现异步加载","url":"%2F2017%2F04%2F16%2Farticle-47%2F","content":"AJAX是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。通过在后台与服务器进行少量数据交换，AJAX可以使网页实现异步更新。\n\n<!--more-->\n\n## 原生AJAX的实现\nAJAX的实现是依靠`XMLHttpRequest`对象来完成的，然后通过该对象实例的`open()`和`send()`方法完成AJAX请求。\n\n| 方法        | 描述           |\n|:-------------:|:-------------:|\n| open(method,url,async)| 规定请求的类型、URL 以及是否异步处理请求。method：请求的类型；GET 或 POST，url：文件在服务器上的位置，async：true（异步）或 false（同步） |\n| send(string)      | 将请求发送到服务器。string：仅用于 POST 请求 |\n\n当采用异步方式发送请求时，为了能够在请求正确时执行后续方法，需要使用实例的`onreadystatechange`事件来监听返回的状态码。\n\n| 属性        | 描述           |\n|:-------------:|:-------------:|\n| onreadystatechange| 存储函数（或函数名），每当 readyState 属性改变时，就会调用该函数。 |\n| readyState     | 存有 XMLHttpRequest 的状态。从 0 到 4 发生变化。0: 请求未初始化；1: 服务器连接已建立；2: 请求已接收；3: 请求处理中；4: 请求已完成，且响应已就绪 |\n| status |  200: \"OK\" ；404: 未找到页面 |\n\n接受服务响应可以使用`XMLHttpRequest`对象的`responseText`或`responseXML`属性。其中`responseText`属性是以字符串的形式接受数据，而`responseXML`是以XML的形式接收数据。\n\n```javascript\nvar xmlhttp = new XMLHttpRequest();\nxmlhttp.onreadystatechange=function()\n  {\n  if (xmlhttp.readyState==4 && xmlhttp.status==200)\n    {\n    document.getElementById(\"myDiv\").innerHTML=xmlhttp.responseText;\n    }\n  }\nxmlhttp.open(\"GET\",\"test1.txt\",true);\nxmlhttp.send();\n```\n\n## JQuery的ajax使用\nJQuery封装的ajax方法通过将配置传入方法中来完成整个请求。\n\n| 参数        | 描述           |\n|:-------------:|:-------------:|\n| async | 布尔值，表示请求是否异步处理。默认是 true。 |\n| beforeSend(xhr) | 发送请求前运行的函数。 |\n| cache | 布尔值，表示浏览器是否缓存被请求页面。默认是 true。 |\n| complete(xhr,status) | 请求完成时运行的函数（在请求成功或失败之后均调用，即在 success 和 error 函数之后）。 |\n| contentType | 发送数据到服务器时所使用的内容类型。默认是：\"application/x-www-form-urlencoded\"。 |\n| context | 为所有 AJAX 相关的回调函数规定 \"this\" 值。 |\n| data | 规定要发送到服务器的数据。 |\n| dataFilter(data,type) | 用于处理 XMLHttpRequest 原始响应数据的函数。 |\n| dataType | 预期的服务器响应的数据类型。 |\n| error(xhr,status,error) | 如果请求失败要运行的函数。 |\n| global | 布尔值，规定是否为请求触发全局 AJAX 事件处理程序。默认是 true。 |\n| ifModified |  布尔值，规定是否仅在最后一次请求以来响应发生改变时才请求成功。默认是 false。 |\n| jsonp |   在一个 jsonp 中重写回调函数的字符串。 |\n| jsonpCallback | 在一个 jsonp 中规定回调函数的名称。 |\n| password | 规定在 HTTP 访问认证请求中使用的密码。 |\n| processData | 布尔值，规定通过请求发送的数据是否转换为查询字符串。默认是 true。 |\n| scriptCharset | 规定请求的字符集。 |\n| success(result,status,xhr) | 当请求成功时运行的函数。 |\n| timeout | 设置本地的请求超时时间（以毫秒计）。 |\n| traditional | 布尔值，规定是否使用参数序列化的传统样式。 |\n| type | 规定请求的类型（GET 或 POST）。 |\n| url | 规定发送请求的 URL。默认是当前页面。 |\n| username | 规定在 HTTP 访问认证请求中使用的用户名。 |\n| xhr | 用于创建 XMLHttpRequest 对象的函数。 |\n\n```javascript\n$.ajax({\n  url:'/comm/test1.php',\n  type:'POST', //GET\n  async:true,    //或false,是否异步\n  data:{\n      name:'yang',age:25\n  },\n  timeout:5000,    //超时时间\n  dataType:'json',    //返回的数据格式：json/xml/html/script/jsonp/text\n  beforeSend:function(xhr){\n      console.log(xhr)\n      console.log('发送前')\n  },\n  success:function(data,textStatus,jqXHR){\n      console.log(data)\n      console.log(textStatus)\n      console.log(jqXHR)\n  },\n  error:function(xhr,textStatus){\n      console.log('错误')\n      console.log(xhr)\n      console.log(textStatus)\n  },\n  complete:function(){\n      console.log('结束')\n  }\n});\n```\n\n","tags":["面试"],"categories":["前端"]},{"title":"JavaScript的事件模型","url":"%2F2017%2F04%2F16%2Farticle-46%2F","content":"JavaScript的事件模型，可以分为两类，分别是DOM0级事件和DOM2级事件；也可以分成三类，分别是原始事件模型、捕获事件模型和冒泡事件模型。\n\n<!--more-->\n\n## DOM0级事件\nDOM0事件也是原始事件模型，这种事件是直接绑定在dom对象上面的事件，例如onclick事件等。\n给这种事件注册方法时，如果注册两种方法，则后一种方法会覆盖前一种，所以解除事件时我们可以直接给事件注册为null即可。\n\n```javascript\nvar click = document.getElementById('click');\nclick.onclick = function(){\n    alert('you click the first function');\n};\nclick.onclick = function(){\n    alert('you click the second function')\n}\n//you click the second function\n```\n\n## DOM2级事件\nDOM2级事件即包括了捕获事件模型和冒泡事件模式。\n捕获事件模型是事件从`document`开始向下传递，一直到目标元素；冒泡事件与之相反，是从目标元素开始向上冒泡，一直传递到`document`。下路描述了两个事件模型的过程。\n\n![图片加载失败](http://oetmrek6t.bkt.clouddn.com/article_46_1.png)\n\n## DOM2级事件的注册和解除\n在DOM2级中使用`addEventListener`和`removeEventListener`来注册和解除事件。这种函数较之之前的方法好处是一个dom对象可以注册多个相同类型的事件，不会发生事件的覆盖，会依次的执行各个事件函数。\n\n`addEventListenr`的第一个参数是事件名称，第二个参数是注册的方法，第三个参数代表捕获还是冒泡，true代表捕获事件，false代表冒泡事件。\n\n有时我们不想让目标元素的事件冒泡到上级，我们可以对目标元素的事件设置阻止冒泡的方法，即使用`event.stopPropagation`方法来阻止事件冒泡。\n\n```javascript\nvar clickInner = document.getElementById('inner');\nvar clickOuter = document.getElementById('outer');\nclickInner.addEventListener('click',function(event){\n    alert('inner show');\n    event.stopPropagation();\n},false);\nclickOuter.addEventListener('click',function(){\n    alert('outer show');\n},false);\n//inner show\n```\n","tags":["面试"],"categories":["前端"]},{"title":"CSS引入的四种方式","url":"%2F2017%2F04%2F16%2Farticle-45%2F","content":"在HTML中引入CSS样式有四种方式，分别是行内式、嵌入式、链接式和导入式。\n\n<!--more-->\n\n## 行内式\n在元素的标签的style属性中设定CSS样式，这种写法不利于维护，适用于给某个单独标签设定其独有的样式。\n\n```html\n<div style=\"background: red;\"></div>\n```\n\n## 嵌入式\n这种方式是通过style标签将CSS样式整体写在html中，当网站为单一页面且样式不多时可以使用该方法。\n\n```html\n<style type=\"text/css\">\n  body {\n    margin: 0 auto;\n  }\n</style>\n```\n\n## 链接式\n链接式的CSS样式引入是最常见和常用的CSS样式引入方法，通过link标签将外部的CSS引入到HTML文件中。\n\n```html\n<link rel=\"stylesheet\" type=\"text/css\" href=\"css/main.css\">\n```\n\n## 导入式\n这种写法通过`@import`关键字将外部的CSS文件导入到CSS样式当中。\n\n```html\n<style type=\"text/css\">\n  @import 'css/main.css';\n</style>\n```\n\n## 链接式和导入式区别\n这里说链接式和导入式的区别，主要是指link和import的区别。\n\nlink属于html的标签，除了加载CSS之外还可以定义RSS，定义rel连接属性等作用，而@import只能用于加载CSS。\n\n另外，link引入的CSS会在页面加载的时候同时加载，而@import导入的CSS则是等页面加载完成之后再加载，所以当页面比较复杂时可能会出现先是无样式的HTML，闪烁一下后才出现CSS样式。\n\n","tags":["面试"],"categories":["前端"]},{"title":"雅虎军规：网站性能优化","url":"%2F2017%2F04%2F16%2Farticle-44%2F","content":"提到网站性能优化，最出名的莫过于雅虎军规，这里将其35条规则列出。\n\n<!--more-->\n\n## 目录\n1. 尽量减少HTTP请求数\n2. 使用CDN（Content Delivery Network）\n3. 添上Expires或者Cache-Control HTTP头\n4. Gzip组件\n5. 把样式表放在顶部\n6. 把脚本放在底部\n7. 避免使用CSS表达式\n8. 把JavaScript和CSS放到外面\n9. 减少DNS查找\n10. 压缩JavaScript和CSS\n11. 避免重定向\n12. 去除重复脚本\n13. 配置ETags\n14. 让Ajax可缓存\n15. 尽早清空缓冲区\n16. 对Ajax用GET请求\n17. 延迟加载组件\n18. 预加载组件\n19. 减少DOM元素的数量\n20. 跨域分离组件\n21. 尽量少用iframe\n22. 杜绝404\n23. 给Cookie减肥\n24. 把组件放在不含cookie的域下\n25. 尽量减少DOM访问\n26. 用智能的事件处理器\n27. 选择 舍弃@import\n28. 避免使用滤镜\n29. 优化图片\n30. 优化CSS Sprite\n31. 不要用HTML缩放图片\n32. 用小的可缓存的favicon.ico\n33. 保证所有组件都小于25K\n34. 把组件打包到一个复合文档里\n35. 避免图片src属性为空\n\n## 尽量减少HTTP请求数\n减少页面组件数的一种方式是简化页面设计。但对于复杂页面来说，可以通过合并文件来减少HTTP请求数。\n\nCSS Sprites 是减少图片请求数量的首选方式。把背景图片都整合到一张图片中，然后用CSS的 background-image 和 background-position 属性来定位要显示的部分。\n\n行内图片（Base64编码）是用 data: URL模式 来把图片嵌入页面。这样会增加HTML文件的大小，把行内图片放在（缓存的）样式表中是个好办法，而且成功避免了页面变“重”。但目前主流浏览器并不能很好地支持行内图片。\n\n## 使用CDN（Content Delivery Network）\n内容分发网络（CDN）是一组分散在不同地理位置的web服务器，用来给用户更高效地发送内容。典型地，选择用来发送内容的服务器是基于网络距离的衡量标准的。例如：选跳数（hop）最少的或者响应时间最快的服务器。\n\n## 添上Expires或者Cache-Control HTTP头\n这条规则有两个方面：\n- 对于静态组件：通过设置一个遥远的将来时间作为 Expires 来实现永不失效\n- 多余动态组件：用合适的 Cache-Control HTTP头来让浏览器进行条件性的请求\n\n浏览器（和代理）用缓存来减少HTTP请求的数目和大小，让页面能够更快加载。web服务器通过有效期HTTP响应头来告诉客户端，页面的各个组件应该被缓存多久。\n\n## Gzip组件\n从HTTP/1.1开始，web客户端就有了支持压缩的Accept-Encoding HTTP请求头。\n`Accept-Encoding: gzip, deflate`\n如果web服务器看到这个请求头，它就会用客户端列出的一种方式来压缩响应。web服务器通过Content-Encoding相应头来通知客户端。\n`Content-Encoding: gzip`\n\n## 把样式表放在顶部\n把样式表放到文档的HEAD部分能让页面看起来加载地更快。这是因为把样式表放在head里能让页面逐步渲染。\n\n在很多浏览器（包括IE）中，把样式表放在HTML文档底部都会阻止页面逐渐渲染。这些浏览器阻塞渲染过程，以避免因为样式变动而重绘页面元素，用户这时就只能盯着空白页面。\n\n## 把脚本放在底部\n脚本会阻塞并行下载， HTTP/1.1官方文档 建议浏览器每个主机名下并行下载的组件数不要超过两个，如果图片来自多个主机名，并行下载的数量就可以超过两个。如果脚本正在下载，浏览器就不开始任何其它下载任务，即使是在不同主机名下的。\n\n## 避免使用CSS表达式\n用CSS表达式动态设置CSS属性，是一种强大又危险的方式。表达式最大的问题是它们经常被重复计算，比我们想象的次数还要多。不仅仅是页面渲染和调整大小的时候，在页面被滚动，甚至用户在页面上移动鼠标时都会重新计算表达式。给CSS表达式添加一个计数器就可以追踪它重新计算的时间和频率，而在页面上动动鼠标就可以引发10000多次重新计算。\n\n## 把JavaScript和CSS放到外面\n实际上，用外部文件可以让页面更快，因为JavaScript和CSS文件会被缓存在浏览器。HTML文档中的行内JavaScript和CSS在每次请求该HTML文档的时候都会重新下载。这样做减少了所需的HTTP请求数，但增加了HTML文档的大小。另一方面，如果JavaScript和CSS在外部文件中，并且已经被浏览器缓存起来了，那么我们就成功地把HTML文档变小了，而且还没有增加HTTP请求数。\n\n\n## 减少DNS查找\nDNS查找被缓存起来更高效，由用户的ISP（网络服务提供商）或者本地网络存在一个特殊的缓存服务器上，但还可以缓存在个人用户的计算机上。DNS信息被保存在操作系统的DNS cache(微软Windows上的”DNS客户端服务”)里。大多数浏览器有独立于操作系统的自己的cache。只要浏览器在自己的cache里还保留着这条记录，它就不会向操作系统查询DNS。\n\nIE默认缓存DNS查找30分钟，写在 DnsCacheTimeout 注册表设置中。Firefox缓存1分钟，可以用 network.dnsCacheExpiration 配置项设置。(Fasterfox把缓存时间改成了1小时 P.S. Fasterfox是FF的一个提速插件)\n\n如果客户端的DNS cache是空的（包括浏览器的和操作系统的），DNS查找数等于页面上不同的主机名数，包括页面URL，图片，脚本文件，样式表，Flash对象等等组件中的主机名，减少不同的主机名就可以减少DNS查找。\n\n减少不同主机名的数量同时也减少了页面能够并行下载的组件数量，避免DNS查找削减了响应时间，而减少并行下载数量却增加了响应时间。我的原则是把组件分散在2到4个主机名下，这是同时减少DNS查找和允许高并发下载的折中方案。\n\n## 压缩JavaScript和CSS\n压缩具体来说就是从代码中去除不必要的字符以减少大小，从而提升加载速度。代码最小化就是去掉所有注释和不必要的空白字符（空格，换行和tab）。在JavaScript中这样做能够提高响应性能，因为要下载的文件变小了。两个最常用的JavaScript代码压缩工具是 JSMin 和 YUI Compressor ，YUI compressor还可以压缩CSS。\n\n## 避免重定向\n重定向用301和302状态码，下面是一个有301状态码的HTTP头：\n\n```\nHTTP/1.1 301 Moved Permanently\n      Location: http://example.com/newuri\n      Content-Type: text/html\n```\n浏览器会自动跳转到 Location 域指明的URL。重定向需要的所有信息都在HTTP头部，而响应体一般是空的。其实额外的HTTP头，比如 Expires 和 Cache-Control 也表示重定向。除此之外还有别的跳转方式：refresh元标签和JavaScript，但如果你必须得做重定向，最好用标准的3xxHTTP状态码，主要是为了让返回按钮能正常使用。\n\n牢记重定向会拖慢用户体验，在用户和HTML文档之间插入重定向会延迟页面上的所有东西，页面无法渲染，组件也无法开始下载，直到HTML文档被送达浏览器。\n\n有一种常见的极其浪费资源的重定向，而且web开发人员一般都意识不到这一点，就是URL尾部缺少一个斜线的时候。例如，跳转到 http://astrology.yahoo.com/astrology 会返回一个重定向到 http://astrology.yahoo.com/astrology/ 的301响应（注意添在尾部的斜线）。在Apache中可以用 Alias ， mod_rewrite 或者 DirectorySlash 指令来取消不必要的重定向。\n\n重定向最常见的用途是把旧站点连接到新的站点，还可以连接同一站点的不同部分，针对用户的不同情况（浏览器类型，用户帐号类型等等）做一些处理。用重定向来连接两个网站是最简单的，只需要少量的额外代码。虽然在这些时候使用重定向减少了开发人员的开发复杂度，但降低了用户体验。一种替代方案是用 Alias 和 mod_rewrite ，前提是两个代码路径都在相同的服务器上。如果是因为域名变化而使用了重定向，就可以创建一条CNAME（创建一个指向另一个域名的DNS记录作为别名）结合 Alias 或者 mod_rewrite 指令。\n\n## 去除重复脚本\n页面含有重复的脚本文件会影响性能，这可能和你想象的不一样。在对美国前10大web站点的评审中，发现只有2个站点含有重复脚本。两个主要原因增加了在单一页面中出现重复脚本的几率：团队大小和脚本数量。在这种情况下，重复脚本会创建不必要的HTTP请求，执行无用的JavaScript代码，而影响页面性能。\n\n## 配置ETags\n实体标签（ETags），是服务器和浏览器用来决定浏览器缓存中组件与源服务器中的组件是否匹配的一种机制（“实体”也就是组件：图片，脚本，样式表等等）。添加ETags可以提供一种实体验证机制，比最后修改日期更加灵活。一个ETag是一个字符串，作为一个组件某一具体版本的唯一标识符。唯一的格式约束是字符串必须用引号括起来，源服务器用相应头中的 ETag 来指定组件的ETag：\n\n```\nHTTP/1.1 200 OK\n      Last-Modified: Tue, 12 Dec 2006 03:03:59 GMT\n      ETag: \"10c24bc-4ab-457e1c1f\"\n      Content-Length: 12195\n```\n然后，如果浏览器必须验证一个组件，它用 If-None-Match 请求头来把ETag传回源服务器。如果ETags匹配成功，会返回一个304状态码，这样就减少了12195个字节的响应体。\n\n```\nGET /i/yahoo.gif HTTP/1.1\n      Host: us.yimg.com\n      If-Modified-Since: Tue, 12 Dec 2006 03:03:59 GMT\n      If-None-Match: \"10c24bc-4ab-457e1c1f\"\n      HTTP/1.1 304 Not Modified\n```\nETags存在的问题是它们是由特定服务器构造的，所以如果浏览器从一个服务器获取最初的组件，然后想验证另一个服务器上的相同组件，ETags是无法匹配成功的，而用一群服务器处理请求在web站点中又非常普遍。\n\n## 让Ajax可缓存\nAjax的一个好处是可以给用户提供即时反馈，因为它能够从后台服务器异步请求信息。然而，用了Ajax就无法保证用户在等待异步JavaScript和XML响应返回期间不会非常无聊。在很多应用程序中，用户能够一直等待取决于如何使用Ajax。例如，在基于web的电子邮件客户端中，用户为了寻找符合他们搜索标准的邮件消息，将会保持对Ajax请求返回结果的关注。重要的是，要记得“异步”并不意味着“即时”。\n\n我们一起看看例子，一个Web 2.0的电子邮件客户端用了Ajax来下载用户的通讯录，以便实现自动完成功能。如果用户从上一次使用之后再没有修改过她的通讯录，而且Ajax响应是可缓存的，有尚未过期的Expires或者Cache-Control HTTP头，那么之前的通讯录就可以从缓存中读出。必须通知浏览器，应该继续使用之前缓存的通讯录响应，还是去请求一个新的。可以通过给通讯录的Ajax URL里添加一个表明用户通讯录最后修改时间的时间戳来实现，例如 &t=1190241612 。如果通讯录从上一次下载之后再没有被修改过，时间戳不变，通讯录就将从浏览器缓存中直接读出，从而避免一次额外的HTTP往返消耗。如果用户已经修改了通讯录，时间戳也可以确保新的URL不会匹配缓存的响应，浏览器将请求新的通讯录条目。\n\n## 尽早清空缓冲区\n当用户请求一个页面时，服务器需要用大约200到500毫秒来组装HTML页面，在这期间，浏览器闲等着数据到达。PHP中有一个 flush() 函数，允许给浏览器发送一部分已经准备完毕的HTML响应，以便浏览器可以在后台准备剩余部分的同时开始获取组件，好处主要体现在很忙的后台或者很“轻”的前端页面上（P.S. 也就是说，响应时耗主要在后台方面时最能体现优势）。\n\n## 对Ajax用GET请求\nYahoo!邮箱 团队发现使用 XMLHttpRequest 时，浏览器的POST请求是通过一个两步的过程来实现的：先发送HTTP头，在发送数据。所以最好用GET请求，它只需要发送一个TCP报文（除非cookie特别多）。IE的URL长度最大值是2K，所以如果要发送的数据超过2K就无法使用GET了。\n\nPOST请求的一个有趣的副作用是实际上没有发送任何数据，就像GET请求一样。正如 HTTP说明文档 中描述的，GET请求是用来检索信息的。所以它的语义只是用GET请求来请求数据，而不是用来发送需要存储到服务器的数据。\n\n## 延迟加载组件\nJavaScript是分隔onload事件之前和之后的一个理想选择。例如，如果有JavaScript代码和支持拖放以及动画的库，这些都可以先等会儿，因为拖放元素是在页面最初渲染之后的。其它可以延迟加载的部分包括隐藏内容（在某个交互动作之后才出现的内容）和折叠的图片。\n\n## 预加载组件\n预加载可能看起来和延迟加载是相反的，但它其实有不同的目标。通过预加载组件可以充分利用浏览器空闲的时间来请求将来会用到的组件（图片，样式和脚本）。用户访问下一页的时候，大部分组件都已经在缓存里了，所以在用户看来页面会加载得更快。\n\n实际应用中有以下几种预加载的类型：\n\n- 无条件 预加载——尽快开始加载，获取一些额外的组件。google.com就是一个sprite图片预加载的好例子，这个sprite图片并不是google.com主页需要的，而是搜索结果页面上的内容。\n- 条件性 预加载——根据用户操作猜测用户将要跳转到哪里并据此预加载。在 search.yahoo.com 的输入框里键入内容后，可以看到那些额外组件是怎样请求加载的。\n- 提前 预加载——在推出新设计之前预加载。经常在重新设计之后会听到：“这个新网站不错，但比以前更慢了”，一部分原因是用户访问先前的页面都是有旧缓存的，但新的却是一种空缓存状态下的体验。可以通过在将要推出新设计之前预加载一些组件来减轻这种负面影响，老站可以利用浏览器空闲的时间来请求那些新站需要的图片和脚本。\n\n## 减少DOM元素的数量\n一个复杂的页面意味着要下载更多的字节，而且用JavaScript访问DOM也会更慢。举个例子，想要添加一个事件处理器的时候，循环遍历页面上的500个DOM元素和5000个DOM元素是有区别的。\n\n大量的DOM元素是一种征兆——页面上有些内容无关的标记需要清理。正在用嵌套表格来布局吗？还是为了修复布局问题而添了一堆的` <div> `或许应该用更好的语义化标记。\n\n## 跨域分离组件\n分离组件可以最大化并行下载，但要确保只用不超过2-4个域，因为存在DNS查找的代价。例如，可以把HTML和动态内容部署在 `www.example.org` ，而把静态组件分离到 `static1.example.org` 和 `static2.example.org` 。\n\n## 尽量少用iframe\n用iframe可以把一个HTML文档插入到父文档里，重要的是明白iframe是如何工作的并高效地使用它。\n\n`<iframe>` 的优点：\n- 引入缓慢的第三方内容，比如标志和广告\n- 安全沙箱\n- 并行下载脚本\n\n`<iframe>` 的缺点：\n- 代价高昂，即使是空白的iframe\n- 阻塞页面加载\n- 非语义\n\n## 杜绝404\nHTTP请求代价高昂，完全没有必要用一个HTTP请求去获取一个无用的响应（比如404 Not Found），只会拖慢用户体验而没有任何好处。\n\n## 给Cookie减肥\n使用cookie的原因有很多，比如授权和个性化。HTTP头中cookie信息在web服务器和浏览器之间交换。重要的是保证cookie尽可能的小，以最小化对用户响应时间的影响。\n\n相关经验原则可以总结如下：\n- 清除不必要的cookie\n- 保证cookie尽可能小，以最小化对用户响应时间的影响\n- 注意给cookie设置合适的域级别，以免影响其它子域\n- 设置合适的有效期，更早的有效期或者none可以更快的删除cookie，提高用户响应时间\n\n## 把组件放在不含cookie的域下\n当浏览器发送对静态图像的请求时，cookie也会一起发送，而服务器根本不需要这些cookie。所以它们只会造成没有意义的网络通信量，应该确保对静态组件的请求不含cookie。可以创建一个子域，把所有的静态组件都部署在那儿。\n\n## 尽量减少DOM访问\n用JavaScript访问DOM元素是很慢的，所以，为了让页面反应更迅速，应该：\n- 缓存已访问过的元素的索引\n- 先“离线”更新节点，再把它们添到DOM树上\n- 避免用JavaScript修复布局问题\n\n## 用智能的事件处理器\n有时候感觉页面反映不够灵敏，是因为有太多频繁执行的事件处理器被添加到了DOM树的不同元素上，这就是推荐使用 事件委托 的原因。如果一个 `div` 里面有10个按钮，应该只给div容器添加一个事件处理器，而不是给每个按钮都添加一个。事件能够冒泡，所以可以捕获事件并得知哪个按钮是事件源。\n\n## 选择 舍弃@import\n前面提到了一个最佳实践：为了实现逐步渲染，CSS应该放在顶部。\n\n在IE中用 `@import` 与在底部用 `<link>` 效果一样，所以最好不要用它。\n\n## 避免使用滤镜\nIE专有的 `AlphaImageLoader` 滤镜可以用来修复IE7之前的版本中半透明PNG图片的问题。在图片加载过程中，这个滤镜会阻塞渲染，卡住浏览器，还会增加内存消耗而且是被应用到每个元素的，而不是每个图片，所以会存在一大堆问题。\n\n最好的方法是干脆不要用 `AlphaImageLoader`，而优雅地降级到用在IE中支持性很好的PNG8图片来代替。如果非要用`AlphaImageLoader` ，应该用下划线hack：`_filter` 来避免影响IE7及更高版本的用户。\n\n## 优化图片\n设计师做好图片后，在把这些图片通过FTP上传到web服务器之前，我们还可以做一些事情。\n- 检查GIF图片，看看图片中是不是用了调色板大小对应的颜色数，\n如果4色图片用了调色板中256色的“槽”，那就还有改进的余地。\n- 试着把GIF图片转换成PNG，看能不能缩减大小，往往可以。开发者通常不愿意用PNG图片，因为浏览器支持有限，但这都是过去的事情了。真正的问题是PNG图片完全支持alpha透明度，而GIF图片却不支持透明度渐变，所以GIF能做的任何事情，PNG都可以（除了动画）。\n- 对图片进行压缩处理等。\n\n## 优化CSS Sprite\n- 在Sprite图片中横向排列一般都比纵向排列的最终文件小\n- 组合Sprite图片中的相似颜色可以保持低色数，最理想的是256色以下PNG8格式\n- “对移动端友好”，不要在Sprite图片中留下太大的空隙。虽然不会在很大程度上影响图片文件的大小，但这样做可以节省用户代理把图片解压成像素映射时消耗的内存。100×100的图片是1万个像素，而1000×1000的图片就是100万个像素了。\n\n## 不要用HTML缩放图片\n不要因为在HTML中可以设置宽高而使用本不需要的大图。\n\n## 用小的可缓存的favicon.ico\nfavicon.ico是放在服务器根目录的图片，它会带来一堆麻烦，因为即便你不管它，浏览器也会自动请求它，所以最好不要给一个`404 Not Found`响应。而且只要在同一个服务器上，每次请求它时都会发送cookie，此外这个图片还会干扰下载顺序，例如在IE中，当你在onload中请求额外组件时，将会先下载favicon。\n\n所以为了缓解favicon.ico的缺点，应该确保：\n- 足够小，最好在1K以下\n- 设置合适的有效期HTTP头（以后如果想换的话就不能重命名了），把有效期设置为几个月后一般比较安全，可以通过检查当前favicon.ico的最后修改日期来确保变更能让浏览器知道。\n\n## 保证所有组件都小于25K\n这个限制是因为iPhone不能缓存大于25K的组件，注意这里指的是 未压缩的 大小。这就是为什么缩减内容本身也很重要，因为单纯的gzip可能不够。\n\n## 把组件打包到一个复合文档里\n把各个组件打包成一个像有附件的电子邮件一样的复合文档里，可以用一个HTTP请求获取多个组件（记住一点：HTTP请求是代价高昂的）。用这种方式的时候，要先检查用户代理是否支持（iPhone就不支持）。\n\n## 避免图片src属性为空\n当图片的src属性为空时，浏览器会向服务器发送另一个请求。\n- IE 向页面所在目录发起一个请求\n- Safari和Chrome 想当前页面本身发送一个请求\n- Firefox 3及更早版本与Safari和Chrome处理方式一样，但3.5解决了这个问题，不会再发送请求了\n- Opera 遇到有空src属性的图片不做任何处理\n\n为什么图片的src属性为空不好？\n- 意外发送大量的通信量对服务器来说是很伤的，尤其是在每天有几百万访问量页面的时候。\n- 浪费服务器资源去生成一个根本不可能被看到的页面。\n- 可能会污染用户数据，如果追踪请求状态，要么通过cookie要么是其它方式，可能会破坏用户数据。即使图片请求并没有返回图片，整个HTTP头部也会被浏览器接受并读取，包括所有的cookie。虽然其余部分会被丢弃，但这可能已经造成破坏了。\n\n\n\n","tags":["SEO"],"categories":["前端"]},{"title":"JS原型和原型链","url":"%2F2017%2F04%2F16%2Farticle-43%2F","content":"JS原型和原型链是JS开发中重要的一个点，通常通过原型继承来实现面向对象的开发。\n\n通过查阅资料和比较，最终也算是对此有了稍微的理解。这里主要推荐一下这篇文章——[JS原型与原型链终极详解](http://www.108js.com/article/article1/10201.html?id=1092)。\n\n<!--more-->\n\n## 原型对象\n在JavaScript中，通过`new Function()`创建的对象拥有一个`prototype`属性，该属性也是一个对象，即原型对象。注意这里是通过`new Function()`创建的对象，对于`new Object()`创建的对象是没有原型对象的属性的，但是会有一个`__proto__`属性。\n\n关于原型对象的作用，主要是用来实现对象之间的继承，给出下面的例子。\n\n```javascript\nvar person = function(name){\n  this.name = name\n};\nperson.prototype.getName = function(){\n  return this.name; \n}\nvar zjh = new person(‘zhangjiahao’);\nzjh.getName(); //zhangjiahao\n```\n这里通过给person的原型对象添加一个获取名字的方法来使其他的person对象拥有该方法。具体的继承实现，则是通过原型链来实现。\n\n## 原型链\nJavaScript中的每一个对象都有一个`__proto__`属性，该属性会指向创建它的对象的原型对象，而原型对象的`__proto__`属性又会指向创建它的对象的原型对象。即可以得到如下关系图：\n\n![图像加载失败](http://oetmrek6t.bkt.clouddn.com/article_43_1.jpg)\n\n在该图中，zjh的`__proto__`属性指向person的原型，person原型的`__proto__`属性指向object的原型，最终object原型的`__proto__`属性指向`null`，该原型链结束。\n\n下图分析了内存中的结构图，其中蓝色方框即为通过`new Function()`创建的对象，蓝色椭圆框为`new Object()`创建的对象，白色方框为对象的属性，红色虚线框为不存在的属性。\n\n![图像加载失败](http://oetmrek6t.bkt.clouddn.com/article_43_2.jpg)\n\n\n\n","tags":["面试"],"categories":["前端"]},{"title":"HTML标签的语义化","url":"%2F2017%2F04%2F16%2Farticle-42%2F","content":"## 什么是HTML标签的语义化\nHTML标签的语义化就是根据元素内容来选择符合语义的标签，即用正确的标签做正确的事。\n\n<!--more-->\n\n## 语义化的好处\n- HTML语义化让页面的内容结构化，使结构更加清晰，便于对浏览器、搜索引擎解析。\n- 即使在没有CSS样式的情况下也能以一种文档格式显示，并且是容易阅读的。\n- 搜索引擎的爬虫也依赖于HTML标记来确定上下文和各个关键字的权重，利于SEO。\n- 使阅读源代码的人对网站更容易将网站分块，便于阅读维护和理解。\n\n## 需要注意的\n- 尽可能少的使用无语义的标签div和span；\n- 在语义不明显时，既可以使用div或者p时，尽量用p,因为p在默认情况下有上下间距，对兼容特殊终端有利；\n- 不要使用纯样式标签，如：b、font、u等，改用css设置。\n- 需要强调的文本，可以包含在strong或者em标签中（浏览器预设样式，能用CSS指定就不用他们），strong默认样式是加粗（不要用b），em是斜体（不用i）；\n- 使用表格时，标题要用caption，表头用thead，主体部分用tbody包围，尾部用tfoot包围。表头和一般单元格要区分开，表头用th，单元格用td；\n- 表单域要用fieldset标签包起来，并用legend标签说明表单的用途；\n- 每个input标签对应的说明文本都需要使用label标签，并且通过为input设置id属性，在lable标签中设置for=someld来让说明文本和相对应的input关联起来。\n\n## HTML5新增语义标签\n例如`<header>`,`<nav>`,`<article>`,`<section>`,`<footer>`,`<aside>`,`<hgroup>`,`<address>`,`<time>`,`<details>`等等。\n\n","tags":["SEO"],"categories":["前端"]},{"title":"Vue组件间通信","url":"%2F2017%2F04%2F06%2Farticle-41%2F","tags":["VUE"],"categories":["前端"]},{"title":"HTML5应用程序缓存","url":"%2F2017%2F03%2F10%2Farticle-40%2F","content":"HTML5提供了一个manifest属性来实现应用程序的缓存，如需启用应用程序缓存，直接在`<html>`标签中加上manifest属性：\n\n```html\n<!DOCTYPE HTML>\n<html manifest=\"demo.appcache\">\n...\n</html>\n```\n需要注意的是，manifest 文件需要配置正确的 MIME-type，即 \"text/cache-manifest\"。必须在 web 服务器上进行配置。\n\n<!--more-->\n\n## Manifest文件详解\nmanifest 文件可分为三个部分：\n- CACHE MANIFEST - 在此标题下列出的文件将在首次下载后进行缓存\n- NETWORK - 在此标题下列出的文件需要与服务器的连接，且不会被缓存\n- FALLBACK - 在此标题下列出的文件规定当页面无法访问时的回退页面（比如 404 页面）\n\n### CACHE MANIFEST\n第一行，CACHE MANIFEST，是必需的：\n\n```\nCACHE MANIFEST\n/theme.css\n/logo.gif\n/main.js\n```\n上面的 manifest 文件列出了三个资源：一个 CSS 文件，一个 GIF 图像，以及一个 JavaScript 文件。当 manifest 文件加载后，浏览器会从网站的根目录下载这三个文件。然后，无论用户何时与因特网断开连接，这些资源依然是可用的。\n\n### NETWORK\n可以使用星号来指示所有其他资源/文件都需要因特网连接：\n\n```\nNETWORK:\nlogin.asp\n*\n```\n\n### FALLBACK\n下面的 FALLBACK 小节规定如果无法建立因特网连接，则用 \"404.html\" 替代 /html5/ 目录中的所有文件：\n\n```\nFALLBACK:\n/html5/ /404.html\n```\n\n### 更新缓存\n一旦应用被缓存，它就会保持缓存直到发生下列情况：\n- 用户清空浏览器缓存\n- manifest 文件被修改\n- 由程序来更新应用缓存\n\n### 实例\n以 \"#\" 开头的是注释行，但也可满足其他用途。应用的缓存会在其 manifest 文件更改时被更新。如果您编辑了一幅图片，或者修改了一个 JavaScript 函数，这些改变都不会被重新缓存。更新注释行中的日期和版本号是一种使浏览器重新缓存文件的办法。\n\n```\nCACHE MANIFEST\n# 2012-02-21 v1.0.0\n/theme.css\n/logo.gif\n/main.js\n\nNETWORK:\nlogin.asp\n\nFALLBACK:\n/html5/ /404.html\n```\n","tags":["面试"],"categories":["前端"]},{"title":"【2017春招】阿里weex团队前端一面","url":"%2F2017%2F03%2F10%2Farticle-39%2F","content":"虽然面试主要是在聊简历上的项目，但是因为是weex团队，所以问了很多移动端相关的问题，其他的一些问题就是在项目中可能遇到的情况。项目相关问题暂未列出。\n\n<!--more-->\n\n面试问题如下（不分先后）：\n\n[JS如何实现继承](2017/04/16/article-43/)\n\n[JS中的三个事件主要是指什么](2017/04/16/article-46/)\n\n[如何解决前端跨域问题](2017/03/10/article-34/)\n\n[如何实现一个轮播图]()\n\n[前端如何做网站性能优化](2017/04/16/article-44/)\n\n[如何做移动端的字体自适应]()\n\n[谈谈对vue的理解](https://cn.vuejs.org/v2/guide/)\n\n[谈谈对weex的想法](http://weex.apache.org/cn/)\n\n[移动端的轮播图滑动如何实现]()\n\n[express和koa框架有什么区别]()\n\n[canvas如何绘制一张图片]()\n\n[websocket如何实现的]()\n\n[packge.json包含哪些属性](http://javascript.ruanyifeng.com/nodejs/packagejson.html)\n\n[原生的AJAX如何实现](2017/04/16/article-47/)\n\n[如何复制一个对象]()\n\n[什么是伪数组]()\n\n[如何实现一个元素的垂直居中](2017/03/10/article-37/)\n\n[如何实现懒加载]()\n\n[CSS3的动画如何实现](http://www.w3school.com.cn/css3/css3_animation.asp)\n\n[有没有用过reset.css](https://yq.aliyun.com/articles/25739)\n","tags":["webpack"],"categories":["面试"]},{"title":"【2017春招】腾讯AlloyTeam前端一面","url":"%2F2017%2F03%2F10%2Farticle-38%2F","content":"2017腾讯AlloyTeam前端开发面试问的也都是基础为主，但是基本没有问HTML和CSS相关的问题，因为他们这个团队招的前端主要以JS为主，所以问的大都是关于JS相关的问题。\n\n<!--more-->\n\n面试问题如下（不分先后）：\n\n[JS如何实现原型继承](2017/04/16/article-43/)\n\n[JS中的三个事件主要是指什么](2017/04/16/article-46/)\n\n[如何解决前端跨域问题](2017/03/10/article-34/)\n\n[如何理解JS中的闭包](2016/09/18/article-7/)\n\n[前端如何做网站性能优化](2017/04/16/article-44/)\n\n[说一说Promise的用法](2017/03/09/article-32/)\n\n[有没有用过ES6的语法](2017/03/09/article-32/)\n\n[JS的基本数据类型有哪些](http://www.w3school.com.cn/js/pro_js_primitivetypes.asp)\n\n[原生的AJAX怎么写](2017/04/16/article-47/)\n\n[JQuery的ajax需要传递哪些参数](2017/04/16/article-47/)\n","tags":["SEO"],"categories":["面试"]},{"title":"前端必会的垂直居中","url":"%2F2017%2F03%2F10%2Farticle-37%2F","content":"垂直居中，这是在前端中会经常遇到的问题，同时也是面试前端开发中必问的问题。这里总结一下几种常用的使元素垂直居中的方法。\n\n<!--more-->\n\n## 使用绝对定位实现垂直居中\n使用绝对定位的垂直居中方法，是块级元素最常见也是最常用的一种办法。\n在子元素的宽高未知时垂直居中：\n\n```css\n.div {  \n  margin: auto;  \n  position: absolute;  \n  top: 0; \n  left: 0; \n  bottom: 0; \n  right: 0;  \n}  \n```\n子元素的宽高已知时的垂直居中：\n\n```css\n.div {  \n  position: absolute;  \n  top: 50%; \n  left: 50%; \n  width: 400px;\n  height: 200px;\n  margin-top: -100px;\n  margin-left: -200px; \n}  \n```\n## 使用transform属性实现垂直居中\n使用transform属性实现的元素垂直居中，与绝对定位类似。不过因为CSS3属性的缘故，用此方法要考虑浏览器的兼容性。\n\n```css\n.div {  \n  position: absolute;  \n  top: 50%; \n  left: 50%; \n  transform: translate(-50%, -50%);\n  -webkit-transform: translate(-50%, -50%);\n  -moz-transform: translate(-50%, -50%);\n  -ms-transform: translate(-50%, -50%);\n}  \n```\n## 使用单元表格来垂直居中\n这个方法是通过使用`display: table-cell`的属性来让元素像表格单元一样显示，该方法需要对居中元素添加额外的父元素。\n\n```css\n.father {\n  display: table-cell;\n  vertical-align: middle;\n}\n.son {\n  vertical-align: middle;\n}\n```\n## 使用FlexBox的新属性实现\n此方法是使用CSS3的新属性flex来实现垂直居中，该属性目前兼容性已经比较完善，同时用它也来完成很多响应式的设计，所以记住该方法还是很有必要的。\n推荐一下另一篇文章：[flex布局的用法]()\n\n```css\n.box {\n  display: flex;\n  justify-content: center;\n  align-items: center;\n}\n```\n\n## 对于行内元素的垂直居中\n对于行内元素的垂直居中，需要对父元素设置`text-align: center`属性,这样行内元素已经可以实现水平居中，再为了实现垂直居中，只需要为行内元素添加`vertical-align: center`属性就行。\n\n```css\n.father {\n  text-align: center;\n}\n.son {\n  display: inline-block;\n  vertical-align: middle;\n}\n```\n","tags":["CSS3"],"categories":["前端"]},{"title":"JS获取屏幕的大小","url":"%2F2017%2F03%2F10%2Farticle-36%2F","content":"使用JavaScript获取屏幕的宽高。\n\n包括屏幕分辨率大小，浏览器可视区域大小，网页被卷起的大小，网页正文部分大小等。\n\n<!--more-->\n\n```html\n<html>\n<script>\n  function a(){\n    document.write(\n      \"屏幕分辨率为：\"+screen.width+\"*\"+screen.height\n      +\"<br />\"+\n      \"屏幕可用大小：\"+screen.availWidth+\"*\"+screen.availHeight\n      +\"<br />\"+\n      \"网页可见区域宽：\"+document.body.clientWidth\n      +\"<br />\"+\n      \"网页可见区域高：\"+document.body.clientHeight\n      +\"<br />\"+\n      \"网页可见区域宽(包括边线的宽)：\"+document.body.offsetWidth \n      +\"<br />\"+\n      \"网页可见区域高(包括边线的宽)：\"+document.body.offsetHeight \n      +\"<br />\"+\n      \"网页正文全文宽：\"+document.body.scrollWidth\n      +\"<br />\"+\n      \"网页正文全文高：\"+document.body.scrollHeight\n      +\"<br />\"+\n      \"网页被卷去的高：\"+document.body.scrollTop\n      +\"<br />\"+\n      \"网页被卷去的左：\"+document.body.scrollLeft\n      +\"<br />\"+\n      \"网页正文部分上：\"+window.screenTop\n      +\"<br />\"+\n      \"网页正文部分左：\"+window.screenLeft\n      +\"<br />\"+\n      \"屏幕分辨率的高：\"+window.screen.height\n      +\"<br />\"+\n      \"屏幕分辨率的宽：\"+window.screen.width\n      +\"<br />\"+\n      \"屏幕可用工作区高度：\"+window.screen.availHeight\n      +\"<br />\"+\n      \"屏幕可用工作区宽度：\"+window.screen.availWidth\n    );\n  }\n</script>\n  <body onload=\"a()\" >\n  </body>\n</html>\n```","tags":["JavaScript"],"categories":["前端"]},{"title":"JS delete方法","url":"%2F2017%2F03%2F10%2Farticle-35%2F","content":"JavaScript中delete方式用来删除一个对象的属性。\n\n<!--more-->\n\ndelete 操作符与直接释放内存（只能通过解除引用来间接释放）没有关系。可查看内存管理页面。\n\n你可以使用 delete 操作符来删除一个隐式声明的全局变量,也就是没有使用 var 定义的全局变量.全局变量其实是global对象(window)的属性.\n\n如果 delete 操作符删除成功，则被删除的属性将从所属的对象上彻底消失。然后，如果该对象的原型链上有一个同名属性，则该对象会从原型链上继承该同名属性。\n\n有一些属性是无法被删除的，这些属性被称为 DontDelete.\n\n```javascript\nx = 42;        // 隐式声明的全局变量\nvar y = 43;    // 显式声明的全局变量\nmyobj = {\n  h: 4,    \n  k: 5\n}    \n\n// 隐式声明的全局变量可以被删除\ndelete x;       // 返回 true \n\n// 显式声明的全局变量不能被删除,该属性不可配置（not configurable）\ndelete y;       // 返回 false \n\n//内置对象的内置属性不能被删除\ndelete Math.PI; // 返回 false\n\n//用户定义的属性可以被删除\ndelete myobj.h; // 返回 true \n\n// myobj 是全局对象的属性，而不是变量\n//因此可以被删除\ndelete myobj;   // 返回 true\n\nfunction f() {\n  var z = 44;\n\n  // delete 方法无法删除变量，只能作用于对象的属性\n  delete z;     // returns false\n}\n```\n\n不能删除一个对象从原型继承而来的属性（不过可以从原型上直接删除它）。\n\n```javascript\nfunction Foo(){}\n Foo.prototype.bar = 42;\n var foo = new Foo();\n\n // 无效的操作\n delete foo.bar;       \n   \n // logs 42，继承的属性\n console.log(foo.bar);       \n    \n // 直接删除原型上的属性\n delete Foo.prototype.bar;\n \n // logs \"undefined\"，已经没有继承的属性\n console.log(foo.bar);\n```\n\n当你删除一个数组元素时，数组的 length 属性并不会变小。例如，如果你删除了a[3], a[4]仍然是a[4], a[3]成为undefined. 即便你删除了最后一个元素也是如此 (delete a[a.length-1]).\n\n当用 delete 操作符删除一个数组元素时，被删除的元素已经完全不属于该数组。下面的例子中， trees[3] 被使用delete彻底删除。\n\n```javascript\nvar trees = [\"redwood\",\"bay\",\"cedar\",\"oak\",\"maple\"];\ndelete trees[3];\nif (3 in trees) {\n   // 这里不会被执行\n}\n```\n\n\n","tags":["JavaScript"],"categories":["前端"]},{"title":"前端跨域请求原理","url":"%2F2017%2F03%2F10%2Farticle-34%2F","content":"前端的跨域请求，之前遇到过几次，但是都没有去好好整明白具体的原理和解决办法，前两天看到一篇文章，讲的很好，看完之后受益匪浅，转载记录一番。\n\n原文链接：[前端跨域请求原理及实践](http://tingandpeng.com/2016/09/05/%E5%89%8D%E7%AB%AF%E8%B7%A8%E5%9F%9F%E8%AF%B7%E6%B1%82%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E8%B7%B5/)\n\n<!--more-->\n\n## 什么是跨域请求\n浏览器的同源策略，出于防范跨站脚本的攻击(XSS)，禁止客户端脚本（如 JavaScript）对不同域的服务进行跨站调用。\n\n一般的，只要网站的 协议名`protocol`、 主机`host`、 端口号`port` 这三个中的任意一个不同，网站间的数据请求与传输便构成了跨域调用。\n\n## 利用JSONP解决跨域问题\n### 什么是JSONP\nJSONP 是 JSON 的一种使用模式，可以解决主流浏览器的跨域数据访问问题。其原理是根据 `XmlHttpRequest` 对象受到同源策略的影响，而 `<script>`标签元素却不受同源策略影响，可以加载跨域服务器上的脚本，网页可以从其他来源动态产生 JSON 资料。用 JSONP 获取的不是 JSON 数据，而是可以直接运行的 JavaScript 语句。\n\n### 使用jQuery中的ajax实现JSONP的调用\n请求代码：\n\n```javascript\n\n// 回调函数\nfunction jsonpCallback(data) {\n    console.log(\"jsonpCallback: \" + data.name)\n}\n$(\"#submit\").click(function() {\n    var data = {\n        name: $(\"#name\").val(),\n        id: $(\"#id\").val()\n    };\n    $.ajax({\n        url: 'http://localhost:3001/ajax/deal',\n        data: data,\n        dataType: 'jsonp',\n        cache: false,\n        timeout: 5000,\n        // jsonp 字段含义为服务器通过什么字段获取回调函数的名称\n        jsonp: 'callback',\n        // 声明本地回调函数的名称，jquery 默认随机生成一个函数名称\n        jsonpCallback: 'jsonpCallback',\n        success: function(data) {\n            console.log(\"ajax success callback: \" + data.name)\n        },\n        error: function(jqXHR, textStatus, errorThrown) {\n            console.log(textStatus + ' ' + errorThrown);\n        }\n    });\n});\n\n```\n\n服务器代码：\n\n```javascript\n\napp.get('/ajax/deal', function(req, res) {\n    console.log(\"server accept: \", req.query.name, req.query.id)\n    var data = \"{\" + \"name:'\" + req.query.name + \" - server 3001 process',\" + \"id:'\" + req.query.id + \" - server 3001 process'\" + \"}\"\n    var callback = req.query.callback\n    var jsonp = callback + '(' + data + ')'\n    console.log(jsonp)\n    res.send(jsonp)\n    res.end()\n})\n```\n这里一定要注意 data 中字符串拼接，不能直接将 JSON 格式的 data 直接传给回调函数，否则会发生编译错误： parsererror Error: jsonpCallback was not called。\n\n现在可以知道利用 JSONP 格式返回的值是一段要立即执行的 JavaScript 代码，通过执行这段代码来对数据进行处理，而不会像 ajax 的 XmlHttpRequest 那样可以监听不同事件对数据进行不同处理。\n\n### 使用script标签原生实现JSONP\n虽然 jQuery 的 JSONP 实现与 ajax 很像，但是原理却并不一样，只是 jQuery 对 JSONP 做了封装和转换使得它与 ajax 很像。\n\n在请求发送时查看HTTP请求头，我们会发现即使形式上使用的是 POST 方法来传输一个JSON数据，但是发送请求时还是会被转成 GET 请求，所以我们可以通过`script`标签来构造一个 GET 请求解决跨域的问题。\n\n```javascript\n<script src = 'http://localhost:3001/ajax/deal?callback=jsonpCallback&name=chiaki&id=3001&_=1473164876032'></script>\n```\n\n### JSONP使用的不足\n- 只能使用 GET 方法发起请求，这是由于 script 标签自身的限制决定的。\n- 不能很好的发现错误，并进行处理。与 Ajax 对比，由于不是通过 XmlHttpRequest 进行传输，所以不能注册 success、error 等事件监听函数。\n\n## 使用CORS实现跨域请求\n### 什么是CORS\nCross-Origin Resource Sharing（CORS）跨域资源共享是一份浏览器技术的规范，提供了 Web 服务从不同域传来沙盒脚本的方法，以避开浏览器的同源策略，是 JSONP 模式的现代版。与 JSONP 不同，CORS 除了 GET 要求方法以外也支持其他的 HTTP 要求。用 CORS 可以让网页设计师用一般的 XMLHttpRequest，这种方式的错误处理比 JSONP 要来的好。另一方面，JSONP 可以在不支持 CORS 的老旧浏览器上运作。现代的浏览器都支持 CORS。\n\n### CORS的实现\n请求代码：\n\n```javascript\n//正常的跨域请求\n$(function() {\n  $(\"#submit\").click(function() {\n    var data = {\n      name: $(\"#name\").val(),\n      id: $(\"#id\").val()\n    };\n    $.ajax({\n      type: 'POST',\n      data: data,\n      url: 'http://localhost:3001/cors',\n      dataType: 'json',\n      cache: false,\n      timeout: 5000,\n      success: function(data) {\n        console.log(data)\n      },\n      error: function(jqXHR, textStatus, errorThrown) {\n        console.log('error ' + textStatus + ' ' + errorThrown);\n      }\n    });\n  });\n});\n\n```\n服务器代码：\n\n```javascript\napp.post('/cors', function(req, res) {\n  res.header(\"Access-Control-Allow-Origin\", \"*\");\n  res.header(\"Access-Control-Allow-Headers\", \"X-Requested-With\");\n  res.header(\"Access-Control-Allow-Methods\", \"PUT,POST,GET,DELETE,OPTIONS\");\n  res.header(\"X-Powered-By\", ' 3.2.1')\n  res.header(\"Content-Type\", \"application/json;charset=utf-8\");\n  var data = {\n    name: req.body.name + ' - server 3001 cors process',\n    id: req.body.id + ' - server 3001 cors process'\n  }\n  console.log(data)\n  res.send(data)\n  res.end()\n})\n```\n可以看到，在服务器返回的请求头中设置CORS从而实现跨域请求。\n\n### CORS中属性分析\nAccess-Control-Allow-Origin\n- origin参数指定可以访问资源的URI。 浏览器必须执行此操作。对于没有凭证的请求，服务器可以将“*”指定为通配符，从而允许任何源访问资源。\n\nAccess-Control-Allow-Methods\n- 指定访问资源时允许的方法或方法,这用于响应预请求。\n\nAccess-Control-Allow-Headers\n- 用于响应预请求，以指示在进行实际请求时可以使用哪些HTTP头。\n\n### CORS与JSONP的对比\n1. CORS 除了 GET 方法外，也支持其它的 HTTP 请求方法如 POST、 PUT 等。\n2. CORS 可以使用 XmlHttpRequest 进行传输，所以它的错误处理方式比 JSONP 好。\n3. JSONP 可以在不支持 CORS 的老旧浏览器上运作。\n\n## 一些其它的跨域调用方式\n### window.name\nwindow对象有个name属性，该属性有个特征：即在一个窗口 (window) 的生命周期内，窗口载入的所有的页面都是共享一个 window.name 的，每个页面对 window.name 都有读写的权限，window.name 是持久存在一个窗口载入过的所有页面中的，并不会因新页面的载入而进行重置。\n\n### window.postMessage()\n这个方法是 HTML5 的一个新特性，可以用来向其他所有的 window 对象发送消息。需要注意的是我们必须要保证所有的脚本执行完才发送 MessageEvent，如果在函数执行的过程中调用了他，就会让后面的函数超时无法执行。\n\n### web sockets\nweb sockets是一种浏览器的API，它的目标是在一个单独的持久连接上提供全双工、双向通信。(同源策略对web sockets不适用)\nweb sockets原理：在JS创建了web socket之后，会有一个HTTP请求发送到浏览器以发起连接。取得服务器响应后，建立的连接会使用HTTP升级从HTTP协议交换为web sockt协议。只有在支持web socket协议的服务器上才能正常工作。\n\n","tags":["面试"],"categories":["面试"]},{"title":"HTML DOCTYPE 标签","url":"%2F2017%2F03%2F09%2Farticle-33%2F","content":"## 定义和用法\n`<!DOCTYPE>` 声明必须是 HTML 文档的第一行，位于 `<html>` 标签之前。\n\n`<!DOCTYPE>` 声明不是 HTML 标签；它是指示 web 浏览器关于页面使用哪个 HTML 版本进行编写的指令。\n\n在 HTML 4.01 中，`<!DOCTYPE>` 声明引用 DTD，因为 HTML 4.01 基于 SGML。DTD 规定了标记语言的规则，这样浏览器才能正确地呈现内容。\n\nHTML5 不基于 SGML，所以不需要引用 DTD。\n\n请始终向 HTML 文档添加 `<!DOCTYPE>`声明，这样浏览器才能获知文档类型。\n\n<!--more-->\n\n## HTML 4.01 与 HTML5 之间的差异\n在 HTML 4.01 中有三种 `<!DOCTYPE>` 声明。在 HTML5 中只有一种。\n\n### HTML5\n\n```html\n<!DOCTYPE html>\n```\n\n### HTML 4.01 Strict\n该 DTD 包含所有 HTML 元素和属性，但不包括展示性的和弃用的元素（比如 font）。不允许框架集（Framesets）。\n\n```html\n<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01//EN\" \"http://www.w3.org/TR/html4/strict.dtd\">\n```\n\n### HTML 4.01 Transitional\n该 DTD 包含所有 HTML 元素和属性，包括展示性的和弃用的元素（比如 font）。不允许框架集（Framesets）。\n\n```html\n<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\">\n```\n\n### HTML 4.01 Frameset\n该 DTD 等同于 HTML 4.01 Transitional，但允许框架集内容。\n\n```html\n<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Frameset//EN\" \"http://www.w3.org/TR/html4/frameset.dtd\">\n```\n","tags":["HTML"],"categories":["前端"]},{"title":"ES6学习总结","url":"%2F2017%2F03%2F09%2Farticle-32%2F","content":"ES6相比于之前的ECMAScript来说，是变化比较大的，里面新增的一些语法和标准，都致力于让JavaScript的开发变得更加规范和高效。而对于一个优秀的前端开发者来说，拥抱新的变化时必不可少的，大部分的互联网公司面试也都会问到ES6相关的问题。遗憾自己现在才决定好好学习ES6的语法，将自己的总结记录在此文章中。\n\n注：学习教程为阮一峰老师出版的[《ES6标准入门》](http://es6.ruanyifeng.com/#docs)一书\n\n<!--more-->\n\n## let和const命令\n在ES6中，我们推荐使用let和const命令来代替之前的var声明变量。\n\n### let命令\nlet命令声明的变量只在声明的代码块内有效。\n\n使用let命令时，变量的引用必须在声明之后，否则会报错。\n\nlet命令声明的变量会与当前块级作用域绑定，不受外界影响。\n\nlet命令声明变量时不允许在相同作用域内重复声明同一个变量。\n\n在严格模式下，函数只能在顶层作用域和函数中声明，否则报错。\n\n### const命令\nconst用来声明常量，一旦声明，其值就不能改变。\n\nconst声明的变量，在声明时必须初始化，否则会报错。\n\n关于作用域的方面，const与let命令相同，声明只在块级作用域内产生影响。\n\n## 变量的解构赋值\nES6允许按照一定的模式，从数组和对象中提取值，对变量进行赋值，这被称为解构。\n变量解构赋值的用途包括：\n\n```javascript\n//变换变量的值\n[x, y] = [y, x];\n\n//从函数返回一个数组\nfunction example() {\n  return [1, 2, 3];\n}\nconst [a, b, c] = example();\n\n//从函数返回一个对象\nfunction example() {\n  return {\n    foo: 1,\n    bar: 2,\n  };\n}\nconst {foo, bar} = example();\n\n//函数参数的定义\nfunction f([x, y, z]) {...}\nf([1, 2, 3]);\nfunction f({x, y, z}) {...}\nf({x: 1, y: 2, z: 3]};\n\n//提取JSON对象中的数据\nconst jsonData = {\n  a: 1,\n  b: 2,\n  c: [3, 4],\n};\nlet { a, b, c:d } = jsonData;\n\n//指定函数参数的默认值\nfunction ajax( url, {\n  async = true,\n  beforeSend = function() {},\n  cache = true,\n  complete = function() {},\n  error = 'errorMessage',\n}) {\n  ...\n}\n\n//遍历map结构\nfor (let [key, value] of map) {\n  console.log(key + ':' + value);\n}\nfor (let [key] of map) {\n  console.log(key);\n}\nfor (let [,value] of map) {\n  console.log(value);\n}\n\n//获取加载模块的指定方法\nconst { sourceNode, sourceMapConsumer } = require('source-map');\n\n```\n### 数组的解构赋值\n只要等号两边的模式相同，左边的变量就可以被赋予对应的值。\n\n```javascript\n\nlet [foo, [[bar, baz]]] = [1, [[2, 3]]];\n//foo = 1, bar = 2, baz = 3\nlet [ , , third] = [1, 2, 3];\n//third = 3\nlet [a, ...b] = [1, 2, 3, 4];\n//a = 1, b = [2, 3, 4]\n\n```\n如果等号左边的变量模式多于右边，则会解构失败，解构失败的变量值会变成undefined。反之，等号左边的变量模式少于右边，则会正常解构。\n\n```javascript\nlet [foo] = [];\n//foo undefined\nlet [bar, foo] = [1];\n//foo undefined\nlet [x, y] = [1, 2, 3];\n//x = 1, y = 2\n\n```\n如果某种数据结构具有Iterator接口，那么它也可以采用数组形式的解构赋值。\n\n解构赋值允许指定默认值：\n\n```javascript\nlet [foo = true] = [];\n//foo = true;\n\n```\n需要注意的是，ES6内部使用`===`来判断某个位置是否有值，所以如果右边数组中的值不严格等于undefined，默认值是不会生效。\n\n### 对象的解构赋值\n对象解构赋值与数组的解构赋值类似，不同的是，对象的解构不需要按次序，只需要对应的属性名相同即可。\n\n```javascript\nlet { bar, foo } = { foo: 'aaa', bar: 'bbb' };\n//bar = bbb, foo = aaa;\n\nlet { baz } = { foo: 'aaa', bar: 'bbb' };\n//baz = undefined;\n\nlet { foo:baz } = { foo: 'aaa', bar: 'bbb' };\n//baz = aaa; foo is not defined.\n\n```\n对象的解构赋值只会对变量进行赋值，不会对模式赋值。\n\n对于已经声明的变量解构赋值时要小心不能以大括号开头，否则会出错。下例中`{x}`会被理解成一个代码块，所以会报错，正确的写法是将整个解构语句放在括号里。\n\n```javascript\nlet x;\n{ x } = { x:1 };\n//error\n({ x } = { x:1 });\n//x = 1\n```\n\n### 字符串的解构\n字符串的解构是将字符串装换成一个类似数组的对象。\n\n```javascript\nconst [a, b, c, d, e] = 'hello';\n// a = 'h',...,e = 'o';\nlet { length:len } = 'hello';\n//len = 5;\n```\n\n### 数字和布尔值的解构赋值\n解构赋值的规则是，如果等号右边的类型不是Object，就将其转为Object。\n\n```javascript\nlet { toString:s } = 123;\n//s = true;\nlet { toString:s } = true;\n//s = true;\nlet { prop:x } = undefined;\n//error\nlet { prop:y } = null;\n//error\n```\n\n## 字符串的扩展\n### codePointAt()\nJavaScript中，字符以UTF-16的格式储存，每个字符固定为2字节，对于需要4个字节储存的字符（Unicode 编码大于 0xFFFF 的字符），JavaScript会认为它们是两个字符。\n\n```JavaScript\nlet s = '𠮷';\nconsole.log(s.charCodeAt(0));\n//55362   0xD842\nconsole.log(s.charCodeAt(1));\n//57271   0xDFB7\n```\nES6提供了`codePointAt`方法，能够正确处理4个字节存储的字符，返回一个字符的Unicode编码。下面的代码中JavaScript将“𠮷a”识别成了3个字符，其中从第一个字符开始正确的识别出了32位的UTF-16编码。\n\n```javascript\nlet s = '𠮷a';\nconsole.log(s.codePointAt(0));\n//134071 0x20bb7\nconsole.log(s.codePointAt(1));\n//57271 0xDFB7\nconsole.log(s.charCodeAt(2));\n//97 0x61\n```\n为了正确的识别出两个字符的编码，可以使用循环来获取每个单独的字符，然后打印出它们的编码。\n\n```javascript\nlet s = '𠮷a';\nfor (let ch of s) {\n  console.log(ch.codePointAt(0).toString(16));\n}\n// 0x20bb7   0x61\n```\n\n### String.fromCodePoint()\n该方法用于从Unicode编码转换为字符，即相当于`codePointAt`方法的反例。当传入多个参数时，会被合并成一个字符串并返回。需要注意的是，此方法是定义在`String`对象上，而`codePointAt`是定义在字符串实例上。\n\n### at()\n用于返回给定位置的字符，相当于ES5的`charAt`方法，不同的时，该方法可以返回32位的UTF-16编码字符。\n\n### includes(),startsWith(),endsWith()\n- includes(): 返回布尔值，表示是否找到了参数字符串。\n- startsWith(): 返回布尔值，表示参数字符串是否在源字符串的头部。\n- endsWith(): 返回布尔值，表示参数字符串是否在源字符串的尾部。\n这3个方法都支持第二个参数，表示开始搜索的位置。其中`endsWith`方法的第二个参数表示前n个字符。\n\n### repeat()\n`repeat`方法返回一个新字符串，表示将源字符串重复n次。\n\n```javascript\n'n'.repeat(2);\n//'nn'\n```\n\n### padStart(),padEnd()\n字符串补全长度方法。`padStart`用于字符串头部补全，`padEnd`用于字符串尾部补全。\n\n```javascript\n'x'.padStart(5,'ab');\n//'ababx'\n'x'.padEnd(4,'ab');\n//'xaba'\n'xxx'.padStart(2,'ab');\n//'xxx'\n'x'.padStart(4);\n//'   x'\n```\n\n### String.raw()\n`String.raw`方法通常用来处理带反斜线的字符串，以便后续使用。也可以用作字符串中插入字符串的函数来用。\n\n```javascript\nString.raw`Hi\\n${2+3}`;\n//Hi\\\\n5\nString.raw({ raw: test }, 0, 1, 2);\n//t0e1s2t\n```\n需要注意的是，在使用第二种方式的时候，第一个参数必须是具有`raw`属性的对象，并且`raw`的值为一个数组。\n\n## 数值的扩展\n### Number.isFinite(), Number.isNaN()\n`Number.isFinite()`用来检查一个数值是否为有限的（finite）\n\n```javascript\nNumber.isFinite(15); // true\nNumber.isFinite(0.8); // true\nNumber.isFinite(NaN); // false\nNumber.isFinite(Infinity); // false\nNumber.isFinite(-Infinity); // false\nNumber.isFinite('foo'); // false\nNumber.isFinite('15'); // false\nNumber.isFinite(true); // false\n```\n`Number.isNaN()`用来检查一个值是否为NaN。\n\n```javascript\nNumber.isNaN(NaN) // true\nNumber.isNaN(15) // false\nNumber.isNaN('15') // false\nNumber.isNaN(true) // false\nNumber.isNaN(9/NaN) // true\nNumber.isNaN('true'/0) // true\nNumber.isNaN('true'/'true') // true\n```\n它们与传统的全局方法`isFinite()`和`isNaN()`的区别在于，传统方法先调用`Number()`将非数值的值转为数值，再进行判断，而这两个新方法只对数值有效，`Number.isFinite()`对于非数值一律返回false, `Number.isNaN()`只有对于NaN才返回true，非NaN一律返回false。\n\n```javascript\nisFinite(25) // true\nisFinite(\"25\") // true\nNumber.isFinite(25) // true\nNumber.isFinite(\"25\") // false\n\nisNaN(NaN) // true\nisNaN(\"NaN\") // true\nNumber.isNaN(NaN) // true\nNumber.isNaN(\"NaN\") // false\nNumber.isNaN(1) // false\n```\n\n### Number.parseInt(), Number.parseFloat() \nES6将全局方法`parseInt()`和`parseFloat()`，移植到Number对象上面，行为完全保持不变。这样做的目的，是逐步减少全局性方法，使得语言逐步模块化。\n\n```javascript\n// ES5的写法\nparseInt('12.34') // 12\nparseFloat('123.45#') // 123.45\n\n// ES6的写法\nNumber.parseInt('12.34') // 12\nNumber.parseFloat('123.45#') // 123.45\n```\n\n### Number.isInteger()\n`Number.isInteger()`用来判断一个值是否为整数。需要注意的是，在JavaScript内部，整数和浮点数是同样的储存方法，所以3和3.0被视为同一个值。\n\n```javascript\nNumber.isInteger(25) // true\nNumber.isInteger(25.0) // true\nNumber.isInteger(25.1) // false\nNumber.isInteger(\"15\") // false\nNumber.isInteger(true) // false\n```\n\n### Number.EPSILON\nES6在Number对象上面，新增一个极小的常量`Number.EPSILON`。引入一个这么小的量的目的，在于为浮点数计算，设置一个误差范围。我们知道浮点数计算是不精确的。但是如果这个误差能够小于`Number.EPSILON`，我们就可以认为得到了正确结果。\n\n```javascript\nNumber.EPSILON\n// 2.220446049250313e-16\nNumber.EPSILON.toFixed(20)\n// '0.00000000000000022204'\n\nNumber.EPSILON\n// 2.220446049250313e-16\nNumber.EPSILON.toFixed(20)\n// '0.00000000000000022204'\n\n5.551115123125783e-17 < Number.EPSILON\n// true\n```\n\n### 安全整数和Number.isSafeInteger()\nJavaScript能够准确表示的整数范围在-2^53到2^53之间（不含两个端点），超过这个范围，无法精确表示这个值。ES6引入了`Number.MAX_SAFE_INTEGER`和`Number.MIN_SAFE_INTEGER`这两个常量，用来表示这个范围的上下限。\n`Number.isSafeInteger()`则是用来判断一个整数是否落在这个范围之内。\n\n```javascript\nNumber.isSafeInteger('a') // false\nNumber.isSafeInteger(null) // false\nNumber.isSafeInteger(NaN) // false\nNumber.isSafeInteger(Infinity) // false\nNumber.isSafeInteger(-Infinity) // false\n\nNumber.isSafeInteger(3) // true\nNumber.isSafeInteger(1.2) // false\nNumber.isSafeInteger(9007199254740990) // true\nNumber.isSafeInteger(9007199254740992) // false\n\nNumber.isSafeInteger(Number.MIN_SAFE_INTEGER - 1) // false\nNumber.isSafeInteger(Number.MIN_SAFE_INTEGER) // true\nNumber.isSafeInteger(Number.MAX_SAFE_INTEGER) // true\nNumber.isSafeInteger(Number.MAX_SAFE_INTEGER + 1) // false\n```\n\n## Math对象的扩展\n### Math.trunc()\n`Math.trunc`方法用于去除一个数的小数部分，返回整数部分。对于非数值，`Math.trunc`内部使用Number方法将其先转为数值。\n\n```javascript\nMath.trunc(4.1) // 4\nMath.trunc(4.9) // 4\nMath.trunc(-4.1) // -4\nMath.trunc(-4.9) // -4\nMath.trunc(-0.1234) // -0\n```\n\n### Math.sign()\n`Math.sign`方法用来判断一个数到底是正数、负数、还是零。\n\n```javascript\nMath.sign(-5) // -1\nMath.sign(5) // +1\nMath.sign(0) // +0\nMath.sign(-0) // -0\nMath.sign(NaN) // NaN\nMath.sign('foo'); // NaN\nMath.sign();      // NaN\n```\n\n### Math.cbrt()\n`Math.cbrt`方法用于计算一个数的立方根。\n\n```javascript\nMath.cbrt(-1) // -1\nMath.cbrt(0)  // 0\nMath.cbrt(1)  // 1\nMath.cbrt(2)  // 1.2599210498948734\n```\n\n### Math.hypot()\n`Math.hypot`方法返回所有参数的平方和的平方根。\n\n```javascript\nMath.hypot(3, 4);        // 5\nMath.hypot(3, 4, 5);     // 7.0710678118654755\nMath.hypot();            // 0\nMath.hypot(NaN);         // NaN\nMath.hypot(3, 4, 'foo'); // NaN\nMath.hypot(3, 4, '5');   // 7.0710678118654755\nMath.hypot(-3);          // 3\n```\n\n### 对数方法\n`Math.expm1(x)`返回`e^x - 1`，即`Math.exp(x) - 1`。\n`Math.log1p(x)`方法返回`1 + x`的自然对数，即`Math.log(1 + x)`。如果x小于-1，返回NaN。\n`Math.log10(x)`返回以10为底的x的对数。如果x小于0，则返回NaN。\n`Math.log2(x)`返回以2为底的x的对数。如果x小于0，则返回NaN。\n\n### 三角函数方法\n`Math.sinh(x)`返回x的双曲正弦\n`Math.cosh(x)`返回x的双曲余弦\n`Math.tanh(x)`返回x的双曲正切\n`Math.asinh(x)`返回x的反双曲正弦\n`Math.acosh(x)`返回x的反双曲余弦\n`Math.atanh(x)`返回x的反双曲正切\n\n### 指数运算符\nES2016 新增了一个指数运算符（**）。指数运算符可以与等号结合，形成一个新的赋值运算符（**=）。\n\n```javascript\n2 ** 2 // 4\n2 ** 3 // 8\n\nlet a = 1.5;\na **= 2;\n// 等同于 a = a * a;\n\nlet b = 4;\nb **= 3;\n// 等同于 b = b * b * b;\n```\n\n## 数组的扩展\n### Array.from()\n`Array.from`方法用于将两类对象转为真正的数组：类似数组的对象（array-like object）和可遍历（iterable）的对象（包括ES6新增的数据结构Set和Map）。\n\n```javascript\nlet arrayLike = {\n    '0': 'a',\n    '1': 'b',\n    '2': 'c',\n    length: 3\n};\n\n// ES6的写法\nlet arr2 = Array.from(arrayLike); // ['a', 'b', 'c']\n\nArray.from('hello')\n// ['h', 'e', 'l', 'l', 'o']\n\nlet namesSet = new Set(['a', 'b'])\nArray.from(namesSet) // ['a', 'b']\n```\n值得提醒的是，扩展运算符（...）也可以将某些数据结构转为数组。\n`Array.from`还可以接受第二个参数，作用类似于数组的map方法，用来对每个元素进行处理，将处理后的值放入返回的数组。\n\n```javascript\nArray.from(arrayLike, x => x * x);\n// 等同于\nArray.from(arrayLike).map(x => x * x);\n\nArray.from([1, 2, 3], (x) => x * x)\n// [1, 4, 9]\n```\n\n### Array.of()\n`Array.of`方法用于将一组值，转换为数组。\n\n```javascript\nArray.of(3, 11, 8) // [3,11,8]\nArray.of(3) // [3]\nArray.of(3).length // 1\n```\n\n### 数组实例的copyWithin()\n数组实例的copyWithin方法，在当前数组内部，将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回当前数组。也就是说，使用这个方法，会修改当前数组。\n\n它接受三个参数:\n- target（必需）：从该位置开始替换数据。\n- start（可选）：从该位置开始读取数据，默认为0。如果为负值，表示倒数。\n- end（可选）：到该位置前停止读取数据，默认等于数组长度。如果为负值，表示倒数。\n\n```javascript\n[1, 2, 3, 4, 5].copyWithin(0, 3)\n// [4, 5, 3, 4, 5]\n\n// 将3号位复制到0号位\n[1, 2, 3, 4, 5].copyWithin(0, 3, 4)\n// [4, 2, 3, 4, 5]\n\n// -2相当于3号位，-1相当于4号位\n[1, 2, 3, 4, 5].copyWithin(0, -2, -1)\n// [4, 2, 3, 4, 5]\n```\n\n### 数组实例的find()和findIndex()\n数组实例的`find`方法，用于找出第一个符合条件的数组成员。它的参数是一个回调函数，所有数组成员依次执行该回调函数，直到找出第一个返回值为true的成员，然后返回该成员。如果没有符合条件的成员，则返回undefined。\nfind方法的回调函数可以接受三个参数，依次为当前的值、当前的位置和原数组。\n\n```javascript\n[1, 4, -5, 10].find((n) => n < 0)\n// -5\n\n[1, 5, 10, 15].find(function(value, index, arr) {\n  return value > 9;\n}) // 10\n```\n数组实例的`findIndex`方法的用法与`find`方法非常类似，返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回-1。\n\n```javascript\n[1, 5, 10, 15].findIndex(function(value, index, arr) {\n  return value > 9;\n}) // 2\n```\n\n### 数组实例的fill()\n`fill`方法使用给定值，填充一个数组。`fill`方法还可以接受第二个和第三个参数，用于指定填充的起始位置和结束位置。\n\n```javascript\n['a', 'b', 'c'].fill(7)\n// [7, 7, 7]\n\nnew Array(3).fill(7)\n// [7, 7, 7]\n\n['a', 'b', 'c'].fill(7, 1, 2)\n// ['a', 7, 'c']\n```\n\n### 数组实例的entries()，keys()和values()\n\n```javascript\nfor (let index of ['a', 'b'].keys()) {\n  console.log(index);\n}\n// 0\n// 1\n\nfor (let elem of ['a', 'b'].values()) {\n  console.log(elem);\n}\n// 'a'\n// 'b'\n\nfor (let [index, elem] of ['a', 'b'].entries()) {\n  console.log(index, elem);\n}\n// 0 \"a\"\n// 1 \"b\"\n```\n\n### 数组实例的includes()\n`Array.prototype.includes`方法返回一个布尔值，表示某个数组是否包含给定的值，与字符串的`includes`方法类似。\n\n## 函数的扩展\n### 函数参数的默认值\n除了简洁，ES6 的写法还有两个好处：首先，阅读代码的人，可以立刻意识到哪些参数是可以省略的，不用查看函数体或文档；其次，有利于将来的代码优化，即使未来的版本在对外接口中，彻底拿掉这个参数，也不会导致以前的代码无法运行。\n默认赋值的参数不能在函数体内再次声明，否则会报错。\n\n```javascript\nfunction log(x, y = 'World') {\n  console.log(x, y);\n}\n\nlog('Hello') // Hello World\nlog('Hello', 'China') // Hello China\nlog('Hello', '') // Hello\n```\n通常情况下，定义了默认值的参数，应该是函数的尾参数。因为这样比较容易看出来，到底省略了哪些参数。如果非尾部的参数设置默认值，实际上这个参数是没法省略的。\n\n```javascript\n// 例一\nfunction f(x = 1, y) {\n  return [x, y];\n}\n\nf() // [1, undefined]\nf(2) // [2, undefined])\nf(, 1) // 报错\nf(undefined, 1) // [1, 1]\n\n// 例二\nfunction f(x, y = 5, z) {\n  return [x, y, z];\n}\n\nf() // [undefined, 5, undefined]\nf(1) // [1, 5, undefined]\nf(1, ,2) // 报错\nf(1, undefined, 2) // [1, 5, 2]\n```\n指定了默认值以后，函数的length属性，将返回没有指定默认值的参数个数。也就是说，指定了默认值后，length属性将失真。\n需要注意的是，length属性只返回默认参数之前的未指定默认值参数的个数，在其之后会忽略。\n\n```javascript\n(function (a) {}).length // 1\n(function (a = 5) {}).length // 0\n(function (a, b, c = 5) {}).length // 2\n\n(function (a = 0, b, c) {}).length // 0\n(function (a, b = 1, c) {}).length // 1\n```\n一旦设置了参数的默认值，函数进行声明初始化时，参数会形成一个单独的作用域（context）。等到初始化结束，这个作用域就会消失。\n\n```javascript\nvar x = 1;\n\nfunction f(x, y = x) {\n  console.log(y);\n}\n\nf(2) // 2\n\nlet x = 1;\n\nfunction f(y = x) {\n  let x = 2;\n  console.log(y);\n}\n\nf() // 1\n```\n\n### rest参数\nES6 引入 rest 参数（形式为“...变量名”），用于获取函数的多余参数，这样就不需要使用arguments对象了。rest 参数搭配的变量是一个数组，该变量将多余的参数放入数组中。\n注意，rest 参数之后不能再有其他参数（即只能是最后一个参数），否则会报错。\n\n```javascript\nfunction add(...values) {\n  let sum = 0;\n\n  for (var val of values) {\n    sum += val;\n  }\n\n  return sum;\n}\n\nadd(2, 5, 3) // 10\n```\n\n### 扩展运算符\n扩展运算符（spread）是三个点（...）。它好比 rest 参数的逆运算，将一个数组转为用逗号分隔的参数序列。\n\n```javascript\nconsole.log(...[1, 2, 3])\n// 1 2 3\n\nconsole.log(1, ...[2, 3, 4], 5)\n// 1 2 3 4 5\n\n[...document.querySelectorAll('div')]\n// [<div>, <div>, <div>]\n```\n\n### 严格模式\n只要函数参数使用了默认值、解构赋值、或者扩展运算符，那么函数内部就不能显式设定为严格模式，否则会报错。\n\n```javascript\n// 报错\nfunction doSomething(a, b = a) {\n  'use strict';\n  // code\n}\n\n// 报错\nconst doSomething = function ({a, b}) {\n  'use strict';\n  // code\n};\n\n// 报错\nconst doSomething = (...a) => {\n  'use strict';\n  // code\n};\n\nconst obj = {\n  // 报错\n  doSomething({a, b}) {\n    'use strict';\n    // code\n  }\n};\n```\n\n### 箭头函数\n如果箭头函数不需要参数或需要多个参数，就使用一个圆括号代表参数部分。\n如果箭头函数的代码块部分多于一条语句，就要使用大括号将它们括起来，并且使用return语句返回。\n由于大括号被解释为代码块，所以如果箭头函数直接返回一个对象，必须在对象外面加上括号。\n\n```javascript\nvar f = v => v;\n//等同于下面的函数\nvar f = function(v) {\n  return v;\n};\n\nvar f = () => 5;\n// 等同于\nvar f = function () { return 5 };\n\nvar sum = (num1, num2) => num1 + num2;\n// 等同于\nvar sum = function(num1, num2) {\n  return num1 + num2;\n};\n```\n\n### 绑定 this\n箭头函数可以绑定this对象，大大减少了显式绑定this对象的写法（call、apply、bind）。但是，箭头函数并不适用于所有场合，所以ES7提出了“函数绑定”（function bind）运算符，用来取代call、apply、bind调用。虽然该语法还是ES7的一个提案，但是Babel转码器已经支持。\n\n函数绑定运算符是并排的两个双冒号（::），双冒号左边是一个对象，右边是一个函数。该运算符会自动将左边的对象，作为上下文环境（即this对象），绑定到右边的函数上面。\n\n```javascript\nfoo::bar;\n// 等同于\nbar.bind(foo);\n\nfoo::bar(...arguments);\n// 等同于\nbar.apply(foo, arguments);\n\ngetPlayers()\n::map(x => x.character())\n::takeWhile(x => x.strength > 100)\n::forEach(x => console.log(x));\n\n// 例二\nlet { find, html } = jake;\n\ndocument.querySelectorAll(\"div.myClass\")\n::find(\"p\")\n::html(\"hahaha\");\n```\n\n### 尾调用优化\n在一个函数的尾部调用另一个函数，称之为尾调用。\n\n```javascript\n//尾调用\nfunction f(x){\n  return g(x);\n}\n\n// 情况一 不是尾调用，g(x)执行完后又赋值了\nfunction f(x){\n  let y = g(x);\n  return y;\n}\n\n// 情况二 不是尾调用\nfunction f(x){\n  return g(x) + 1;\n}\n\n// 情况三 也不是尾调用\nfunction f(x){\n  g(x);\n}\n```\n\n### 尾递归\n函数调用自身，称为递归。如果尾调用自身，就称为尾递归。\n递归非常耗费内存，因为需要同时保存成千上百个调用帧，很容易发生“栈溢出”错误（stack overflow）。但对于尾递归来说，由于只存在一个调用帧，所以永远不会发生“栈溢出”错误。\n\n```javascript\nfunction Fibonacci (n) {\n  if ( n <= 1 ) {return 1};\n\n  return Fibonacci(n - 1) + Fibonacci(n - 2);\n}\n\nFibonacci(10); // 89\n// Fibonacci(100)\n// Fibonacci(500)\n// 堆栈溢出了\n\nfunction Fibonacci2 (n , ac1 = 1 , ac2 = 1) {\n  if( n <= 1 ) {return ac2};\n\n  return Fibonacci2 (n - 1, ac2, ac1 + ac2);\n}\n\nFibonacci2(100) // 573147844013817200000\nFibonacci2(1000) // 7.0330367711422765e+208\nFibonacci2(10000) // Infinity\n```\n\n## 对象的扩展\n### 属性的简洁表示方法\nES6 允许直接写入变量和函数，作为对象的属性和方法。\n\n```javascript\nvar birth = '2000/01/01';\n\nvar Person = {\n\n  name: '张三',\n\n  //等同于birth: birth\n  birth,\n\n  // 等同于hello: function ()...\n  hello() { console.log('我的名字是', this.name); }\n\n};\n```\n\n### 属性名表达式\n定义对象的属性时可以直接用标识符作为属性名，也可以用表达式作为属性名，这时要将表达式放在方括号之内。\n\n```javascript\nlet propKey = 'foo';\n\nlet obj = {\n  [propKey]: true,\n  ['a' + 'bc']: 123\n};\n```\n\n### Object.is()\n`Object.is()`方法用来判断两个值是否严格相等。\n\n### Object.assign()\n`Object.assign()`方法用来将原对象的可枚举属性复制到目标对象上去。如果后面的原对象与前面的有相同的属性，则后面会覆盖前面。\n\n```javascript\nvar target = { a: 1, b: 1 };\n\nvar source1 = { b: 2, c: 2 };\nvar source2 = { c: 3 };\n\nObject.assign(target, source1, source2);\ntarget // {a:1, b:2, c:3}\n```\n常见用法：\n\n```javascript\n//为对象添加属性\nclass Point {\n  constructor(x, y) {\n    Object.assign(this, {x, y});\n  }\n}\n\n//给对象添加方法\nObject.assign(SomeClass.prototype, {\n  someMethod(arg1, arg2) {\n    ···\n  },\n  anotherMethod() {\n    ···\n  }\n});\n\n//克隆对象\nfunction clone(origin) {\n  return Object.assign({}, origin);\n}\n\n//合并多个对象\nconst merge =\n  (target, ...sources) => Object.assign(target, ...sources);\n\n//\n```\n\n### 属性的遍历\nES6一共有5种方法可以遍历对象的属性。\n\n- for...in\n  for...in循环遍历对象自身的和继承的可枚举属性（不含Symbol属性）。\n- Object.keys(obj)\n  Object.keys返回一个数组，包括对象自身的（不含继承的）所有可枚举属性（不含Symbol属性）。\n- Object.getOwnPropertyNames(obj)\n  Object.getOwnPropertyNames返回一个数组，包含对象自身的所有属性（不含Symbol属性，但是包括不可枚举属性）。\n- Object.getOwnPropertySymbols(obj)\n  Object.getOwnPropertySymbols返回一个数组，包含对象自身的所有Symbol属性。\n- Reflect.ownKeys(obj)\n  Reflect.ownKeys返回一个数组，包含对象自身的所有属性，不管是属性名是Symbol或字符串，也不管是否可枚举。\n\n以上的5种方法遍历对象的属性，都遵守同样的属性遍历的次序规则。\n\n- 首先遍历所有属性名为数值的属性，按照数字排序。\n- 其次遍历所有属性名为字符串的属性，按照生成时间排序。\n- 最后遍历所有属性名为Symbol值的属性，按照生成时间排序。\n\n### Object.keys()\n`Object.keys()`返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历属性的键名。\n\n```javascript\nvar obj = { foo: 'bar', baz: 42 };\nObject.keys(obj)\n// [\"foo\", \"baz\"]\n```\n\n### Object.values() \n`Object.values()`返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历属性的键值。\n如果Object.values方法的参数是一个字符串，会返回各个字符组成的一个数组。\n\n```javascript\nvar obj = { foo: 'bar', baz: 42 };\nObject.values(obj)\n// [\"bar\", 42]\n\nObject.values('foo')\n// ['f', 'o', 'o']\n```\n\n### Object.entries()\n`Object.entries()`返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历属性的键值对数组。\n\n```javascript\nvar obj = { foo: 'bar', baz: 42 };\nObject.entries(obj)\n// [ [\"foo\", \"bar\"], [\"baz\", 42] ]\n```\n\n## Symbol\nES6 引入了一种新的原始数据类型Symbol，表示独一无二的值。它是 JavaScript 语言的第七种数据类型，前六种是：undefined、null、布尔值（Boolean）、字符串（String）、数值（Number）、对象（Object）。\nSymbol 值通过Symbol函数生成。这就是说，对象的属性名现在可以有两种类型，一种是原来就有的字符串，另一种就是新增的 Symbol 类型。凡是属性名属于 Symbol 类型，就都是独一无二的，可以保证不会与其他属性名产生冲突。\nSymbol函数可以接受一个字符串作为参数，表示对 Symbol 实例的描述，主要是为了在控制台显示，或者转为字符串时，比较容易区分。\n\n```javascript\nvar s1 = Symbol('foo');\nvar s2 = Symbol('bar');\n\ns1 // Symbol(foo)\ns2 // Symbol(bar)\n\ns1.toString() // \"Symbol(foo)\"\ns2.toString() // \"Symbol(bar)\"\n```\n\n### 作为属性名的 Symbol\n由于每一个 Symbol 值都是不相等的，这意味着 Symbol 值可以作为标识符，用于对象的属性名，就能保证不会出现同名的属性。这对于一个对象由多个模块构成的情况非常有用，能防止某一个键被不小心改写或覆盖。\n注意，Symbol 值作为对象属性名时，不能用点运算符。同理，在对象的内部，使用 Symbol 值定义属性时，Symbol 值必须放在方括号之中。\n\n```javascript\nvar mySymbol = Symbol();\n\n// 第一种写法\nvar a = {};\na[mySymbol] = 'Hello!';\n\n// 第二种写法\nvar a = {\n  [mySymbol]: 'Hello!'\n};\n\n// 第三种写法\nvar a = {};\nObject.defineProperty(a, mySymbol, { value: 'Hello!' });\n\n// 以上写法都得到同样结果\na[mySymbol] // \"Hello!\"\n\n//不能用点来声明\na.mySymbol = 'Hello!';\na[mySymbol] // undefined\na['mySymbol'] // \"Hello!\"\n```\n\n### 属性名的遍历\nSymbol 作为属性名，该属性不会出现在`for...in`、`for...of`循环中，也不会被`Object.keys()`、`Object.getOwnPropertyNames()`、`JSON.stringify()`返回。但是，它也不是私有属性，有一个`Object.getOwnPropertySymbols`方法，可以获取指定对象的所有 Symbol 属性名。\n另一个新的API，`Reflect.ownKeys`方法可以返回所有类型的键名，包括常规键名和 Symbol 键名。\n\n```javascript\nvar obj = {};\n\nvar foo = Symbol(\"foo\");\n\nObject.defineProperty(obj, foo, {\n  value: \"foobar\",\n});\n\nfor (var i in obj) {\n  console.log(i); // 无输出\n}\n\nObject.getOwnPropertyNames(obj)\n// []\n\nObject.getOwnPropertySymbols(obj)\n// [Symbol(foo)]\n\nlet obj = {\n  [Symbol('my_key')]: 1,\n  enum: 2,\n  nonEnum: 3\n};\n\nReflect.ownKeys(obj)\n//  [\"enum\", \"nonEnum\", Symbol(my_key)]\n```\n\n## Set和Map数据结构\n### Set\nSet数据结构类似于数组，但是其成员的值都是唯一的，没有重复值。\n\nSet本身是一个构造函数，用来生成Set数据结构；也可以通过向构造函数中传值的方式来创建一个Set。\n```javascript\nconst s = new Set();\n\n[2, 3, 5, 4, 5, 2, 2].forEach(x => s.add(x));\n\nfor (let i of s) {\n  console.log(i);\n}\n// 2 3 5 4\n\nconst set = new Set([1, 2, 3, 4, 4]);\n[...set]\n// [1, 2, 3, 4]\n```\n\n可以通过Set实现数组的去重；可以通过Array.from将一个Set\b变成数组。\n```javascript\n// 去除数组的重复成员\n[...new Set(array)]\n\nconst array = Array.from(new Set(array));\n```\n\n### Set 实例的属性和方法\n- size 返回Set实例的成员总数\n- add 添加某个值，返回Set结构本身\n- delete 删除某个值，返回一个boolean值，表示是否删除成功\n- has 返回一个boolean值，表示该实例是否拥有某个值\n- clear 清除所有值，没有返回值\n\n### 遍历Set\n- keys() 返回键名的遍历器\n- values() 返回键值的遍历器\n- entries() 返回键值对的遍历器\n- forEach() 使用回调函数遍历每个成员\n\n需要注意的是，由于Set没有键值和键名，所以`keys()`和`values()`方法遍历的结果是一样的。\n\n使用Set实现并交差集合运算。\n```javascript\nlet a = new Set([1, 2, 3]);\nlet b = new Set([4, 3, 2]);\n\n// 并集\nlet union = new Set([...a, ...b]);\n// Set {1, 2, 3, 4}\n\n// 交集\nlet intersect = new Set([...a].filter(x => b.has(x)));\n// set {2, 3}\n\n// 差集\nlet difference = new Set([...a].filter(x => !b.has(x)));\n// Set {1}\n```\n\n### Map\nMap是一种键值对集合，与对象不同的时，它的键名不止为字符串，可以是任何类型，包括对象。\n\nMap构造函数的参数可以是任何具有Iterator接口的数据结构。\n```javascript\nconst set = new Set([\n  ['foo', 1],\n  ['bar', 2]\n]);\nconst m1 = new Map(set);\nm1.get('foo') // 1\n\nconst m2 = new Map([['baz', 3]]);\nconst m3 = new Map(m2);\nm3.get('baz') // 3\n```\n\n### 实例的属性和操作方法\n- size 返回Map结构的成员总数\n- set 设置键名对应的键值，返回整个Map结构\n- get 读取key对应的键值，若找不到，返回undefined\n- has 返回一个boolean值，表示某个键是否在Map中\n- delete 删除某个键，成功则为true，失败则为false\n- clear clear方法清除所有成员，没有返回值\n\nMap的遍历方法与Set结构的遍历方法一致。\n\n### Map与其他结构的转换\n#### 1.Map与数组\nMap转数组可以直接使用扩展运算符`[...]`，数组转Map直接将数组丢进Map的构造函数即可。\n\n#### 2.Map与对象\n若Map的键值都为字符串，则可以转为对象。Map与对象的相互转换都是依靠遍历来进行的。\n\n#### 3.Map与J\bSON\nMap转换JSON有两种情况需要考虑，一种是键名均为字符串的，可以直接转化为对象JSON，其他情况则转化成数组JSON。\n```javascript\nfunction strMapToJson(strMap) {\n  return JSON.stringify(strMapToObj(strMap));\n}\n\nlet myMap = new Map().set('yes', true).set('no', false);\nstrMapToJson(myMap)\n// '{\"yes\":true,\"no\":false}'\n\nfunction mapToArrayJson(map) {\n  return JSON.stringify([...map]);\n}\n\nmapToArrayJson(myMap)\n// '[[true,7],[{\"foo\":3},[\"abc\"]]]'\n```\n\n对应的，JSON转Map也有两种情况。\n```javascript\nfunction jsonToStrMap(jsonStr) {\n  return objToStrMap(JSON.parse(jsonStr));\n}\n\njsonToStrMap('{\"yes\": true, \"no\": false}')\n// Map {'yes' => true, 'no' => false}\n\nfunction jsonToMap(jsonStr) {\n  return new Map(JSON.parse(jsonStr));\n}\n\njsonToMap('[[true,7],[{\"foo\":3},[\"abc\"]]]')\n// Map {true => 7, Object {foo: 3} => ['abc']}\n```\n\n### WeakSet和WeakMap\nWeakSet结构与Set类似，只是WeakSet的成员只能是对象，否则会报错，并且WeakSet不可遍历。\n\nWeakMap的性质同WeakSet。\n\n## Promise 对象\nPromise是用来解决异步编程的回调问题，从语法上说，Promise是一个对象，从它可以获取异步操作的消息。它有三种状态：`Pending(进行中）`，`Resolved(已完成)`，`Rejected(已失败)`。当状态发生改变时，执行相应的函数，并且只有两种改变的可能，从`Pending`变成`Resolved`或者是从`Pending`变成`Rejected`，在状态变化后，状态不会再次发生变化。\n\n### 使用方法\nPromise构造函数接受一个函数作为参数，该函数的两个参数分别是resolve和reject。\nresolve函数的作用是，将Promise对象的状态从“未完成”变为“成功”（即从Pending变为Resolved），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；reject函数的作用是，将Promise对象的状态从“未完成”变为“失败”（即从Pending变为Rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。\n\n```javascript\nvar promise = new Promise(function(resolve, reject) {\n  // ... some code\n\n  if (/* 异步操作成功 */){\n    resolve(value);\n  } else {\n    reject(error);\n  }\n});\n```\nPromise实例有一个then方法，该方法可以接受两个回调函数作为参数。第一个回调函数是Promise对象的状态变为Resolved时调用，第二个回调函数是Promise对象的状态变为Reject时调用。其中，第二个函数是可选的，不一定要提供。\n\n```javascript\npromise.then(function(value) {\n  // success\n}, function(error) {\n  // failure\n});\n```\n关于Promise对象封装的AJAX异步操作实例。\n\n```javascript\nvar getJSON = function(url) {\n  var promise = new Promise(function(resolve, reject){\n    var client = new XMLHttpRequest();\n    client.open(\"GET\", url);\n    client.onreadystatechange = handler;\n    client.responseType = \"json\";\n    client.setRequestHeader(\"Accept\", \"application/json\");\n    client.send();\n\n    function handler() {\n      if (this.readyState !== 4) {\n        return;\n      }\n      if (this.status === 200) {\n        resolve(this.response);\n      } else {\n        reject(new Error(this.statusText));\n      }\n    };\n  });\n\n  return promise;\n};\n\ngetJSON(\"/posts.json\").then(function(json) {\n  console.log('Contents: ' + json);\n}, function(error) {\n  console.error('出错了', error);\n});\n```\nresolve函数的参数除了正常的值以外，还可能是另一个Promise实例，表示异步操作的结果有可能是一个值，也有可能是另一个异步操作。\n下面的代码中p1的状态传递给p2，也就是说，p1的状态决定了p2的状态。如果p1的状态是Pending，那么p2的回调函数就会等待p1的状态改变；如果p1的状态已经是Resolved或者Rejected，那么p2的回调函数将会立刻执行。\n\n```javascript\nvar p1 = new Promise(function (resolve, reject) {\n  // ...\n});\n\nvar p2 = new Promise(function (resolve, reject) {\n  // ...\n  resolve(p1);\n})\n```\n\n### Promise.prototype.then()\nthen方法的作用是为Promise实例添加状态改变时的回调函数并返回一个新的Promise实例。前面说过，then方法的第一个参数是Resolved状态的回调函数，第二个参数（可选）是Rejected状态的回调函数。\n采用链式的then，可以指定一组按照次序调用的回调函数。这时，前一个回调函数，有可能返回的还是一个Promise对象（即有异步操作），这时后一个回调函数，就会等待该Promise对象的状态发生变化，才会被调用。并且可以将前一个调用返回的参数传入到下一个调用中。\n\n```javascript\ngetJSON(\"/post/1.json\").then(function(post) {\n  return getJSON(post.commentURL);\n}).then(function funcA(comments) {\n  console.log(\"Resolved: \", comments);\n}, function funcB(err){\n  console.log(\"Rejected: \", err);\n});\n\ngetJSON(\"/posts.json\").then(function(json) {\n  return json.post;\n}).then(function(post) {\n  // ...\n});\n```\n\n### Promise.prototype.catch()\n`Promise.prototype.catch`方法是`.then(null, rejection)`的别名，用于指定发生错误时的回调函数。\nPromise 对象的错误具有“冒泡”性质，会一直向后传递，直到被捕获为止。也就是说，错误总是会被下一个catch语句捕获。一般来说，不要在then方法里面定义Reject状态的回调函数（即then的第二个参数），总是使用catch方法。因为这种写法可以捕获前面then方法执行中的错误，也更接近同步的写法。\n由于catch方法返回的是一个Promise对象，所以后面还可以接着调用。若前面没有报错，则会跳过catch方法。\n\n```javascript\nvar someAsyncThing = function() {\n  return new Promise(function(resolve, reject) {\n    // 下面一行会报错，因为x没有声明\n    resolve(x + 2);\n  });\n};\n\nsomeAsyncThing()\n.catch(function(error) {\n  console.log('oh no', error);\n})\n.then(function() {\n  console.log('carry on');\n});\n// oh no [ReferenceError: x is not defined]\n// carry on\n```\n\n### Promise.all()\n`Promise.all`方法用于将多个Promise实例，包装成一个新的Promise实例，其参数为一个数组。当多个实例的状态都为`Resolved`时，新的实例状态才会变成`Resolved`，此时多个实例的返回值组成一个数组传给新实例的回调函数。但若有某个实例的状态变成`Rejected`，那么新的实例状态变成`Rejected`。第一个状态变化的实例返回值会传给新的实例。\n\n```javascript\n// 生成一个Promise对象的数组\nvar promises = [2, 3, 5, 7, 11, 13].map(function (id) {\n  return getJSON(\"/post/\" + id + \".json\");\n});\n\nPromise.all(promises).then(function (posts) {\n  // ...\n}).catch(function(reason){\n  // ...\n});\n```\n\n### Promise.race()\n该方法同`Promise.all()`方法类似，不同的是只有有一个实例发生改变，新的实例状态便会改变，那个率先改变的 Promise 实例的返回值，就传递给新实例的回调函数。\n\n### Promise.resolve()\n`Promise.resolve`方法将其它对象转为Promise对象。\n它的参数有四种情况：\n- 参数是一个Promise实例时，不做任何改动。\n- 参数是具有`then`方法的对象，将对象转换后立即执行该`then`方法。\n- 参数不是具有`then`方法的对象，或根本就不是对象时，转换后会使新的Promise对象的状态为`Resolved`，即立即执行其`Resolved`方法。\n- 不带任何参数会直接返回一个`Resolved`状态的Promise对象。\n\n### Promise.reject()\n`Promise.reject(reason)`方法也会返回一个新的 Promise 实例，该实例的状态为`rejected`。\n与`Promise.resolve`方法不同的是，`Promise.reject`方法的参数会原封不动的作为后续方法的参数传入。\n\n```javascript\nconst thenable = {\n  then(resolve, reject) {\n    reject('出错了');\n  }\n};\n\nPromise.reject(thenable)\n.catch(e => {\n  console.log(e === thenable)\n})\n// true\n```\n\n### 附加方法done()和finally()\nPromise对象的回调链，不管以`then`方法或`catch`方法结尾，要是最后一个方法抛出错误，都有可能无法捕捉到（因为Promise内部的错误不会冒泡到全局）。因此，我们可以提供一个`done`方法，总是处于回调链的尾端，保证抛出任何可能出现的错误。\n\n```javascript\nPromise.prototype.done = function (onFulfilled, onRejected) {\n  this.then(onFulfilled, onRejected)\n    .catch(function (reason) {\n      // 抛出一个全局错误\n      setTimeout(() => { throw reason }, 0);\n    });\n};\n```\n\n`finally`方法用于指定不管Promise对象最后状态如何，都会执行的操作。它与`done`方法的最大区别，它接受一个普通的回调函数作为参数，该函数不管怎样都必须执行。\n\n```javascript\nPromise.prototype.finally = function (callback) {\n  let P = this.constructor;\n  return this.then(\n    value  => P.resolve(callback()).then(() => value),\n    reason => P.resolve(callback()).then(() => { throw reason })\n  );\n};\n```\n\n## Iterator\nIterator为可遍历的数据结构提供了一个接口，以更加方便的访问数据结构中的内容。ES6中可遍历的数据结构除了`Array`和`Object`外，新增了`Map`和`Set`两种数据结构。\n\nIterator的遍历过程如下：\n1. 创建一个指针对象，指向当前数据结构的\b起始位置。\n2. 每一次调用一次指针对象的`next()`方法，将指针指向数据结构的下一个成员。\n\n模拟`next()`方法代码：\n```js\nvar it = makeIterator(['a', 'b']);\n\nit.next() // { value: \"a\", done: false }\nit.next() // { value: \"b\", done: false }\nit.next() // { value: undefined, done: true }\n\nfunction makeIterator(array) {\n  var nextIndex = 0;\n  return {\n    next: function() {\n      return nextIndex < array.length ?\n        {value: array[nextIndex++], done: false} :\n        {value: undefined, done: true};\n    }\n  };\n}\n```\n\n### for...of...\n对于拥有Iterator接口的数据结构，可以使用`for...of...`来进行遍历操作。\n\n相比于`for...of...`遍历，`for\b...in...`遍历存在的缺点有：\n1. `for...in...`会遍历原型链上的键。\n2. `for...in...`可能以任意顺序遍历键名。\n\n另外，`for...of...`遍历\b的为value值，而`for...in...`遍历的为key值。\n\n## Generator函数\nGnerator函数会返回一个遍历器对象，同时每一个遍历器对象拥有一种状态，之后通过调用遍历器的`next()`方法来依次执行不同状态的对应的操作。\n\n```js\nfunction* helloWorldGenerator() {\n  yield 'hello';\n  yield 'world';\n  return 'ending';\n}\n\nvar hw = helloWorldGenerator();\n```\n\nGenerator函数的声明需要在`function`后面添加`*`，通过里面的`yield`表达式来定义不同的状态，需要注意的是如果`yield`用在非Generator函数中会报错。\n\nGenerator函数在实例化时并不会执行，而是进入第一个状态的等待态中，这时通过调用`next()`方法会\b将遍历器指针后移，同时执行\b前一个等待态的方法。即`yield`表达式是暂停执行，而`next()`\b则是恢复执行。\n\n```js\nhw.next()\n// { value: 'hello', done: false }\n\nhw.next()\n// { value: 'world', done: false }\n\nhw.next()\n// { value: 'ending', done: true }\n\nhw.next()\n// { value: undefined, done: true }\n```\n\n### next方法的参数\n`yield`表达式本身没有返回值，或者说总是返回`undefined`。`next`方法可以带一个参数，该参数就会被当作上一个`yield`表达式的返回值。\n\n```js\nfunction* f() {\n  for(var i = 0; true; i++) {\n    var reset = yield i;\n    if(reset) { i = -1; }\n  }\n}\n\nvar g = f();\n\ng.next() // { value: 0, done: false }\ng.next() // { value: 1, done: false }\ng.next(true) // { value: 0, done: false }\n```\n\n### for...of循环\n`for...of`循环可以自动遍历 Generator 函数时生成的Iterator对象，且此时不再需要调用next方法。\n\n```js\nfunction *foo() {\n  yield 1;\n  yield 2;\n  yield 3;\n  yield 4;\n  yield 5;\n  return 6;\n}\n\nfor (let v of foo()) {\n  console.log(v);\n}\n// 1 2 3 4 5\n```\n\n这里需要注意，一旦`next()`方法的返回对象的`done`属性为`true`，`for...of`循环就会中止，且不包含该返回对象，所以上面代码的`return`语句返回的6，不包括在`for...of`循环之中。\n\n### Generator.prototype.return()\nGenerator函数返回的遍历器对象，还有一个`return()`方法，可以返回给定的值，并且终结遍历Generator函数。如果不给定值，则会返回`undefined`。\n\n```js\nfunction* gen() {\n  yield 1;\n  yield 2;\n  yield 3;\n}\n\nvar g = gen();\n\ng.next()        // { value: 1, done: false }\ng.return('foo') // { value: \"foo\", done: true }\ng.next()        // { value: undefined, done: true }\n```\n\n### yield* 表达式\n在\b一个Generator函数中调用另一个Generator函数，需要使用`yield *`表达式。\n\n```js\nfunction* foo() {\n  yield 'a';\n  yield 'b';\n}\n\nfunction* bar() {\n  yield 'x';\n  foo();\n  yield 'y';\n}\n\nfor (let v of bar()){\n  console.log(v);\n}\n// \"x\"\n// \"y\"\n```\n\n## async函数\n`async`函数返回一个`Promise`对象，可以使用`then`方法添加回调函数，当函数执行遇到`await`的时候，会等待异步操作完成，再继续执行函数体内后面的语句。\n\n```js\nasync function getStockPriceByName(name) {\n  var symbol = await getStockSymbol(name);\n  var stockPrice = await getStockPrice(symbol);\n  return stockPrice;\n}\n\ngetStockPriceByName('goog').then(function (result) {\n  console.log(result);\n});\n```\n\n`async`函数内部的`return`语句的返回值，会作为`then`方法回调函数的参数，若函数内部抛出异常，则会\b导致返回的`Promise`对象进入到`rejected`状态。因此在使用时，我们通常把`await`放在`try...catch`当中。\n\n如果希望`await`后面的多个请求并发执行，则可以使用`Promise.all()`方法。\n\n## Class的用法\nES6中提供了新的类写法，使用`Class`关键字来声明一个类。在类中有一个`constructor`方法，作为该类的构造方法。同时类的所有方法都定义在类的`prototype`属性上面，`prototype`对象的`constructor`属性，直接指向该类本身，因为在声明类的实例时会自动执行类的构造方法。\n\n```js\n//定义类\nclass Point {\n  constructor(x, y) {\n    this.x = x;\n    this.y = y;\n  }\n\n  toString() {\n    return '(' + this.x + ', ' + this.y + ')';\n  }\n}\n```\n\n### constructor方法\n一个类如果没有显示定义`constructor`方法，则会被默认添加一个构造方法，默认方法返回实例对象，即`this`，也可以指定返回其他对象。\n\n```js\nclass Foo {\n  constructor() {\n    return Object.create(null);\n  }\n}\n\nnew Foo() instanceof Foo\n// false\n```\n\n### get和set方法\n在类的内部可以使用`get`和`set`关键字，对某个属性设置存值函数和取值函数，拦截该属性的存取行为。\n\n```js\nclass MyClass {\n  constructor() {\n    // ...\n  }\n  get prop() {\n    return 'getter';\n  }\n  set prop(value) {\n    console.log('setter: '+value);\n  }\n}\n\nlet inst = new MyClass();\n\ninst.prop = 123;\n// setter: 123\n\ninst.prop\n// 'getter'\n```\n\n### Class的静态方法\n在类的方法前面加上`static`关键字，可以为`Class`声明静态方法，该方法不会被实例继承，而是直接通过类来调用。父类的静态方法可以被子类继承。\n\n```js\nclass Foo {\n  static classMethod() {\n    return 'hello';\n  }\n}\n\nFoo.classMethod() // 'hello'\n\nvar foo = new Foo();\nfoo.classMethod()\n// TypeError: foo.classMethod is not a function\n```\n\n### Class的继承\nES6的`Class`可以通过`extends`关键字来实现继承，在子类的构造器中可以使用`super()`方法来调用父类的构造器，`super`方法也是必须被调用的，用来继承父类的`this`对象，子类是没有自己的`this`对象的。\n\n```js\nClass ColorPoint extends Point {\n  constructor(x, y, color) {\n    super(x, y); // 调用父类的constructor(x, y)\n    this.color = color;\n  }\n\n  toString() {\n    return this.color + ' ' + super.toString(); // 调用父类的toString()\n  }\n}\n```\n\n### Object.getPrototypeOf()\n这个方法可以用来获取到子类的父类。\n\n## 修饰器\n### 类的修饰\n类的修饰器用来改变类的行为，包括为类添加属性或者方法等。\n\n```js\n@testable\nclass MyTestableClass {\n  // ...\n}\n\nfunction testable(target) {\n  target.isTestable = true;\n}\n\nMyTestableClass.isTestable // true\n```\n\n修饰器的行为相当于下面这样。\n\n```js\n@decorator\nclass A {}\n\n// 等同于\n\nclass A {}\nA = decorator(A) || A;\n```\n\n通过返回一个函数的方式可以为修饰器传入参数。\n\n```js\nfunction testable(isTestable) {\n  return function(target) {\n    target.isTestable = isTestable;\n  }\n}\n\n@testable(true)\nclass MyTestableClass {}\nMyTestableClass.isTestable // true\n\n@testable(false)\nclass MyClass {}\nMyClass.isTestable // false\n```\n\n### 方法的修饰\n当修饰器修饰方法时，修饰函数有三个参数，一个是所要修饰的目标对象，第二个是要修饰的属性名称，第三个是属性的描述对象。当有多个修饰器的时候，修饰器的顺序是从上到下按照入栈出栈的形式执行的。另外修饰器只能修饰类中的方法，不能修饰普通的函数，因为普通函数存在函数和变量提升的问题。\n\n```js\nclass Person {\n  @nonenumerable\n  get kidCount() { return this.children.length; }\n}\n\nfunction nonenumerable(target, name, descriptor) {\n  descriptor.enumerable = false;\n  return descriptor;\n}\n```\n","tags":["ES6"],"categories":["前端"]},{"title":"【2017春招】网易游戏前端一面","url":"%2F2017%2F03%2F09%2Farticle-31%2F","content":"2017网易游戏前端开发面试一面题目如下：\n\n<!--more-->\n\n[HTML DOCTYPE 标签是什么意思](/2017/03/09/article-33/)\n\n[实现子元素的垂直居中](/2017/03/10/article-37/)\n\n[什么是HTML的语义化](/2017/04/16/article-42/)\n\n[HTML5中的缓存是怎么实现的](/2017/03/10/article-40/)\n\n[如何解决前端跨域问题](/2017/03/10/article-34/)\n\n[JS原型链是什么](/2017/04/16/article-43/)\n\n[网站性能优化有哪些方式](/2017/04/16/article-44/)\n\n[引用CSS的link和import有什么区别](/2017/04/16/article-45/)","tags":["SEO"],"categories":["面试"]},{"title":"JS实现时间的格式化","url":"%2F2017%2F03%2F07%2Farticle-29%2F","content":"大部分时候，我们都需要显示如下格式的时间：\n\n```\n2017-03-07 08:10:58  //yyyy-mm-dd hh:mm:ss\n```\n\n但是我们却无法直接获取到这种格式的时间，所以可以通过给`Date`对象增加一个`format`方法来实现时间的格式化。\n\n<!--more-->\n\n## dateFormat.js\n\n```javascript\n\nDate.prototype.format = function(fmt) { \n  const o = { \n    \"M+\" : this.getMonth()+1,                 //月份 \n    \"d+\" : this.getDate(),                    //日 \n    \"h+\" : this.getHours(),                   //小时 \n    \"m+\" : this.getMinutes(),                 //分 \n    \"s+\" : this.getSeconds(),                 //秒 \n    \"q+\" : Math.floor((this.getMonth()+3)/3), //季度 \n    \"S\"  : this.getMilliseconds()             //毫秒 \n  }; \n  if(/(y+)/.test(fmt)) {\n    fmt=fmt.replace(RegExp.$1, (this.getFullYear()+\"\").substr(4 - RegExp.$1.length)); \n  }\n  for(let k in o) {\n    if(new RegExp(\"(\"+ k +\")\").test(fmt)){\n      fmt = fmt.replace(RegExp.$1, (RegExp.$1.length==1) ? (o[k]) : ((\"00\"+ o[k]).substr((\"\"+ o[k]).length)));\n    }\n  }\n  return fmt; \n}     \n\n```\n\n## 使用方法\n对一个任意格式的时间`time`如下使用：\n\n```javascript\nnew Date(time).format('yyyy-mm-dd hh:mm:ss');\n```\n\n例如：\n\n```javascript\nnew Date(new Date().toLocaleString()).format('yyyy-mm-dd hh:mm:ss');\nnew Date('July 21, 1983 01:15:00').format('yyyy-mm-dd hh:mm:ss');\n```\n\n","tags":["JavaScript"],"categories":["前端"]},{"title":"JS数组中的map和forEach方法","url":"%2F2017%2F03%2F07%2Farticle-28%2F","content":"map和forEach是JS中对数组的基本遍历方法，相比于普通的for循环，可以让代码显得更加简洁，操作也更加方便。\n\n<!--more-->\n\n# Array.prototype.map()\n\nmap()方法创建一个新数组，其结果是该数组中的每个元素调用一个提供函数的结果。\n\n```javascript\narray.map(callback(currentValue, index, array){\n    //do something\n}, this);\n\narray.map(callback[, thisArg]);\n```\n\n## callback\n为数组中每个元素执行的函数，该函数接收三个参数：\n\n### currentValue(当前值)\n数组中正在处理的当前元素。\n\n### index(索引)\n数组中正在处理的当前元素的索引。\n### array\nforEach()方法正在操作的数组。\n\n### thisArg可选\n可选参数。当执行回调 函数时用作this的值(参考对象)。\n\n## 描述\nmap 方法会给原数组中的每个元素都按顺序调用一次 callback 函数。callback 每次执行后的返回值（包括 undefined）组合起来形成一个新数组。 callback 函数只会在有值的索引上被调用；那些从来没被赋过值或者使用 delete 删除的索引则不会被调用。\n\ncallback 函数会被自动传入三个参数：数组元素，元素索引，原数组本身。\n\n如果 thisArg 参数有值，则每次 callback 函数被调用的时候，this 都会指向 thisArg 参数上的这个对象。如果省略了 thisArg 参数,或者赋值为 null 或 undefined，则 this 指向全局对象 。\n\nmap 不修改调用它的原数组本身（当然可以在 callback 执行时改变原数组）。\n\n使用 map 方法处理数组时，数组元素的范围是在 callback 方法第一次调用之前就已经确定了。在 map 方法执行的过程中：原数组中新增加的元素将不会被 callback 访问到；若已经存在的元素被改变或删除了，则它们的传递到 callback 的值是 map 方法遍历到它们的那一时刻的值；而被删除的元素将不会被访问到。\n\n# Array.prototype.forEach()\nforEach() 方法同map() 方法的使用方法一致，不同的是该方法没有返回值，只是在callback中对数组的每一项`有效值`进行一次处理。注意，这里与map() 方法不同的是，不是对数组的每一个元素都执行callback，而是只对数组中含有有效值的元素执行。 那些已删除（使用delete方法等情况）或者未初始化的项将被跳过（但不包括那些值为 undefined 的项）（例如在稀疏数组上）。\n","tags":["JavaScript"],"categories":["前端"]},{"title":"【数据结构与算法】排序算法","url":"%2F2017%2F03%2F06%2Farticle-27%2F","content":"排序（Sorting) 是将一组数据按照规定顺序进行排列，其目的是为了便于查询和处理数据。字典是典型的排序结构，无论哪种字典，都要将字或词按一定的顺序排列起来，这样才能便于使用。\n\n<!--more-->\n\n## 气泡排序\n\n气泡排序（Bubble Sorting) 是一种最简单的排序算法。设要排序的记录存放在一个数组之中，把关键字较小的记录看成 “较轻的”，所以应该 “上浮”。从底部开始，反复的上下扫描数组。进行每遍扫描的时候，依次考察相邻的两个记录，如果它们的排序位置不对，即 “轻” 的在上面，“重” 的在下面，则将它们互换位置。第一遍扫描，使最轻的记录 “上浮” 到数组的最上面，所以在进行第二遍扫描时，不用比较最顶端的记录。一般来说，第i次的扫描不用比较第i次之前的记录。\n\n代码实现：\n\n```javascript\n\nfunction BubbleSorting(array) {\n  for (var i = 0;i<array.length - 1;i++)\n    for (var j = i+1;j<array.length;j++)\n      if (array[i] > array[j]) {\n        [array[j], array[i]] = [array[i], array[j]];\n      }\n}\n\n```\n\n双向气泡排序，通过每次遍历确定某个位置，该位置的一侧已经有序，从该位置向无序的一侧进行遍历排序。通过此算法可以减少气泡排序外层循环的次数。\n\n代码实现：\n\n```javascript\n\nfunction DoubleBubbleSorting(array) {\n  var flag = true,i = 0,n = array.length;\n  while(flag) {\n    flag = false;\n    for (var j = n-i+1;j>i;j--) \n      if (array[j] < array[j-1]) {\n        flag = true;\n        [array[j], array[j-1]] = [array[j-1], array[j]];\n      }\n    for (var j = i+1;j<=n-i+1;j++) \n      if (array[j] > array[j+1]) {\n        flag = true;\n        [array[j], array[j+1]] = [array[j+1], array[j]];\n      }\n    i++;\n  }\n}\n\n```\n\n## 插入排序\n\n插入排序（Insertion Sorting) 类似玩纸牌时整理手中的纸牌。把被排序的记录逐个取出，插在适当的位置。即进行第i遍整理时，前`i-1`个记录`A[1],A[2],...,A[i-1]`已经排好顺序；取出第i个记录`A[i]`，在整理好的序列中为`A[i]`找到一个合适的位置j，即`A[1],A[2],...,A[j-1]`的关键字都小于或等于`A[i]`的关键字，而`A[j],...,A[i-1]`的关键字都大于`A[i]`的关键字；将从j开始到位置`i-1`的记录全部都后移一步；将原来`A[i]`的数据插在`A[j]`中；于是，`A[1],A[2],...,A[i]`任然是排好顺序的。\n\n代码实现：\n\n```javascript\n\nfunction InsertSorting(array) {\n  for (var i = 0;i<array.length;i++) {\n    var j = i;\n    while (array[j] > array[j+1]) {\n      [array[j], array[j+1]] = [array[j+1], array[j]];\n      j--;\n    }\n  }\n}\n\n```\n\n## 选择排序\n\n选择排序（Selection Sorting) 的基本方法是从`A[1],A[2],...,A[n]`中选出一个关键字最小的记录，换到`A[1]`；第2遍，从`A[2],A[3],...,A[n]`中选出一个关键字最小的记录，换到`A[2]`；...；第i遍，从`A[i],A[i+1],...,A[n]`中选出一个关键字最小的记录，换到`A[i]`；...；重复`n-1`遍。\n\n代码实现：\n\n```javascript\n\nfunction SelectSorting(array) {\n  for (var i = 0;i<array.length - 1;i++) {\n    var lowindex = i;\n    for (var j = i+1;j<array.length;j++) \n      if (array[j] <= array[lowindex])\n        lowindex = j;\n    [array[i], array[lowindex]] = [array[lowindex], array[i]];\n  }\n}\n\n```\n\n## shell排序\n希尔排序（Shell Sorting）又称缩小增量法，基本思想是分组选择排序。即先取定一个整数`d1<n`,把全部结点分成d1个组,所有距离为 d1倍数的记录放在一组中,在各组内进行直接插入排序;然 后取`d2<d1`,重复上述分组和排序工作,直至取`di=1`,即所有 记录放在一个组中排序为止。\n\n代码实现：\n\n```js\n\nfunction ShellSorting(array) {\n  var n = array.length;\n  for (var k = Math.floor(n / 2); k >= 1; k = Math.floor(k / 2)) {\n    for (var j = k; j < n ; j++) {\n      var x = array[j];\n      var i = j - k;\n      while (i >= 0 && array[j] < array[i]) {\n        array[j] = array[i];\n        array[i] = x;\n        i -= k;\n        j -= k;\n      }\n    }\n  }\n}\n\n```\n\n## 快速排序\n\n\n## 归并排序\n## 堆排序\n## 基数排序\n\n\n\n","tags":["算法"],"categories":["算法"]},{"title":"MAC查看端口进程占用","url":"%2F2017%2F03%2F04%2Farticle-26%2F","content":"MAC查看某个端口是否被进程占用的命令为：\n\n  lsof -i tcp:port\n\n查看之后可以获得占用进程的PID，然后使用如下命令杀死进程：\n\n  kill PID\n\n<!--more-->","tags":["mac"],"categories":["后端"]},{"title":"【2017春招】写在前面","url":"%2F2017%2F03%2F01%2Farticle-30%2F","content":"2017年春节刚过，各大公司的校招大战就已开启，很多公司都早早的开始了提前批的内推，想要抢到第一批最优秀的实习生。由于之前竞赛获奖的缘故，所以在联系intel的HR之后，就接到几个部门的面试电话，问了一些简单的问题，大概只要确定不是完全不会就行，情人节那天就给了offer。本来我想做前端的，但是在面前端的团队之前，firmware的Team已经给了offer,所以就不能再去前端部门了。想想也行，毕竟去intel做固件开发要比前端好一些。\n\n虽然已经拿到了一个offer，但是还是想多投一些其它的公司，有多个选择总是好的，而且也可以积累一下面试经验。所以接下来的一两个月就开始了各种投简历——面试环节，遇到的问题不少，写下这篇文章来记录一下各个公司的面试情况。\n\n<!--more-->\n\n## [【2017春招】网易游戏](/2017/03/09/article-31/)\n其中最早开始内推的公司就是网易游戏，在春节前就已经给出了内推消息和QQ群，所以很多人都早早的投了网易游戏，等待大年初八HR小姐姐们开始上班的时候筛选简历。\n\n前端简历的筛选结果是在2月底开始的，3.1号下午面的一面，问的都是一些基础知识点，本来约好的15.00开始，结果15.15才打电话过来，可能是面试官GG比较忙，面的时候也感觉很仓促。相关的面试问题在另一篇文章中，因为刚开学也没有准备，所以没有能够都答出来，最后还是遗憾没能够通过面试。\n\n## [【2017春招】腾讯AlloyTeam](/2017/03/10/article-38)\n3.2号早上的时候看到学校就业群里有学长发了腾讯的内推消息，就投了一波简历，没想到面试消息来得这么快。中午收到短信，通知我下午四点开始面试，面试的部门是AlloyTeam。\n\nAlloyTeam啊！！！大二的时候当时就看到了该团队的博客，还在下面留了一条言问如何能够以后加入该团队，得到的回答是学好基础课就行了，很无奈我学的并不好。咳咳，跑远了，因为根本没有准备啊，就去团队博客看了一下，发现AlloyTeam招前端写的是招JS，心想GG。\n果然，面试的时候基本全部是JS的问题，我这个JS的渣渣，稳挂。\n\n## [【2017春招】阿里weex团队](/2017/03/10/article-39)\n投阿里和腾讯的情况挺像的，都是面的太早了，一点准备都没有，不过跟阿里的面试官聊的挺多的，毕竟问了很多简历上的东西，还是能够侃侃而谈的。\n3.2号中午的时候投的阿里内推，当时想的过两天再做测试题和编程题的，可以先缓两天再面试。结果没想到的是晚上七点就接到了面试电话。OTZ\n\n面试官是一位大姐姐，刚开始没听清她是哪个部门的，后来又问了一下，她告诉我她们以前是淘宝UED的，现在叫淘宝无线，不过她们的团队主要是负责weex的研发。所以面试就主要围绕项目来聊，然后中间会问很多问题，大部分都是移动端相关的。\n面试差不多了，大姐姐说本来约的四十分钟的，现在估计都五十分钟了吧，就到这里吧。挂了以后我一看时间==，竟然聊了105分钟。不过最后还是进了备胎池，可能是面试官一直在反复确认纠结吧。\n\n## [【2017春招】腾讯SNG质量部]()\n之前面的AlloyTeam已经GG了，就没在意这个，所以就随便投了一下。某天接到腾讯深圳总部的电话才知道，是投的SNG的测试，就面了一波。\n\n一面主要问了一些JS的基础知识，可能面试官对前端了解的不多，所以问的也比较简单，都答了出来，后来又聊了波项目，主要就是说说遇到的问题，然后就是问对QQ或者微信聊天做测试的话该怎么去做等等。\n\n过了几天接到二面的约面电话，刚好凑到网易、360、腾讯模拟笔试那一天。二面的话主要聊了下项目，感觉是考察学习能力的，也问了一下对QQ或微信测试的问题，还问了对测试的看法（这个比较有意思）。结束后我问了一下，告诉我如果通过的话后面就是HR面了。\n\nHR面的电话打来的时候我正准备上火车检票，于是就告诉她半个小时后打过来就行。HR面就在火车上进行了。感觉像是查户口一样，HR问我出来干啥，然后就被发现翘课出来找女朋友了TT。聊了大概四十分钟，中途火车上没信号还断了一次，不过HR又打了过来。\n\noffer已经拿到，虽然是系统测试，但是还是蛮想去腾讯的，而且觉得自己现在太菜了，要学的东西还挺多，感觉去腾讯能学到不少。\n\n## [【2017春招】百度地图前端](/2017/04/16/article-48)\n百度春招开启前接到了百度地图的面试电话，以为是学长的内推，后来又接到一个百度的电话才想到这个应该是我在大街网投的。一面主要还是问一些基础，问的比较简单，感觉答的还行，最后面试官也问了我可以实习的时间和可以入职的时间。以为很快就可以等到二面，结果最后还是没有了消息。\n\n## [【2017春招】百度口碑前端](/2017/04/16/article-49)\n接到这个面试与百度地图的面试电话是在同一天，接到的第一反应是二面来的这么快？结果开始面了之后才发现不是二面，而是百度的另一个团队，问的也是以基础为主，但是相比于之前的还是要难不少，自己答的确实不够好。当我问他问题时，我问了一下他们主要使用什么技术栈，面试官好像不是特别高兴，告诉我他们框架什么的也都会用，只是在用框架之前更应该把基础掌握牢固。\n\n面试完之后我就知道这个肯定是过不了的，但是对百度地图还是心存希望的，只是最后没了消息也是让自己备受打击，好像没有一个前端的面试能够获得二面，自己真的是菜的没救了吗？\n\n## [【2017春招】百度云计算事业部]()\n本来已经彻底放弃春招了，因为各大公司的内推都已经结束，BAT的笔试又都没有做，所以就拒了intel准备去腾讯嗨一波。结果偶然在知乎上看见百度云计算招前端工程师，评论区看到可以接受18届实习生，就投了一波简历，很快得到了答复。\n\n邮件回复我们简历已经通过了筛选，但是面试之前需要做一个笔试，十天时间完成一个天气的WEBAPP或者一个地名选择器。很不巧的是那几天要在驾校学车，所以就没有报任何希望，加上面试滴滴被狠虐了一番，一点信心都没了。\n等科三考完试，离截止日期不到四天，心里想着，就当是练手吧，能完成多少是多少。最后半天时，总算把一个差不多像样的WEBAPP给提交了过去，有兴趣的同学可以去看一看——[仿IOS天气预报WEBAPP](https://github.com/helianthuswhite/vue-weather)。\n\n我以为自己尽力了应该很快就会等到面试，结果一周都没有消息，又是被深深的打击了一波。但是在朋友（百度大佬）的劝说下我还是发了封邮件问问情况。很快收到了回复邮件，问我实习时间以及是否愿意接受上海实习。第二天HR打电话来约了面试时间，看来多少还是给了个机会。\n\n在面试百度云计算之前去参加了一下新浪微博的现场面试，讲道理我感觉我答的算是挺好的吧，反正跟面试官感觉说了不少，最后告诉我我的项目很多，但是都没有沉淀，我的技术深度没有达到项目那么多。T T，直接就给挂掉了，心灰意冷，转念一想还是得感谢这个面试官，指出的问题很准确，同时也更感激手上offer了。\n真的是突然感觉自己是真的菜，转眼要实习了，发现自己什么都没有学好，基础很差，技术又不精，心情也很烦躁，游戏也没有任何意思了，过两天的百度面试已经想要放弃了。\n\n该来的还是要来，在没有任何准备的情况下，我开始了百度的面试。一面听起来是个年轻的小哥，听完我的自我介绍之后告诉我我的经历蛮丰富的，我的心里却很无奈，很多面试官听完我的介绍都这样给我说过，可是往往期望也高，失望也会越大。一面的话主要也是问一些基础的知识点，关于html、css、js方面的很快就问完了，之后面试官看我是软件工程专业的，就问我是不是学过数据结构与算法、计算机网络这些课，我心里一想，GG，课本上的知识早就忘的差不多了。面试官先问了一个最简单的冒泡排序，我先把代码说了一遍，然后讲解排序流程的时候把自己给绕进去了。。。。。。因为我记得冒泡排序跟选择排序还有插入排序shell排序好像很像，万一说叉了不是拉闸。好在面试官也没为难我，让我说一下快排，这个记得还是蛮清楚的。之后计网又问了一些问题。最后问题问完，面试官告诉我二面面试官会在十到二十分钟之后联系我，听到这个太开心了我，哈哈哈，我终于也是有二面的人了。\n\n二面的话是一个小姐姐，没有自我介绍，就开始问我一些实际场景，让我说一说实现的方法，JS方面的问的挺多的，最后让我说一下项目，我就主要说了一下那个天气预报WEBAPP的。我感觉二面答的并不够好，面试官最后也告诉我实际上我的项目经验其实并不是那么足，（听到这一句，好吧，拉闸）不过实习的话也够了。哇，真的是一句话听的我的心情是跌宕起伏的。之后面试官就告诉我今天会有经理面。\n\n经理面聊的很轻松，经理了解了我的基本信息等情况之后就让我说说的项目经历，我就从我的第一个项目和第一个竞赛说起，一直把我去年一年的事情都说完了，我感觉自己当时说的肯定是眉飞色舞、神采激昂。不过经理问了一下我们学校的情况，让我觉得难道他是我的老学长？经理面很短，只有二十四分钟，最后经理说面试结束，他马上会把材料整理一下发给HR，等HR联系我就行。总算是有了结果。\n\n## 写在最后\n在拿到百度云计算的offer之后，我的整个春招找实习的过程也就结束了，最后还是确定了百度，终于可以做自己喜欢的工作了。\n\n在这段时间，自己经历了很多面试，也经历了很多失败，发现了自己的渺小，也知道了找工作的艰辛，明白了很多道理，最后能够收获一份自己满意的offer也是很开心很幸运。\n\n如何评价自己接触到的面试官和HR，总得来说，所有公司的HR基本上都是很不错的小姐姐，人很好声音也都好听，哈哈哈，可能是因为职业的缘故吧。至于面试官，也许是我非BAT面的比较少吧，还是觉得BAT的面试官比其他的面试官要好一些，包括问题的拿捏，说话的语气，表达的清晰等。\n\nintel的面试官也算是一直和我联系的导师吧，我差点因为他去了intel，每次给他邮件问问题时回复我都很及时，最后给他发了封邮件告诉他我不去了，他先是立马回了我一份邮件，第二天就打电话问我原因，当我说工资有点低可能付不起房租时，他告诉我他可以先借我钱（哇，顿时好感度上升）。我觉得通过他对一个实习生的态度可以知道自己去一个公司能发挥自己多大的价值以及学到多少东西。\n\n百度云计算的面试官我觉得比较好的一点就是，每次我回答错误的时候对方会告诉我错了，之后会告诉我如何找到正确答案或者是告诉我怎么做是一种更好的做法。这一点我觉得真的蛮重要的，因为好多次面试有些问题都不知道自己说的是不是正确的，而这种情况下一般都会自认为自己说的还行。所以我总是觉得自己答的还行，可以最后就是没有过。\n\n### 【2017春招】就到这里啦，期待接下来的实习生活，期待明年更好的自己~\n","tags":["面试"],"categories":["面试"]},{"title":"We Can't Stop","url":"%2F2017%2F01%2F25%2Fmusic-11%2F","content":"<blockquote class=\"blockquote-center\">Can't you see it's we who own the night?</blockquote>\n\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=100 src=\"//music.163.com/outchain/player?type=2&id=29480187&auto=0&height=66\"></iframe>\n\n<!--more-->\n\n<p style=\"text-align: center;\">We Can't Stop - Boyce Avenue / Bea Miller\n\nRed cups and sweaty bodies everywhere\n举杯欢庆，激情热舞\nHands in the air like we don't care\n挥动双臂，毫不在乎\n'Cause we came to have so much fun now\n欢乐无限，乐趣无穷\nBet somebody here might be the one now\n寻觅派对达人，调动派对气氛\nIf you're not ready to go home\n你若无归家之心\nCan I get a \"Hell, no!\"? (Hell no)\n就尽情狂欢吧\n'Cause we're gonna go all night\n今夜派对，风光无限\n'Til we see the sunlight, alright\n彻夜狂欢，直至天明\nSo la da di da di\n准备好，啦答嘀答嘀\nWe like to party\n我们爱派对\nDancing you and me\n你我共舞\nDoing whatever we want\n随心所欲\nThis is our house,This is our rules\n我们的地盘，我们做主\nAnd we can't stop\n我们无法停止\nAnd we won't stop\n我们难以停止\nCan't you see it's we who own the night?\n夜晚属于我们\nCan't you see it's we who 'bout that life?\n生活由我们缔造\nAnd we can't stop\n我们无法停止\nAnd we won't stop\n我们难以停止\nWe run things, things don't run we\n是我们主宰世界，不是世界主宰我们\nDon't take nothing from nobody\n做真实的自我，不受他人拖累\nYeah, yeah\n耶，耶\nTo my homegirls just tryin' to live it up, shaking it the like they can't they enough....\n家乡姑娘，身材火辣，激情热舞，如临夜店\nRemember only god can judge us.\n记住！只有上帝有权力评判我们\nForget the haters, somebody loves ya.\n忘却仇人，我们会得到真爱\nMemories made 'til the nights through.\n彻夜狂欢，记忆终止\nSurrounded by the ones who love you.\n被爱你的人包围\nWe all so turned up here, getting turned up...yeah!!\n我们欢呼雀跃，啊，无比开心欢腾\nSo... La, di, da, di, di...\n准备好，啦答嘀答嘀\nWe like to party.\n我们爱派对\nDancing you and me, doing whatever we want...\n和我动起来，尽情狂欢\nAnd, this is our house. And, this is our rules.\n我们的地盘，我们做主\nAnd we can't stop.\n我们无法停止\nAnd we won't stop.\n我们难以停止\nCan't you see it's we who own the night?\n夜晚属于我们\nCan't you see it we who about \"that life?\"\n生活由我们缔造\nAnd we can't stop\n我们无法停止\nAnd we won't stop\n我们难以停止\nWe run things. Things don't run we.\n是我们主宰世界，不是世界主宰我们\nDon't take nothing' from nobody\n做真实的自我，不受他人拖累\nYeah! Yeah!\n耶！耶！\nIt's our party. We can do what we want to\n我们的派对，随心所欲\nIt's our house. We can LOVE who want to!\n我们的派对，爱无界限\nIt's our song. We can sing if want to.\n我们的歌谣，毫无限制\nIt's my mouth. I can SAY what I want to!\n我们的嘴巴，话无阻挡\nohhhh.. Ohhhh ohhhhh ohhh\n噢噢噢噢噢\nAnd we can't stop.\n我们无法停止\nAnd we won't stop.\n我们难以停止\nCan't you see it's we who own the night?\n夜晚属于我们\nCan't you see it we who about \"that life?\"\n生活由我们缔造\nAnd we can't stop\n我们无法停止\nAnd we won't stop\n我们难以停止\nWe run things. Things don't run we.\n是我们主宰世界，不是世界主宰我们\nDon't take nothing' from nobody\n做真实的自我，不受他人拖累\nYeah! Yeah!\n耶！耶！\nIt's our party. We can do what we want to\n我们的派对，随心所欲\nIt's our house. We can LOVE who want to!\n我们的派对，爱无界限\nCan't you see it's we who own the night?\n夜晚属于我们\nCan't you see it we who about \"that life?\"\n生活由我们缔造\nIt's our song. We can sing if want to.\n我们的歌谣，毫无限制\nIt's my mouth. I can SAY what I want to!\n我们的嘴巴，话无阻挡\nWe run things. Thins don't run we\n是我们主宰世界，不是世界主宰我们\nCause we can't stop...\n因为我们无法停止···\n</p>","tags":["音乐"],"categories":["故事"]},{"title":"Dream It Possible","url":"%2F2017%2F01%2F22%2Fmusic-10%2F","content":"<blockquote class=\"blockquote-center\">And we’ll dream it possible</blockquote>\n\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=100 src=\"//music.163.com/outchain/player?type=2&id=38592976&auto=0&height=66\"></iframe>\n\n<!--more-->\n\n<p style=\"text-align: center;\">Dream It Possible - Delacey\n\nI will run, I will climb, I will soar\n我奔跑，我攀爬，我会飞翔\nI’m undefeated\n永不言败\nJumping out of my skin, pull the chord\n跳出我的皮肤，拨弄琴弦\nYeah I believe it\n哦，我相信。\nThe past, is everything we were don’t make us who we are\n往昔，逝去的光阴不会决定现在\nSo I’ll dream, until I make it real, and all I see is stars\n所以我们梦想，直到变成真，看到满天星光\nIts not until you fall that you fly\n不怕跌倒，所以飞翔\nWhen your dreams come alive you’re unstoppable\n当你的梦想成真，你是不可阻挡\nTake a shot, chase the sun, find the beautiful\n挥着翅膀，追逐太阳，寻找美丽\nWe will glow in the dark turning dust to gold\n在黑暗中闪耀点石成金\nAnd we’ll dream it possible\n我们会梦想成真\nI will chase, I will reach, I will fly\n我追逐，我奔驰，我要飞翔\nUntil I’m breaking, until I’m breaking\n直到坠落，直到崩溃\nOut of my cage, like a bird in the night\n走出我的囚笼，像在黑夜里的莺\nI know I’m changing, I know I’m changing\n我知道我在变化，在蜕变\nIn, into something big, better than before\n变成无比强大，从未有过\nAnd if it takes, takes a thousand lives\n如果需要牺牲，需要无数的生命\nThen It’s worth fighting for\n那值得去奋斗\nIts not until you fall that you fly\n不怕跌倒，所以飞翔\nWhen your dreams come alive you’re unstoppable\n当你的梦想成真，你是不可阻挡\nTake a shot, chase the sun, find the beautiful\n挥着翅膀，追逐太阳，寻找美丽\nWe will glow in the dark turning dust to gold\n在黑暗中闪耀点石成金\nAnd we’ll dream it possible\n我们会梦想成真\nFrom the bottom to the top\n从山谷到巅峰\nWe’re sparking wild fire’s\n我们正在迸发野火\nNever quit and never stop\n永不放弃，永不停止\nThe rest of our lives\n点燃未来\nFrom the bottom to the top\n从山谷到巅峰\nWe’re sparking wild fire’s\n我们正在迸发野火\nNever quit and never stop\n永不放弃，永不停止\nIts not until you fall that you fly\n不怕跌倒，所以飞翔\nWhen your dreams come alive you’re unstoppable\n当你的梦想成真，你是不可阻挡\nTake a shot, chase the sun, find the beautiful\n挥着翅膀，追逐太阳，寻找美\nWe will glow in the dark turning dust to gold\n在黑暗中闪耀点石成金\nAnd we’ll dream it possible possible\n我们会梦想成真\n</p>\n","tags":["音乐"],"categories":["故事"]},{"title":"合久必婚","url":"%2F2017%2F01%2F22%2Fmusic-9%2F","content":"<blockquote class=\"blockquote-center\">明日若无法遇见更好，我答应最早来到</blockquote>\n\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=100 src=\"//music.163.com/outchain/player?type=2&id=113289&auto=0&height=66\"></iframe>\n\n<!--more-->\n\n<p style=\"text-align: center;\">合久必婚 - 李克勤 / 陈苑淇\n作曲 : 伍乐城\n作词 : 林夕\n\n我大概未算学懂保护别人\n才无名无份以致我们拖拉至今\n令你未放心全程做我一世情人\n彷佛还未够相衬\n大家忙\n多么漂亮理由\n爱不够\n只不过是借口\n凭我爱你这么久\n亦没信心走出教堂\n没理由\n为何未够好 请听我预告\n就算跟你未游尽花都\n可给你的都会做到\n并未求什么\n唯一志愿想你安好\n谁能及我好 我也想知道\n就算这相貌从未讨好\n总可当跟椅垫共老\n任地厚天高\n回家也都想得到拥抱\n除非这感情你不希罕太易得到\n大家忙\n多么漂亮理由\n爱不够\n只不过是借口\n凭我爱你这么久\n亦没信心走出教堂\n没理由\n为何未够好 请听我预告\n就算跟你未游尽花都\n可给你的都会做到\n并未求什么\n唯一志愿想你安好\n为何没结婚 我也想知道\n就算这相貌从未讨好\n总可当跟椅垫共老\n任地厚天高\n回家也都想得到拥抱\n除非这感情你不希罕太易得到\n明日若然你要我抱一抱\n明日若无法遇见更好\n我答应最早来到\n</p>\n","tags":["音乐"],"categories":["故事"]},{"title":"她","url":"%2F2017%2F01%2F22%2Fmusic-8%2F","content":"<blockquote class=\"blockquote-center\">她，留着他最爱的长发</blockquote>\n\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=100 src=\"//music.163.com/outchain/player?type=2&id=31517548&auto=0&height=66\"></iframe>\n\n<!--more-->\n\n<p style=\"text-align: center;\">她 - 周海媚\n作曲 : 刘佳\n作词 : 王韵韵\n\n她 的秋千荡了半个年华\n她 的眼角依然闪着火花\n她 说话的样子嘻嘻哈哈\n热闹的那么风雅\n她 留着他最爱的长发\n她 不再爱玫瑰花\n她 后来一笑而过\n代替翻涌的喧哗 oh 她.....\n她的眼泪看不见却依然洁白无暇\n对伤的痛的选择笑着装聋作哑\n而她 让人心疼的傻瓜\n岁月请留住她\n她的疯狂太温柔却故作潇洒\n对爱的恨的选择放却夜夜梦话\n等她 深夜聊到了喉咙沙哑\n把她的心带回家\n她 的手中捧着流逝的沙\n她 的裙摆露着小小脚丫\n她 听了世上最美的谎话\n就随着他去天涯\n她 被时间陌生了脸颊\n她 熟练对应牵挂\n她 后来轻描淡写\n看似深刻的伤疤 哦她\n她的眼泪看不见却依然洁白无暇\n对伤的痛的选择笑着装聋作哑\n而她 让人心疼的傻瓜\n岁月请留住她\n她的疯狂太温柔却故作潇洒\n对爱的恨的选择放却夜夜梦话\n等她 深夜聊到了喉咙沙哑\n把她的心带回家\n她的眼泪看不见却依然洁白无暇\n对伤的痛的选择笑着装聋作哑\n而她 让人心疼的傻瓜\n岁月请留住她\n她的疯狂太温柔却故作潇洒\n对爱的恨的选择放却夜夜梦话\n等她 深夜聊到了喉咙沙哑\n把她的心带回家\n</p>\n","tags":["音乐"],"categories":["故事"]},{"title":"小半","url":"%2F2017%2F01%2F22%2Fmusic-7%2F","content":"<blockquote class=\"blockquote-center\">纵容着、任性的、随意的、放肆的、轻易的，将所有欢脱倾翻</blockquote>\n\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=100 src=\"//music.163.com/outchain/player?type=2&id=421423806&auto=0&height=66\"></iframe>\n\n<!--more-->\n\n<p style=\"text-align: center;\">小半 - 陈粒\n作曲 : 陈粒\n作词 : 涂玲子\n\n不敢回看\n左顾右盼不自然的暗自喜欢\n偷偷搭讪总没完地坐立难安\n试探说晚安 多空泛又心酸\n低头呢喃\n对你的偏爱太过于明目张胆\n在原地打转的小丑伤心不断\n空空留遗憾 多难堪又为难\n释然 慵懒 尽欢 时间风干后你与我再无关\n没答案 怎么办 看不惯自我欺瞒\n纵容着 喜欢的 讨厌的 宠溺的 厌倦的\n一个个慢慢黯淡\n纵容着 任性的 随意的 放肆的 轻易的\n将所有欢脱倾翻\n不应该 太心软 不大胆 太死板 不果断\n玩弄着肆无忌惮\n不应该 舍弃了 死心了 放手了 断念了\n无可奈何不耐烦\n不算\n灯火阑珊\n我的心借了你的光是明是暗\n笑自己情绪太泛滥形只影单\n自嘲成习惯 多敏感又难缠\n低头呢喃\n对你的偏爱太过于明目张胆\n在原地打转的小丑伤心不断\n空空留遗憾 多难堪又为难\n释然 慵懒 尽欢 时间风干后你与我再无关\n没答案 怎么办 看不惯自我欺瞒\n纵容着 喜欢的 讨厌的 宠溺的 厌倦的\n一个个慢慢黯淡\n纵容着 任性的 随意的 放肆的 轻易的\n将所有欢脱倾翻\n不应该 太心软 不大胆 太死板 不果断\n玩弄着肆无忌惮\n不应该 舍弃了 死心了 放手了 断念了\n无可奈何不耐烦\n任由着 你躲闪 我追赶 你走散 我呼喊\n是谁在泛泛而谈\n任由着 你来了 你笑了 你走了 不看我\n与理所当然分摊\n不明白 残存的 没用的 多余的 不必的\n破烂也在手紧攥\n不明白 谁赧然 谁无端 谁古板 谁极端\n无辜不知所以然\n纵容着 喜欢的 讨厌的 宠溺的 厌倦的（不管）\n一个个慢慢黯淡\n纵容着 任性的 随意的 放肆的 轻易的\n将所有欢脱倾翻\n不应该 太心软 不大胆 太死板 不果断\n玩弄着肆无忌惮\n不应该 舍弃了 死心了 放手了 断念了\n无可奈何不耐烦\n</p>","tags":["音乐"],"categories":["故事"]},{"title":"We Don't Talk Anymore","url":"%2F2017%2F01%2F22%2Fmusic-6%2F","content":"<blockquote class=\"blockquote-center\">We don't talk anymore, we don't talk anymore</blockquote>\n\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=100 src=\"//music.163.com/outchain/player?type=2&id=401249910&auto=0&height=66\"></iframe>\n\n<!--more-->\n\n<p style=\"text-align: center;\">We Don't Talk Anymore - Charlie Puth / Selena Gomez\n\nWe don't talk anymore, we don't talk anymore\n沉默 我们之间只剩无边的沉默\nWe don't talk anymore, like we used to do\n再也回不到从前的耳语亲昵 只剩沉默\nWe don't love anymore\n爱也在这样的沉默里消耗殆尽\nWhat was all of it for?\n这一切究竟是何原因\nOh, we don't talk anymore, like we used to do\n无话不说的从前已成回忆 一切都被沉默代替\nI just heard you found the one you've been looking\n听闻你已找到心仪的他\nYou've been looking for\n而他也如你所愿的爱你\nI wish I would have known that wasn't me\n真希望我能早点明白你要的不是我\nCause even after all this time I still wonder\n分开了那么久我却不知为何\nWhy I can't move on\n还迟迟不肯释怀不肯放手\nJust the way you did so easily\n而你却那么轻易地说走就走\nDon't wanna know\n不想去想\nWhat kind of dress you're wearing tonight\n今夜的你会为他怎样精心装扮自己\nIf he's holding onto you so tight\n也不想去想他会否如我从前那般\nThe way I did before\n将你紧拥在怀里\nI overdosed\n我还沉浸于过去久久不能平息\nShould've known your love was a game\n早该明白你我之间不过游戏\nNow I can't get you out of my brain\n那样也不至于让我至今都忘不了你\nOh, it's such a shame\n真让我无言又无奈\nWe don't talk anymore, we don't talk anymore\n找不到问候的理由 我们之间只剩无边的沉默\nWe don't talk anymore, like we used to do\n也再回不到从前的亲昵耳语 只剩沉默\nWe don't love anymore\n爱也在这样的沉默里消耗殆尽\nWhat was all of it for?\n这一切究竟是何原因\nOh, we don't talk anymore, like we used to do\n无话不说的从前已成回忆 一切都被沉默代替\nI just hope you're lying next to somebody\n希望此时的你正轻靠在某个温暖的怀抱里\nWho knows how to love you like me\n希望他也能像我那般懂得爱你\nThere must be a good reason that you're gone\n那我也能以此为由安慰自己说你离开我也会幸福开心\nEvery now and then I think you\n当我每次想起你\nMight want me to come show up at your door\n都会希望能重回到在你楼下等你的场景\nBut I'm just too afraid that I'll be wrong\n但也许我也只是自己骗自己\nDon't wanna know\n不想去想\nIf you're looking into her eyes\n此时的他是否正深情凝望着你的眼睛\nIf she's holding onto you so tight the way I did before\n也不想去想他会否如我从前那般将你紧拥在怀里\nI overdosed\n我还沉浸于过去久久不能平息\nShould've known your love was a game\n早该明白你我之间不过游戏\nNow I can't get you out of my brain\n那样也不至于让我至今都忘不了你\nOh, it's such a shame\n真让我无言又无奈\nThat we don't talk anymore (We don't, we don't)\n我们无话不说的从前已成回忆\nWe don't talk anymore (We don't, we don't)\n一切都被沉默代替\nWe don't talk anymore, like we used to do\n再也回不到从前的耳语亲昵 一切都已被沉默代替\nWe don't love anymore (We don't, we don't)\n爱也在这样的沉默里消耗殆尽\nWhat was all of it for? (We don't, we don't)\n这一切究竟是何原因\nOh, we don't talk anymore, like we used to do\n无话不说的从前再也回不去\nLike we used to do\n一切都已被沉默代替\nDon't wanna know\n不想去想\nWhat kind of dress you're wearing tonight\n今夜的你会为他怎样精心装扮自己\nIf he's giving it to you just right\n也不想去想他会否如我从前那般\nThe way I did before\n将你紧拥在怀里\nI overdosed\n我还沉浸于过去久久不能平息\nShould've known your love was a game\n早该明白你我之间不过游戏\nNow I can't get you out of my brain\n那样也不至于让我至今都忘不了你\nOh, it's such a shame\n真让我无言又无奈\nThat we don't talk anymore (We don't, we don't)\n一切怎会被沉默代替\nWe don't talk anymore (We don't, we don't)\n无话不说的从前怎会成为回忆\nWe don't talk anymore, like we used to do\n再也回不到从前的耳语亲昵 一切都已被沉默代替\nWe don't love anymore (We don't, we don't)\n爱也在这样的沉默里消耗殆尽\nWhat was all of it for? (We don't, we don't)\n这一切究竟是何原因\nOh, we don't talk anymore, like we used to do\n无话不说的从前已成回忆 一切都已被沉默代替\nWe don't talk anymore\n再也回不到从前的耳语亲昵\nWhat kind of dress you're wearing tonight (Oh)\n我还会去想今夜的你会为他怎样精心装扮自己\nIf he's holding onto you so tight (Oh)\n会去想他会否如我从前那般\nThe way I did before\n将你紧拥在怀里\nWe don't talk anymore (I overdosed)\n一切都已被沉默代替 我还沉浸于过去久久不能平息\nShould've known your love was a game (Oh)\n早该明白你我之间不过游戏\nNow I can't get you out of my brain (Woah)\n那样也不至于让我至今都忘不了你\nOh, it's such a shame\n真让我无言又无奈\nWe don't talk anymore\n美好从前都已被沉默取代\n</p>","tags":["音乐"],"categories":["故事"]},{"title":"来日方长","url":"%2F2017%2F01%2F22%2Fmusic-5%2F","content":"<blockquote class=\"blockquote-center\">我说爱，或许是来日方长的事情</blockquote>\n\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=100 src=\"//music.163.com/outchain/player?type=2&id=429450375&auto=0&height=66\"></iframe>\n\n<!--more-->\n\n<p style=\"text-align: center;\">来日方长 - 薛之谦/黄龄\n作曲 : 常石磊/袁娅维\n作词 : 常石磊\n\n有些东西\n你要是不提 我不去回忆\n惯了借叹气喘息\n再试着碰碰运气\n总要过下去\n总是妄想\n借半生流离 换某人怜悯\n只怪那输得起的\n遇不上看得起的\n找谁对不起\n我说爱 或许是来日方长的事情\n等不到人 也至少盼着自己\n爱 终究是来日方长的秘密\n答案 不过是场 好觉睡醒\n有些东西\n你要是不提 我不去回忆\n只怪那输得起的\n遇不上看得起的\n找谁对不起\n我说爱 或许是来日方长的事情\n等不到人 也至少盼着自己\n爱 终究是来日方长的秘密\n答案 不过是场 好觉睡醒\n</p>","tags":["音乐"],"categories":["故事"]},{"title":"借我","url":"%2F2017%2F01%2F22%2Fmusic-4%2F","content":"<blockquote class=\"blockquote-center\">静看光阴荏苒，借我喑哑无言</blockquote>\n\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=100 src=\"//music.163.com/outchain/player?type=2&id=408814900&auto=0&height=66\"></iframe>\n\n<!--more-->\n\n<p style=\"text-align: center;\">借我 - 谢春花\n作词 : 锦屏\n作曲 : 谢知非\n\n借我十年\n借我亡命天涯的勇敢\n借我说得出口的旦旦誓言\n借我孤绝如初见\n借我不惧碾压的鲜活\n借我生猛与莽撞不问明天\n借我一束光照亮黯淡\n借我笑颜灿烂如春天\n借我杀死庸碌的情怀\n借我纵容的悲怆与哭喊\n借我怦然心动如往昔\n借我安适的清晨与傍晚\n静看光阴荏苒\n借我喑哑无言\n不管不顾不问不说\n也不念\n静看光阴荏苒\n借我喑哑无言\n不管不顾不问不说\n也不念\n借我十年\n借我亡命天涯的勇敢\n借我说得出口的旦旦誓言\n借我孤绝如初见\n借我不惧碾压的鲜活\n借我生猛与莽撞不问明天\n借我一束光照亮黯淡\n借我笑颜灿烂如春天\n借我杀死庸碌的情怀\n借我纵容的悲怆与哭喊\n借我怦然心动如往昔\n借我安适的清晨与傍晚\n静看光阴荏苒\n借我喑哑无言\n不管不顾不问不说\n也不念\n静看光阴荏苒\n借我喑哑无言\n不管不顾不问不说\n也不念\n</p>","tags":["音乐"],"categories":["故事"]},{"title":"童话镇","url":"%2F2017%2F01%2F22%2Fmusic-3%2F","content":"<blockquote class=\"blockquote-center\">总有一条蜿蜒在童话镇里梦幻的河，分隔了理想分隔现实</blockquote>\n\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=100 src=\"//music.163.com/outchain/player?type=2&id=432506345&auto=0&height=66\"></iframe>\n\n<!--more-->\n\n<p style=\"text-align: center;\">童话镇 - 陈一发\n作曲 : 暗杠\n作词 : 竹君\n\n听说白雪公主在逃跑\n小红帽在担心大灰狼\n听说疯帽喜欢爱丽丝\n丑小鸭会变成白天鹅\n听说彼得潘总长不大\n杰克他有竖琴和魔法\n听说森林里有糖果屋\n灰姑娘丢了心爱的玻璃鞋\n只有睿智的河水知道\n白雪是因为贪玩跑出了城堡\n小红帽有件抑制自己\n变成狼的大红袍\n总有一条蜿蜒在童话镇里七彩的河\n沾染魔法的乖张气息\n却又在爱里曲折\n川流不息扬起水花\n又卷入一帘时光入水\n让所有很久很久以前\n都走到幸福结局的时刻\n听说睡美人被埋藏\n小人鱼在眺望金殿堂\n听说阿波罗变成金乌\n草原有奔跑的剑齿虎\n听说匹诺曹总说着谎\n侏儒怪拥有宝石满箱\n听说悬崖有颗长生树\n红鞋子不知疲倦地在跳舞\n只有睿智的河水知道\n睡美人逃避了生活的煎熬\n小人鱼把阳光抹成眼影\n投进泡沫的怀抱\n总有一条蜿蜒在童话镇里七彩的河\n沾染魔法的乖张气息\n却又在爱里曲折\n川流不息扬起水花\n又卷入一帘时光入水\n让所有很久很久以前\n都走到幸福结局的时刻\n总有一条蜿蜒在童话镇里梦幻的河\n分隔了理想分隔现实\n又在前方的山口汇合\n川流不息扬起水花\n又卷入一帘时光入水\n让所有很久很久以前\n都走到幸福结局的时刻 又陌生\n啊~~啊~~啊~~啊~~\n</p>","tags":["音乐"],"categories":["故事"]},{"title":"全世界谁倾听你","url":"%2F2017%2F01%2F22%2Fmusic-2%2F","content":"<blockquote class=\"blockquote-center\">从你的全世界路过，把全盛的我都活过</blockquote>\n\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=100 src=\"//music.163.com/outchain/player?type=2&id=432509483&auto=0&height=66\"></iframe>\n\n<!--more-->\n\n<p style=\"text-align: center;\">全世界谁倾听你 - 林宥嘉\n作词：李焯雄\n作曲：梁翘柏\n\n多希望有一个像你的人\n但黄昏跟清晨无法相认\n雨停了 歌停了 风继续\n雨伞又遗落原地\n多希望你就是最后的人\n但年轮和青春不忍相认\n一盏灯 一座城 找一人\n一路的颠沛流离\n从你的全世界路过\n把全盛的我都活过\n请往前走 不必回头\n在终点等你的人会是我\n多希望你就是最后的人\n但年轮和青春不忍相认\n一盏灯 一座城 找一人\n一路的颠沛流离\n从你的全世界路过\n把全盛的爱都活过\n我始终没说\n不增加你负荷\n最后等你的人是我\n从你的全世界路过\n把全盛的我都活过\n请往前走 不必回头\n在终点等你的人会是我\n你爱默默倾听全世界\n全世界谁倾听你\n一朵一朵 一首一首的曾经\n从你的全世界路过\n把全盛的爱都活过\n我始终没说\n不增加你负荷\n最后等你的人是我\n从你的全世界路过\n把全盛的我都活过\n请往前走 不必回头\n在终点等你的人会是我\n请往前走 不必回头\n在终点等你的人会是我\n</p>","tags":["音乐"],"categories":["故事"]},{"title":"解忧杂货店","url":"%2F2017%2F01%2F22%2Fbook-2%2F","content":"<blockquote class=\"blockquote-center\">不是推理小说，却更扣人心弦</blockquote>\n\n![图片加载失败](http://oetmrek6t.bkt.clouddn.com/book_2.jpg)\n\n<!--more-->\n\n这本书是东野圭吾的作品，虽然不是推理小说，却隐隐约约的添加了推理的意味。\n\n几个不同的烦恼，几位不同的主角，貌似没有关联的故事，却又有着千丝万缕的联系。\n\n过去，现在，还是未来，在思考逻辑的时间之外，充满了最善意的温情。","tags":["书籍"],"categories":["故事"]},{"title":"Merry Christmas","url":"%2F2016%2F12%2F27%2Fstory-6%2F","content":"<blockquote class=\"blockquote-center\">圣诞快乐</blockquote>\n\n![图片加载失败](http://oetmrek6t.bkt.clouddn.com/story_6_title.jpg)\n\n<!--more-->\n\n# PART ONE\n\n<blockquote class=\"blockquote-center\">你就像烟火的美丽，那么美丽</blockquote>\n\n二呆从来没有和女生一起度过圣诞节，所以丫头说让二呆陪她一起过圣诞的时候，二呆走些小紧张，小激动又有点小兴奋。\n\n二呆跑到镇上的网吧，想上网查一下看有没有比较合适的攻略。他想给丫头过一个浪漫又难忘的圣诞节。\n\n“如何陪女生过一个难忘的圣诞节”，二呆把这句话输入到搜索框，一系列的结果出现在屏幕上。\n\n“带她去宾馆，然后嘿嘿嘿”，“用尽十八种姿势让她上天”，“到野外去，在星光下让她感受你的火热”……“呸！都是些啥几把玩意儿”二呆骂了几句，虽然二呆已经十八了，但是他觉得丫头作为他的女神，就像池塘里的那一朵白莲，出淤泥而不染，那种下流的事情他是肯定不会做的。对，可能是因为生活在农村的关系，二呆的思想还是比较保守，自从他知道了男女之事之后，在他脑海里就给扣上了下流的帽子。\n\n二呆失望的出了网吧，往门口的台阶一坐，掏出一根烟点着，抽一口仰望天空吐出一个淡淡的眼圈。二呆觉得自己此时就像一个忧郁的王子，过个圣诞节而已，咋就这么难呢。\n\n“砰——”一根爆竹在二呆旁边炸开，吓得二呆烟都掉到了地上，忧郁的王子一下子变成了暴躁的王子。\n“卧槽，哪个傻逼呢”二呆冲着旁边正在玩爆竹的几个小屁孩吼去。\n突然，有一丝灵感蹿进了二呆的脑子里。\n“哎呀卧槽，你们真他妈是天才！”二呆突然想到可以给丫头来一场浪漫的烟花表演，这能不浪漫，这能不难忘？\n\n可是问题来了，二呆没有那么多钱买烟花。他向好友二狗求助，虽然二狗也没有钱，但是他给二呆提供了一条线索——在镇子东边有一个处理过期和劣质烟花的工厂。\n\n二呆跑到镇子东边如愿以偿的以十分便宜的价格买到了一大堆的烟花。他把它们悄悄的藏在了稻场，那里是用来打麦子和稻谷的，比较空旷，正适合放烟花。现在万事俱备，只需要等待圣诞之夜的到来就好了。\n\n圣诞节很快就到了，在等待的这几天二呆每天都生活在担忧与兴奋的夹界之中。一方面他总是担心自己藏的烟花会被那些贪玩的小鬼头们发现，所以他每天都要去检查一下那些烟花是否还完好；另一方面一想到丫头被自己的烟花表演感动到泪光闪烁的样子，二呆就可以兴奋好久。\n\n圣诞节这天，白天的时候二呆和丫头就跟平时约会一样，上午在镇子里面转一圈，中午一起吃饭，然后下午去网吧打游戏。\n\n“这破游戏有什么意思啊，一点都不好玩”\n在丫头第八次被抓死的时候，丫头气的把耳机往键盘上一砸。\n“哎呀，生啥气勒，等老子后期起来干死他们”二呆还在全神贯注地操作着。\n“玩个屁啊，我让你陪我过圣诞节，你倒好，让我来陪你打游戏”丫头生气的按下了二呆座位上的关机键，走出了网吧。\n\n二呆也急忙下了机追了出去。显然，跟游戏相比，还是妹子比较重要。\n\n“哎呀，生啥子气嘛，今天不是还没过完嘛，急个啥”二呆连忙跟丫头解释道。\n“真的么，那你想陪我怎么过”丫头别过头去，还有些生气。\n“你放心，我肯定会让你过一个难忘的圣诞节”二呆拍拍胸脯说到。\n“那我就勉为其难的再相信你一次”\n\n二呆带着丫头在镇里又转了一圈，然后吃了个饭，七点半，虽然还有点早，但是天已经黑了，可以开始行动了。\n\n于是二呆就拉着丫头到了稻场。晚上的稻场黑漆漆的，丫头的手捏的紧了点，她不知道二呆究竟要干什么。\n不过当她看到二呆搬出一箱箱的烟花的时候，她好像明白了点什么，心里也轻松下来了，“那个呆子，还能想到这种东西啊”。\n\n二呆很快就把烟花摆好了，并用了一根长长的引线把所有烟花桶的引子连到了一起。\n“准备好了么，丫头”，二呆冲丫头露出一口大黄牙。\n“嗯”，丫头轻轻的应了一声，羞涩的就像一位发春的少女。\n\n二呆点燃了引线，跑到了丫头旁边。他们手牵着手，等待烟花绽开的美好瞬间。\n\n“咻～～嘭”，烟花成功的上天并且绽放，小小的火药在空中炸开，燃烧，带着金属的光芒，在空中形成一朵朵绚丽的花朵，整个稻场都被照的亮堂了起来。\n\n“哇～”，丫头痴痴的望着天空，带着小姑娘的欢悦和少女的腮红。\n二呆看着丫头，此时的丫头可爱极了，红红的脸蛋就像是平安夜的苹果，让人好像咬一口。\n看来这个烟花表演果然很有效果啊，自己真是太牛逼了，二呆想着。\n\n“丫头”，二呆轻轻地叫了丫头一声。\n“嗯”，丫头也轻轻地应着。\n二呆含情脉脉地看着丫头，丫头羞涩地低下了头，时不时地抬眼瞧一瞧二呆。\n太浪漫了，二呆脑中想着，他觉得自己现在就像言情小说中的男主角，在感动了女主角后来个浪漫的接吻，简直完美。\n\n“我爱——”，在二呆“你”字还没有说出来的时候，“嘭 ——”一声巨响在他们耳边炸开，有一桶烟花没有上天就炸开了！\n\n二呆和丫头赶紧睁开眼，结果发现出事了！倒不是原地炸开的烟花伤着人了，而是弹开的烟花落到了稻场边缘的谷堆上面，干燥的谷堆一下子就燃了起来。\n二呆有些慌了，他也没料到会发生这样的事情。\n可是事情已经发生，怎么办，跑啊！这是二呆回过神来的第一反应。\n\n二呆拉着丫头快速的跑向镇子的中间，身后稻场的火苗已经蹿的很高了，镇上的大人们都急急忙忙地向那边跑去，准备灭火。路过二呆和丫头时，他们故作镇定的样子并没有太过引起人们的注意。\n“呼 ——”在已经离稻场很远的地方，二呆终于松了口气。\n“怎么办啊，呆子，不会发现我们吧”，丫头有些担心的语气。\n“没啥事的，咱俩刚才跑过来，没有人注意到咱们，不是么”，二呆心里也没有谱，但是还是要先安慰丫头的。\n\n二呆送丫头回家，两个人一路上默默地走着，谁都没有说话。\n\n第二天，二呆在睡梦中被揪着耳朵揪醒。\n事情很快就查了出来，最近买那些劣质烟花的只有二呆。\n那天，似乎整栋楼都听到了二呆的惨叫声。\n\n不过隔日，二呆还是鼻青脸肿的去上课了。\n在周围同学的玩笑声中，二呆长长地叹了口气 —— 倒底还真它妈的是个难忘的圣诞节。\n\n# PART TWO\n\n<blockquote class=\"blockquote-center\">Merry Merry Christmas，Lonely Lonely Christmas</blockquote>\n\n12月24日，平安夜。\n\n当余凡从网吧出来的时候，外面已经开始下起了雪。走的时候网管告诉他今天晚上有活动，可是他并不在意，出来上网只是不想闷在寝室罢了，可是在网吧打了几个小时游戏后却也再感觉不到任何的乐趣。\n余凡想随便走一走，就像平时心情不好的时候一样，吹一吹风就会好受一些。\n\n不知不觉余凡走到了市中心的商业街，作为最繁华的街道，平安夜里自然是人山人海，只是和平日里不同的是，今夜的男女比例有些均衡，来来往往的不是男男女女，而是男女男女。\n虽然已经快要零点，但是街道两旁的商店丝毫没有想要打烊的心思，一家家的音响放着最热闹的音乐来吸引更多的顾客。沿路的小贩也不惧寒冷，售卖着各种有趣的小玩意儿，他们也像在场的大部分人一样盼望着圣诞节的到来，只是他们的目的更单纯而已。身旁的情侣们要么手牵着手，要么互相拥搂，分享着最开心的笑容。相比之下，一个人彳亍着的余凡反而要显得更加显眼。\n可是，他才不会在意那么多。余凡掏出了耳机戴上，仿佛周围的喧闹与他无关。\n\n再往前走就到了江边，夜晚的江面一片漆黑，就像天空的一部分一直绵延到了脚下。宽广的江面总会有很强烈的风，掠过岸边的树梢，留下一阵沙沙的响声。\n这里人很少，余凡找到一个长凳坐下了。\n\n还有半小时圣诞节就来了，余凡看了看时间，虽然脸上没有任何表情，可是心里还是有些难受，不然也不会在深夜一人跑到这里来。\n\n他与她已经分手256天，可是他还是很想她。\n分手那天余凡很平静，就像与她平常对话的那样，余凡答应了她的分手请求，后来余凡也尽力的过着平静的生活，好像分手并没有对他造成任何影响。可是只有余凡知道，他放不下她，他还很想她。\n\n高考填报志愿那天，她告诉他，她想陪他一起看最美的雪。所以他在最后不顾家人的反对，改掉了自己的志愿，最后成功的来到了这个城市。可是她却没有被录取上，留在了家乡的城市。\n结果出来的那天，她很害怕，不敢告诉他这个消息，结果他只是摸了摸她的头，说 “ 傻丫头，没事的，只是异地恋而已，放假的时候不是还可以见面的嘛。”\n她终于破涕为笑，在他的怀里蹭了蹭，“ 嗯，那我圣诞节的时候去找你吧。”\n“ 嗯，好。” 余凡把她搂的更紧了点。\n\n圣诞节的时候，她如约来找他，从南到北，从艳阳到寒雪。\n他在车站接她的时候，她红了眼眶，他把她紧紧抱在怀里。\n\n他带她走过这条繁华的街道，就像大部分的情侣一样，他牵着她，在拥挤的人潮中，他怕一不小心就把她丢了。\n那天的雪很大，温度也是格外的低，可是他们并不觉得冷，因为彼此带来的温暖敌过世间所有的寒冰。\n\n在教堂前面，她告诉他：他日等君来，君若不来，我便不嫁；他回应道：他日盼汝至，汝若不至，我便不娶。这是他们之间最动听的情话，却也是最年轻的承诺。\n\n他们在街中央的西餐厅吃饭，为了衬托圣诞节的气氛，餐厅也做了额外的装潢。他们在情侣区，摇晃的蜡烛照亮了昏暗的房间，也照亮了她的脸庞，由室外进入室内，她的脸颊有些泛红，他笑着望着她：真好看。她的脸颊更红了，好像多了些少女的羞涩。\n\n从餐厅出来，他带她去吃冰棍，虽然不知道为什么，只知道这里冰棍很出名，每次他来这里都会吃。\n“ 呐，给你的 ”，他从人群中挤出来，递给她一支草莓口味的。\n“ 竟然不冷啊，好甜 ”，她有些兴奋，就像吃到糖的小朋友。\n他轻轻地揉了揉她的头发，就像从前座位前后她揉他一样。\n\n再往前的江畔广场此时已经没有了广场舞的喧闹，只剩下售卖孔明灯的小贩和成双入对的情侣们。\n“ 我们也去放孔明灯吧 ”，她提议道。\n“ 嗯 ”。\n他们选好了灯，拿了笔，她在上面写着：天长地久。他们互相写下对方的名字，他的名字清秀整齐，她的名字歪三扭四。他们点了火，等着灯罩慢慢鼓起，一点点的上浮，最后松开了手。\n据说，孔明灯飞的越高越远，上面的愿望就越容易实现。\n忽然，一阵风吹过，孔明灯摇摇晃晃，他们抬头望着有些紧张。\n灯最终没有翻过来，只是挂在了树枝上，当所有人都在担心燃烧的灯罩是否会将干枯的树枝点燃时，她有些慌乱，抓紧了他的手，不知所措。\n终究是让看热闹的人们失望了，孔明灯的燃料慢慢耗尽，从树枝上掉了下来。\n她把头埋在他的怀里，他抱紧了她，告诉她，没事的，不用太相信这个啊。\n\n零点过后，他们一起去看电影，故事是很俗的爱情片，可是大概是因为圣诞节的缘故吧，现场还是有很多女生哭成一片。她没有哭，只是靠在了他的肩上。\n出来后，她告诉他，银幕的爱情很感人，他告诉她，现实的爱情都很简单。\n\n他送她回酒店，他转身要走，她叫住了他。\n“ 你要走啊，不上去坐坐么 ”。\n“ 好啊，既然你都这么说了，嘿嘿嘿~ ”，他做出一脸坏笑。\n“ 哼，看你一脸坏笑，才不让你上去呢。你快回去吧 ”。\n“ 知道啦，你也早点休息吧 ”，他知道她是开玩笑，所以也没有感到懊恼。\n他准备离开，她踮起脚尖，在他脸上亲亲一吻，然后跑进了电梯。\n\n“ 铛——，铛——，铛——。。。。。。”，商业街中心的大钟敲了十二下，又一年的圣诞节到来。\n余凡抬起了头，长吁了一口气，灯光下的脸庞隐隐有着泪水划过的痕迹。\n他想要站起来，由于长时间寒冷导致的麻木让他差点摔倒。他活动了一下身子，让自己尽量能够自由行动。\n“ 过去了，都过去吧 ”，余凡告诉自己。他撇撇嘴，笑了笑，最后给她发了条短信 —— “ 圣诞快乐。” 发完之后，余凡拉黑了通讯录号码，曾经熟记于心的数字，以后再也不会提起了吧。\n\n余凡沿着江边往回走，背后圣诞的喧闹越来越远，耳机里回荡着的还是Eason那熟悉的歌声：\n\n<p style=\"text-align: center;\">Merry Merry christmas\nLonely Lonely Christmas\n写了卡片能寄给谁\n心碎得像街上的纸屑\n谁来陪我过这圣诞节\n......</p>\n\n\n# PART THREE\n\n<blockquote class=\"blockquote-center\">为你我用了半年的积蓄，漂洋过海的来看你</blockquote>\n\n坐在火车上，耀川望着窗外，一片片被雪覆盖的田地从他的眼中掠过。火车里的温度越来越高了，窗户渐渐凝起了水珠，向下流过。\n\n“ 小伙子，看着水 ”，待得旁人提醒，耀川才发现淌下的水珠已经沾湿了自己的衣袖。\n“ 谢谢 ”，耀川一边道谢一边拿出纸巾把窗边沿的水珠吸食干净。\n\n耀川此行要翘两天的课，坐十六个小时的硬座，走过一千七百多公里，去见一个人。\n确切地说，是一个网友。\n耀川不明白自己为什么会这么冲动，可能真的像他说的那样，他喜欢她，耀川喜欢一个素未谋面的网友。\n\n耀川自己都没有想过会以这样的方式去喜欢一个人。\n\n那天，室友说要给耀川介绍一个对象，耀川摇摇头，“ 还是算了吧，现在这样挺好的。”\n可是第二天，耀川想了想，还是向室友要了那个女生的联系方式，应该是看出来女孩挺漂亮吧，男生第一眼都会只看外表。\n\n今天是十二月二十三，距离他们认识两个月整。明天是圣诞节，所以耀川想要去找她。\n耀川没有经历过网恋，之前的异地恋只维持了不到两个月，连追女生也是头一遭。\n\n耀川觉得那个女孩和他很像，在很多方面，所以耀川动心了，他想要追她，合不合适在一起才知道。\n他向好友求助如何追女孩子，好友推荐给他一些攻略，他看了觉得一点都不靠谱，与其说是追女孩子的攻略不如说是约炮攻略。所以，这条路，还得耀川自己摸索。\n\n耀川准备了一个小本本，上面记录着她说的话，她的喜好，因为耀川怕哪天忘了之前她说的什么让她生气。\n她说她笑点比较低，他会找一些有趣的图片给她看。\n她说她喜欢小猫和哈士奇，所以他会找到萌萌的小猫照片或是蠢蠢的哈士奇照片。\n她说她不怎么会聊天，所以他会绞尽脑汁的去想一些话题，因为他也不会聊天。\n她说她不喜欢自己的话是最后一句，所以无论她说什么他都会回复，哪怕只是一个标点。\n她说她吃糖的时候心情会变好，所以他给她买了很多糖果，希望她在生气的时候吃糖果让心情变好。\n她说她不喜欢幼稚的男生，所以他会尽量去表现的成熟，可是又忍不住想要给她发一些可爱的表情。\n她说她作业很多不一定写的完，所以他会放下自己要复习的考试，帮她完成她的任务。\n她说......\n耀川不会追女生，但是他对人很好，所以他知道自己应该对喜欢的人更好。\n\n已经过了零点了，可是车厢里的人们仍没有要休息的迹象。长途硬座车厢总是挤满了人，站着的、坐着的、还有蹲着的，人一多就变得嘈杂，与车厢里的暖气一起哄的人头疼。耀川不喜欢人多嘈杂的地方，就像她也不喜欢一样。\n\n耀川打开背包，伸手摸了一下里面的东西，还好，没有化掉。那是准备给她的礼物。耀川很早就已经买了，因为怕双十二的时候物流太慢不能及时收到。\n在走之前，耀川还在纠结该穿什么衣服过去，虽说只是见网友，但毕竟心里也是有着美好的愿望。最终他还是穿上了最近才买的，他打算过年穿的那套衣服，第一次见面当然要留一个好的印象啊，他这样告诉自己。\n\n耀川实在有些撑不住了，他头倚着窗，就这样睡了。\n他醒来的时候已经中午了，坐着睡毕竟是睡不好的，他夜里醒来好多次，现在也觉得浑身酸痛。刚才广播里播报，列车晚点一个半小时，这对他来说更增几分煎熬。\n\n“ 下一站就到啦 ”，耀川告诉她，有点兴奋，掺杂着激动，更少不了紧张。\n“ 那我去接你吧 ”，她回复。\n“ 哎呀，不用啦，而且人家一路坐车蓬头垢面的怎么好意思见你 ”，耀川假设过这种情况发生，所以提前就准备好了回答。可是过了一会儿，他又有点后悔了，他想要早点见到她。而且他觉得，相比于完美的自己，他更愿意她接受不完美的自己。\n\n最终他们还是没有在火车站见着面，不过这对已经抵达这座城市的耀川来说并没有太大的影响。\n耀川打了车前往提前预定好的宾馆。简单收拾一下又洗个澡之后，他又打车到他们约定的见面地点，现在是下午四点半，比计划晚了两个小时。\n\n耀川没有感觉太意外，她给他的感觉与隔着网络一样，也许比想象中的矮一点，现在的他可以很轻松的摸到她的头。\n她带耀川去吃饭，填饱肚子之后天色已经有点晚了，原定的上网计划只能提前了。因为她想，所以计划里必须有这个。倒不是耀川不喜欢陪她上网，只是他觉得约会应该做点更浪漫的事。\n从网吧出来十点多，他把她送回家。第一次见面，他觉得应该没有给她留下什么不好的印象。\n\n第二天，不幸的是，雾霾和感冒打乱了耀川的计划，不是耀川感冒，而是她，只是耀川不想让她感冒加重。\n她带着他吃了她很爱的花甲粉，不过她说没有她们学校的好吃。\n吃完饭后她带他去看她的学校，因为耀川一直觉得她的学校很漂亮，所以他想去看一看。已经放假的校园剩不下多少人，风也有些大，吹得两人将手缩在各自的口袋。她给他讲，那排红色的楼是她们的寝室；路中间的时钟据说需要五百万；湖中间的小岛有鹿和孔雀；夏天的时候湖里会有很多的鱼和蝌蚪......\n终于上了公交车，耀川才觉得暖和了点。他觉得她应该会觉得更冷，所以他不想再带她在室外逛了，他看了一下他的计划，室内活动只有电影和上网。\n“ 现在我们去哪啊 ”，她问他。\n“ 要不我们回去玩那个密室吧 ”，他想起来中午吃饭的时候路过看到一家密室，她说她没有玩过，想要试一下。\n\n两个人玩密室有些吃力，即使耀川觉得自己算是个推理达人，一个小时时间两人最终没能解开第三个谜题。\n不过有意思的是中间的一个问题的答案是需要两个人手拉手才能完成，耀川拉着她的手，有点凉，这是他的感受。\n那家密室还有另一个让耀川觉得比较棒的事情就是，玩密室后可以去另一家私人影吧看电影，这样就又解决了一个找不到去哪里玩的难题。\n\n影吧的大厅有一只猫，挺可爱的，耀川和她都挺喜欢。在等空房间的空闲就靠着这只猫来打发两个人的时间。猫咪可能有些饿了，一直在找他们中午买的小蛋糕，找不到就咬耀川的手指，不用力，就像撒娇要糖的小朋友。耀川拿出手机想要拍一下猫咪，顺便偷偷拍一下她，不过连拍了两张，效果都不是特别理想。\n后来他们选了一张恐怖片，就像很多爱看恐怖片的女孩子一样，她也很喜欢，可是又不敢看，所以在看的时候总是偷偷的偏过头或者捂着眼。\n\n从影吧出来到了吃晚饭的时间，他们随便吃了点小吃。\n“ 接下来干嘛啊 ”，还是一样的问题。\n已经看过电影了，再看不合适，找个咖啡厅坐着聊聊天吧，两个都不爱说话的人也聊不了什么，出去逛街吧，太冷了还容易让她生病加重，想来想去，耀川最终还是决定跟她去网吧。\n因为是圣诞节，所以耀川没有提醒她时间，两个人玩到了过零点才下机。\n\n两个人从网吧出来，街道上已经没有多少人了，虽然没有什么话可以说，可是两个人还是走了挺久。\n“ 要不我送你到下个路口吧，已经太晚了，也不能送你太远 ”，她说。\n“ 这样啊，那我还是送你回家吧，太晚了我不太放心啊 ”，耀川这样回到，只是为了能够多陪她走一段路。\n短短的一段路程，耀川却觉得走了好久，终于把她送到了小区门口，两人道了别。\n“ 我到家了，你走到哪里了 ”，她发来消息。\n“ 就是走到我们折返的那个路口 ”。\n“ 从我家可以看到那里，你开下手电筒，我试试能不能看到 ”。\n耀川找了半天没有找到手电筒在哪，只能开了录像的闪光，在十字路口的中央挥舞着手臂。\n“ 看到啦，快点回去吧 ”。\n“ 嗯，早点休息，晚安 ”。\n“ 晚安 ”。\n“ ~ ”。\n耀川回到宾馆，明天就要回去了，该好好想一想明天的计划。\n\n早上的时候她告诉他，她发烧了。而且，外面下起了雨。这是耀川最不想看到的结果。\n“ 你起来了告诉我，我带你去打针 ”，耀川给她发了条消息，她没有回，应该是睡着了。\n耀川想，在宾馆待着也是没事，所以就去前台退了房。\n\n耀川要先去买一把伞，在结账的时候看到柜台前有她喜欢的阿尔卑斯糖。她喜欢阿尔卑斯原味和草莓味的，软糖喜欢巧克力味的，耀川这样想到，就要了两条阿尔卑斯原味的硬糖，两条草莓味的和两条巧克力味的软糖。\n出了店，一手撑着伞，一手提着糖耀川不知道往哪走。这时，他想起来昨天她提到的玫瑰谷，那是一家蛋糕店，他想吃蛋糕了，他想她也应该想吃蛋糕了。\n\n靠着导航，走了大概半个小时，耀川终于找到了玫瑰谷的所在。店面不大，图片上的应该是总店。\n他很快在里面转了一圈，最终挑了一盒抹茶蛋糕、一盒泡芙和一个玛奇朵，店员包好后递给他，他小心翼翼的和之前的糖放在一个袋子里。\n\n从玫瑰谷到她家步行大概有一个小时的路程，他没有坐车，因为他觉得她醒来可能还要挺久。\n雨已经挺小了，只是风还很大，耀川裹紧了衣服，这样可以让自己暖和一点。\n\n已经中午了，她还没有回消息，下午的车不算晚，所以耀川需要在中午过一点就得往车站走。\n耀川觉得今天应该不能再见到她了，他走进了她家小区旁的超市，进去买了点东西，把蛋糕和糖放在了柜台，叮嘱收银员会有人来取。\n“ 我走了 ”，他给她发了条消息，她还是没有回。\n\n在公交已经走了一半的路程时，她回了消息，“ 我睡过了 ”。\n“ 嗯，那你记得去打针 ”，耀川有点失望，可能是因为没有在走之前见着她最后一面。\n\n在车站等车的时候是最无聊的，车站人很多，耀川没有地方坐，只能靠在墙上。\n他回想着这两天的情景，她对他还算满意吧，他想着，可是却因为他导致她发烧了。耀川突然意识到这个问题，她之前是告诉过他她感冒了的，可是他却还是要她陪他出来。耀川越想越觉得不安，他看了看时间，离发车还有一个小时。\n“ 你现在能起来么，我送你去医院 ”，来回打车四十分钟，二十分钟带她去医院，时间应该来得及吧，耀川在心里算着。\n“ 没事啊，小病而已，你不是要上车了嘛 ”。\n“ 来得及的，而且车肯定会晚点的 ”。\n“ 我起来还要很久的，而且我爸会带我去的，不用担心 ”。\n“ 嗯，那好吧 ”，耀川已经出了车站，看来带她去打针确实是不太可能了。\n\n耀川戴上了耳机，静静地等待着火车的到来。\n\n\n","tags":["故事"],"categories":["故事"]},{"title":"岛上书店","url":"%2F2016%2F12%2F12%2Fbook-1%2F","content":"<blockquote class=\"blockquote-center\">没有谁是一座孤岛</blockquote>\n\n![图片加载失败](http://oetmrek6t.bkt.clouddn.com/book_1.jpeg)\n\n<!--more-->\n\n没有谁是一座孤岛，每本书都是一个世界。\n\n我们读书而后知道我们不孤单。我们读书，因为我们孤单，我们读书，然后就不孤单。我们并不孤单。\n\n我们不全是长篇小说，也不全是短篇故事。最后的最后，我们成为一部人生作品集。\n","tags":["书籍"],"categories":["故事"]},{"title":"CSS中的定位","url":"%2F2016%2F12%2F12%2Farticle-25%2F","content":"# CSS中的定位机制\nCSS 有三种基本的定位机制：文档流、浮动和绝对定位。\n\n文档流即元素本身的默认定位方式，所有的`html`标签按照块级元素从上到下，行内元素从左到右的方式正常排列。\n\n浮动定位会使元素脱离正常的文档流，可以将其理解为浮动在正常文档流的上方，所以对文档流中的其他元素来说，浮动元素相当于不存在。当浮动元素遇到包含框或者另一个浮动框的边框时，将会停止。\n\n绝对定位是使元素在文档流中相对于任何非`static`定位的父元素的定位，也是常用来控制元素定位的一种方式。\n\n<!--more-->\n\n# CSS中的position属性\n## static定位\n元素框正常生成。块级元素生成一个矩形框，作为文档流的一部分，行内元素则会创建一个或多个行框，置于其父元素中。该属性为元素的默认`position`属性值。\n\n示例：\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n\t<meta charset=\"UTF-8\">\n\t<title>Document</title>\n\t<style type=\"text/css\">\n\t\t.father {\n\t\t\tposition: static;\n\t\t}\n\t\t.son1 {\n\t\t\tposition: static;\n\t\t}\n\t\t.son2 {\n\t\t\tposition: static;\n\t\t}\n\t</style>\n</head>\n<body>\n<div class=\"father\">\n\t<div class=\"son1\" style=\"background: red;width: 200px;height: 200px;\">块1</div>\n\t<div class=\"son2\" style=\"background: blue;width: 200px;height: 200px;\">块2</div>\n</div>\n</body>\n</html>\n```\n![图片加载失败](http://oetmrek6t.bkt.clouddn.com/article_25_1.png)\n\n## relative定位\n元素框偏移某个距离。元素仍保持其未定位前的形状，它原本所占的空间仍保留。相对于元素原来的正常文档流进行偏移。\n\n示例：\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n\t<meta charset=\"UTF-8\">\n\t<title>Document</title>\n\t<style type=\"text/css\">\n\t\t.father {\n\t\t\tposition: static;\n\t\t}\n\t\t.son1 {\n\t\t\tposition: relative;\n\t\t\tleft: 100px;\n\t\t}\n\t\t.son2 {\n\t\t\tposition: static;\n\t\t}\n\t</style>\n</head>\n<body>\n<div class=\"father\">\n\t<div class=\"son1\" style=\"background: red;width: 200px;height: 200px;\">块1</div>\n\t<div class=\"son2\" style=\"background: blue;width: 200px;height: 200px;\">块2</div>\n</div>\n</body>\n</html>\n```\n![图片加载失败](http://oetmrek6t.bkt.clouddn.com/article_25_2.png)\n\n## absolute定位\n元素框从文档流完全删除，并相对于其包含块定位，也就是任何非`static`定位的父元素的定位。元素原先在正常文档流中所占的空间会关闭，就好像元素原来不存在一样。元素定位后生成一个块级框，而不论原来它在正常流中生成何种类型的框。\n\n示例一：\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n\t<meta charset=\"UTF-8\">\n\t<title>Document</title>\n\t<style type=\"text/css\">\n\t\t.father {\n\t\t\tposition: static;\n\t\t\tleft: 100px;\n\t\t}\n\t\t.son1 {\n\t\t\tposition: absolute;\n\t\t\tleft: 100px;\n\t\t}\n\t\t.son2 {\n\t\t\tposition: static;\n\t\t}\n\t</style>\n</head>\n<body>\n<div class=\"father\">\n\t<div class=\"son1\" style=\"background: red;width: 200px;height: 200px;\">块1</div>\n\t<div class=\"son2\" style=\"background: blue;width: 200px;height: 200px;\">块2</div>\n</div>\n</body>\n</html>\n```\n![图片加载失败](http://oetmrek6t.bkt.clouddn.com/article_25_3.png)\n\n示例二：\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n\t<meta charset=\"UTF-8\">\n\t<title>Document</title>\n\t<style type=\"text/css\">\n\t\t.father {\n\t\t\tposition: relative;\n\t\t\tleft: 100px;\n\t\t}\n\t\t.son1 {\n\t\t\tposition: absolute;\n\t\t\tleft: 100px;\n\t\t}\n\t\t.son2 {\n\t\t\tposition: static;\n\t\t}\n\t</style>\n</head>\n<body>\n<div class=\"father\">\n\t<div class=\"son1\" style=\"background: red;width: 200px;height: 200px;\">块1</div>\n\t<div class=\"son2\" style=\"background: blue;width: 200px;height: 200px;\">块2</div>\n</div>\n</body>\n</html>\n```\n![图片加载失败](http://oetmrek6t.bkt.clouddn.com/article_25_4.png)\n\n示例三：\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n\t<meta charset=\"UTF-8\">\n\t<title>Document</title>\n\t<style type=\"text/css\">\n\t\t.father {\n\t\t\tposition: relative;\n\t\t\tleft: 100px;\n\t\t}\n\t\t.son1 {\n\t\t\tposition: absolute;\n\t\t\tleft: 100px;\n\t\t}\n\t\t.son2 {\n\t\t\tposition: absolute;\n\t\t}\n\t</style>\n</head>\n<body>\n<div class=\"father\">\n\t<div class=\"son1\" style=\"background: red;width: 200px;height: 200px;\">块1</div>\n\t<div class=\"son2\" style=\"background: blue;width: 200px;height: 200px;\">块2</div>\n</div>\n</body>\n</html>\n```\n![图片加载失败](http://oetmrek6t.bkt.clouddn.com/article_25_5.png)\n\n示例四：\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n\t<meta charset=\"UTF-8\">\n\t<title>Document</title>\n\t<style type=\"text/css\">\n\t\t.father {\n\t\t\tposition: absolute;\n\t\t\tleft: 100px;\n\t\t}\n\t\t.son1 {\n\t\t\tposition: absolute;\n\t\t\tleft: 100px;\n\t\t}\n\t\t.son2 {\n\t\t\tposition: static;\n\t\t}\n\t</style>\n</head>\n<body>\n<div class=\"father\">\n\t<div class=\"son1\" style=\"background: red;width: 200px;height: 200px;\">块1</div>\n\t<div class=\"son2\" style=\"background: blue;width: 200px;height: 200px;\">块2</div>\n</div>\n</body>\n</html>\n```\n![图片加载失败](http://oetmrek6t.bkt.clouddn.com/article_25_4.png)\n\n示例五：\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n\t<meta charset=\"UTF-8\">\n\t<title>Document</title>\n\t<style type=\"text/css\">\n\t\t.father {\n\t\t\tposition: fixed;\n\t\t\tleft: 100px;\n\t\t}\n\t\t.son1 {\n\t\t\tposition: absolute;\n\t\t\tleft: 100px;\n\t\t}\n\t\t.son2 {\n\t\t\tposition: static;\n\t\t}\n\t</style>\n</head>\n<body>\n<div class=\"father\">\n\t<div class=\"son1\" style=\"background: red;width: 200px;height: 200px;\">块1</div>\n\t<div class=\"son2\" style=\"background: blue;width: 200px;height: 200px;\">块2</div>\n</div>\n</body>\n</html>\n```\n![图片加载失败](http://oetmrek6t.bkt.clouddn.com/article_25_4.png)\n\n## fixed定位\n元素框的表现类似于将`position`设置为`absolute`，不过其包含块是视窗本身。\n\n示例：\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n\t<meta charset=\"UTF-8\">\n\t<title>Document</title>\n\t<style type=\"text/css\">\n\t\t.father {\n\t\t\tposition: relative;\n\t\t\ttop: 100px;\n\t\t}\n\t\t.son1 {\n\t\t\tposition: fixed;\n\t\t\tleft: 100px;\n\t\t}\n\t\t.son2 {\n\t\t\tposition: static;\n\t\t}\n\t</style>\n</head>\n<body>\n<div class=\"father\">\n\t<div class=\"son1\" style=\"background: red;width: 200px;height: 200px;\">块1</div>\n\t<div class=\"son2\" style=\"background: blue;width: 200px;height: 200px;\">块2</div>\n</div>\n</body>\n</html>\n```\n![图片加载失败](http://oetmrek6t.bkt.clouddn.com/article_25_6.png)\n","tags":["CSS"],"categories":["前端"]},{"title":"冰城","url":"%2F2016%2F11%2F28%2Fstory-4%2F","content":"<blockquote class=\"blockquote-center\">找一个人相陪，找一颗心相随</blockquote>\n\n![图片加载失败](http://oetmrek6t.bkt.clouddn.com/story_4_title.jpeg)\n\n<!--more-->\n\n<div style=\"text-align: center;\">\n 冬已至，雪将飘\n 愿得一人陪我疯闹\n 在这美丽的冰城\n 把那寒冰都融化了\n\n![图片加载失败](http://oetmrek6t.bkt.clouddn.com/story_4_1.jpg)\n\n 与你在古老的中央大街嬉笑\n 大声欢笑让别人都知道\n 看街旁美丽的灯光闪耀\n 吃着美味的马迭尔冰棍\n 很冷，你却还想要\n\n![图片加载失败](http://oetmrek6t.bkt.clouddn.com/story_4_2.jpeg)\n\n\n 牵着你的手怕你丢掉\n 带你到索菲亚教堂\n 为思念的爱人祈祷\n 然后我们坐在广场的长凳\n 看看喷泉可好\n\n ![图片加载失败](http://oetmrek6t.bkt.clouddn.com/story_4_3.jpeg)\n \n 从大街的一头寻找\n 把这里的饰品店都逛掉\n 希望能够找到\n 一样能够与你般配的宝\n 渐渐的，等黎明破晓\n\n ![图片加载失败](http://oetmrek6t.bkt.clouddn.com/story_4_8.jpg)\n\n 为你准备温暖的早餐\n 听你温柔的说一声，早\n 带你来到防洪纪念塔\n 拍一张照\n 然后去斯大林公园\n 听听音乐，逗逗小鸟\n\n ![图片加载失败](http://oetmrek6t.bkt.clouddn.com/story_4_9.jpeg)\n\n 等到船家开始工作了\n 我们可以去买两张船票\n 越过松花江时\n 在宽阔的江面远眺\n 寒风有点冷，我可以借你怀抱\n\n ![图片加载失败](http://oetmrek6t.bkt.clouddn.com/story_4_5.jpeg)\n\n 下了船我们就到了太阳岛\n 周围有树木环抱\n 里面有人们开心的笑\n 我想找一个安静的地方\n 和你聊聊天就好\n \n ![图片加载失败](http://oetmrek6t.bkt.clouddn.com/story_4_6.jpeg)\n\n 这里的风景甚是美妙\n 在离开时不要觉得时间太少\n 以后若有机会\n 我会带你再走一道\n 希望那时你不会轻易把我拒掉\n\n  ![图片加载失败](http://oetmrek6t.bkt.clouddn.com/story_4_4.jpeg)\n\n 地球环绕，夜幕会到\n 来时的船只换了装貌\n 彩灯张结，霓虹闪耀\n 美丽的一幕幕不要看的呆掉\n 后面还有，更美的没到\n\n  ![图片加载失败](http://oetmrek6t.bkt.clouddn.com/story_4_7.jpeg)\n\n 天气会更加寒冷了\n 窗外的寒风奔驰呼啸\n 请你不要害怕\n 因为你有我的怀抱\n\n  ![图片加载失败](http://oetmrek6t.bkt.clouddn.com/story_4_10.jpg)\n\n 我们可以到最高的龙塔\n 看万里的疆土冰封\n 听高空的气流咆哮\n 偷偷把手伸出外套\n 感受到高处不胜寒的真奥\n\n![图片加载失败](http://oetmrek6t.bkt.clouddn.com/story_4_11.jpg)\n\n 静候能工巧匠们的创造\n 将厚厚的冰块\n 变成各种各样的奇妙\n 在冰雪大世界里\n 穿越冰冻的城堡\n 陪你放肆的玩闹\n \n ![图片加载失败](http://oetmrek6t.bkt.clouddn.com/story_4_12.jpg)\n\n 听解说员的介绍\n 摸摸看能不能感受到\n 稍微累了，冻了\n 我们可以去室内看看舞蹈\n 只是在温暖的怀抱\n 你不可以想要睡觉\n\n  ![图片加载失败](http://oetmrek6t.bkt.clouddn.com/story_4_13.png)\n\n 分开的日子会到\n 不要觉得难过了\n 虽然我们还没有一起细细观察雪花\n 虽然我们还没有一起开心的打过雪仗\n 虽然我们还没有一起堆起一个可爱雪人\n 虽然我们还没有一起穿着冰刀在冰面舞蹈\n 不过，没关系\n\n  ![图片加载失败](http://oetmrek6t.bkt.clouddn.com/story_4_14.png)\n \n 你离开的时候\n 我会将未完成的事情做到\n 我会做一片永不融化的雪花送给你\n 我会把和小伙伴打雪仗的画面放给你\n 我会堆起一个独一无二的大雪人照给你\n 我会穿着冰刀在光滑的冰面上舞一支给你\n 所以，请不要难过\n 等来年，你来到\n 我会陪你再走一遭\n </div>\n","tags":["故事"],"categories":["故事"]},{"title":"不为谁而作的歌","url":"%2F2016%2F11%2F28%2Fmusic-1%2F","content":"<blockquote class=\"blockquote-center\">梦为努力浇了水，爱在背后往前推</blockquote>\n\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=100 src=\"//music.163.com/outchain/player?type=2&id=409060875&auto=0&height=66\"></iframe>\n\n<!--more-->\n\n<p style=\"text-align: center;\">不为谁而作的歌 - 林俊杰\n词：林秋离\n曲：林俊杰\n\n原谅我这一首\n不为谁而作的歌\n感觉上仿佛窗外的夜色\n曾经有那一刻\n回头竟然认不得\n需要从记忆再摸索的人\n和他们关心的 的地方\n和那些走过的请等一等\n梦为努力浇了水\n爱在背后往前推\n当我抬起头儿才发觉\n我是不是忘了谁\n累到整夜不能睡\n夜色哪里都是美\n一定有个人\n她躲过避过闪过瞒过\n她是谁\n她是谁\n原谅我这一首\n不为谁而作的歌\n感觉上仿佛窗外的夜色\n曾经有那一刻回头\n竟然认不得\n需要从记忆再摸索的人\n和他们关心的 的地方\n和那些走过的\n梦为努力浇了水\n爱在背后往前推\n当我抬起头儿才发觉\n我是不是忘了谁\n累到整夜不能睡\n夜色哪里都是美\n一定有个人她\n躲过避过闪过瞒过\n她是谁\n她是谁\n也许在真实面对自己才不顾一切\n去探究当初我害怕面对\n梦为努力浇了水\n爱在背后往前推\n当我抬起头儿才发觉\n我是不是忘了谁\n累到整夜不能睡\n夜色哪里都是美\n一定有个她\n躲过避过闪过瞒过\n她是谁\n她是谁\n她是谁</p>\n\n","tags":["音乐"],"categories":["故事"]},{"title":"俗不可耐的故事","url":"%2F2016%2F11%2F25%2Fstory-2%2F","content":"<blockquote class=\"blockquote-center\">谢谢你，曾来过</blockquote>\n\n![图片加载失败](http://oetmrek6t.bkt.clouddn.com/story_2_title.jpeg)\n\n<!--more-->\n\n## 余凡\n寝室熄灯之后，室友都躺着床上刷手机。就像往常一样在看完一篇故事之后，我会检查一下手机上的各个通讯软件，没准会有遗漏的消息呢。\n\n“ 嗯？这么晚了，她还没睡么？ ”\n我点开了她的QQ窗口，上面显示wifi在线。我在纠结要不要打个招呼。\n\n她叫徐子瑜，是我的大学同学。但是我们不同班，只是高中在同一个学校，她在七班，我在二班，我们互相却从来没有过印象。我们认识是因为大一时候的聚会，大学里比较流行这个，一个省的，一个高中的，一个班的，各种聚会，只不过我们是在高中同学聚会中认识的。我是那次聚会的负责人，因此认识了很多人，她是其中一个，漂亮，安静。\n\n“ 嘿！ ” 我给她打了声招呼。\n“ n(*≧▽≦*)n ” 她每次都会发一个萌萌的表情，她是个可爱的女孩子。\n“ 这么晚了还没睡么 ”\n“ 在补作业呢 ”\n“ 嗯 ” 我突然不知道该跟她聊些什么了。\n\n我第一次找她聊天的时候是我上一段恋情结束一个多月。那一个月我就像是一个忧伤的诗人，整日里发一些感慨的打油诗，期待着前女友会因此而回来。一个月后，想想日子还是要过的，我这么优秀的男生都不要，以后就等着后悔吧。于是，我想要找一个新的妹子。子瑜挺好的，只是我还不喜欢她，但是我会喜欢她的吧。\n\n“ 你还记得大一的时候么，我们刚认识的时候 ”\n“ 啊？ ” 她对我突如其来的问话感到有些惊讶。\n\n大一寒假的时候我们聊天算是最频繁的了，每天互相分享着有趣的事情，每天互相道个早安晚安，那个时候每天好像都挺开心的。我觉得我已经快要忘了前女友，我觉得我快要喜欢上这个可爱的女生。\n\n某天晚上，我从梦里醒来。梦中之前的那个她哭着找她的 “小凡凡”，她一个又一个的问班上的同学，我去哪儿了。我就在她的面前啊，可是她却怎么也看不到我，最后她急的坐在地上哭泣，最后我急的从梦中惊醒。我还是放不下她呵！我缩在被窝里，一张张翻看我和她之前的照片，不知道什么时候睡着了。\n\n第二天中午醒来的时候，发现QQ上新增好几条消息。我和子瑜每天早上七点互道早安，今天却没有回她，她有些担心，连发了好几条消息。我连忙给她回了个早安，顺便补上一句，不好意思睡过头了。她发个可爱的表情，你没事就好啦，都中午了，快起床吧~\n我想了想昨天的梦，苦笑了一下，都过去了吧，我现在有子瑜不是挺好的么。\n\n“ 听到这里你是不是觉得我很讨厌？ ” 我把最初的想法都向子瑜坦白了。\n她没有说话，但是我知道她也没有睡觉。\n\n事情好像进展的都挺顺利，刚上大学的少男少女都按耐不住青春期被家长老师扼杀的情愫，尤其是重点大学的 “乖宝宝们”。开学之后的第一个周末，我决定跟子瑜约会，我叫她周六下午一起去看电影，她同意了。在计划实施的前一天晚上，我在群里向一群老哥们炫耀自己的脱单计划，你们这群老光棍不行啊，前段时间还嘲笑我失恋了，看哥明天再给你们领个对象回来。这个老司机群里瞬间就炸了，大家纷纷向我咨询详细情况。然而在我慷慨激昂的讲述完我的心路历程的时候，群里都沉默了。\n“ 你这样不行啊老铁 ” 终于有人发声了。\n“ 就是就是，你这不喜欢人家就祸害人家小姑娘干啥呢 ”\n“ 你这行为不做好，我不认你这个预言家 ”\n“ 没发现你咋还有这渣男思想呢 ”\n。。。。。。\n结果好像和我预想的不太一样啊，这群老哥们不顶我怎么还怼我呢。然后，我就被各位老哥教育了一通，总之，都说我这个做法是不对的。\n\n晚上躺在床上，我想了很多乱七八糟的事情，最后想到自己现在变成这样，是太不应该了把。不喜欢别人，为什么要跟别人在一起呢？只是为了满足自己的私心？可是最后却是伤害了一位好姑娘呵。\n\n第二天，我爽约了。\n“ 你今天是不是挺忙的啊，我等了你好久的，你下次再这样我就不理你了￣へ￣ ”\n“ 嗯，不好意思啊 ”\n“ 好啦，没事的，晚安啦~ ”\n“ 晚安 ”\n子瑜没有继续追问我爽约的原因，但是她肯定挺难过吧。\n\n“ 你知道么，那天我本来是有课的，但是我逃了那一节课。 ” 子瑜突然插话。\n“ 对不起 ” 现在的我也不知道该说些什么好。\n她没有接话，气氛有些尴尬，但是既然话已经说出了，那就都说完吧。\n\n那次之后，我就开始渐渐的疏远子瑜了，我觉得我不应该去祸害一个好姑娘，不是么。\n刚开始，我和她都有些不适应，但是时间久了，也都习惯了吧。\n当我和她已经很久不联系的时候，我写了一百零六篇日记，十个月里，我想了之前的那个她一百零六次。\n\n在不和子瑜联系后，我发现我想前女友的次数更多了，每次想她的时候我会把自己的思念写在日记里，我们的回忆，我们的点点滴滴，十个月，我写了一百零六篇日记。\n\n可能是我之前爱的不够深，从某一时刻，日记断了，之后再也没有连上。\n我还是把之前的她给放下了。\n\n“ 她真幸福 ” 子瑜发来四个字。\n\n在之后的一段时间里，我感到莫名的轻松，不再有任何感情的负担，也不会再去想某个人。一个人沉迷学习，无法自拔。\n\n那天是照例刷完最后一道物理题，我稍作休息，拿起手机刷了会儿空间。\n“ 好想死，别问我为什么。 ” ————子瑜\n我突然看到子瑜发了这么一条动态。\n“ 你怎么了？ ” 我在聊天窗口翻了好久找到了子瑜的头像。\n“ ( ⊙ o ⊙ )啊！没事啦，就是肚子疼。。。。。。” 子瑜很快回复了消息，有点小惊讶。\n“ 好吧，那我陪你聊聊天吧，分散一下注意力应该会好一点 ”\n“ (⊙v⊙)嗯，好哒~ ”\n我不知道自己怎么鬼使神差的说要陪子瑜聊天，可能只是我不愿意看见她难受吧。\n\n我陪她聊了一下午，后来她说她好多了，要去吃饭。\n“ 谢谢你。 ” ————子瑜\n她更新了自己的动态，我默默地点了个赞，收拾了一下自己的书包也准备去吃饭了。\n\n后来我总是隔三差五的就会找子瑜聊天，因为跟她聊天我的心情会很好啊。\n室友说：如果你的手机里有一个会让你秒回消息的特别关心，那说明你喜欢她。\n我觉得我可能是喜欢上子瑜了。\n\n“ 。 ” 子瑜回复了一个句号。\n\n于是我尝试着去追一下这个女孩。她应该对我有好感吧？我这样想，但是却又不确定，因为之前和她聊天的时候，她会主动找我，而现在，每次聊天都是我发起的。\n“ 明天你有时间么，要不要一起去看电影啊 ” 我鼓起勇气发了这么一句话，因为之前的事情，我怕她会拒绝。\n“ 嗯，我看一下 ” “ 你真幸运~ 刚好我明天没有课 ”\n我没想到她这么轻易的就答应了我。晚上躺在床上，翻来覆去睡不安稳，想着明天应该有哪些活动。\n\n事情没有我想的那么复杂，我们一起去看了一场电影，然后又一起吃饭，最后我送她回宿舍，就是这么简单，别的什么都没有发生。\n那天她穿着白色的裙子，真好看，我看的有些发呆，还被她嗤笑了一番。\n\n我以为剩下的事情会水到渠成，只需要我们多约会几次。\n\n可是，在我连续两次约她出去都失败时，我觉得可能是我自我感觉太良好了吧。而且那段时间她和我聊天时也有了变化，总是心不在焉的，这让我更加失望。也许她对所有人都挺好呢，也许她和其他人聊天也会发可爱的表情呢，也许有那么一个人她会主动找他聊天呢。\n只是因为我对她好，所以她才会答应上次跟我出去的吧。\n\n“ 不是这样的。 ” 子瑜发来一句。\n“ 嗯哼？ ”\n“ 你不知道我的想法啊 ”\n我沉默没有说话，她也沉默。\n\n“ 其实，从一开始我就喜欢你的啊！” 我不知道子瑜现在的心情是怎样的，我把想说的都说出来，她应该也很苦恼吧。\n“ 我以前没有谈过恋爱，也不知道怎样才算是喜欢一个人，但是从大一的时候，每天和你聊天都会很开心，手机有消息时就会连忙查看是不是你发的，有时候上课也会发呆，室友告诉我说，这就是恋爱的前兆，我才知道，原来这就是喜欢一个人啊 ”\n“ 我本来以为就像故事里常有的，自己会在大学里谈一场美好的恋爱。你那时每天会发很多关于你前女友的动态，室友说你这样的男生不好，要么是花心，要么是不喜欢，只是为了找对象而找对象。可是我不信，我给她们说我们每天互相道早安晚安的事情，我给她们说你关心我的事情，她们却说我执迷不悟。”\n“ 直到后来，你那天的失约，以及后来慢慢疏远我，我不知道为什么，只是很难过，可是却没有勇气问你原因。好在时间会冲淡很多，时间久了，我也就习惯啦。 ”\n“ 我以为自己和你不会再有什么过多的交集，只是普通朋友就好啦。没想到你后来又突然找我聊天了，那天肚子特别疼，自己一个人在寝室，有一瞬间感觉好像自己被世界给抛弃了。那天下午，真的谢谢你。”\n“ 后来你找我聊天又有些频繁了，我不知道该怎么形容当时自己的心情，反正挺复杂吧，自己可能还是喜欢你的，可是我怕再像之前那样，你或许并不喜欢我。所以我告诉自己不要再主动找你聊天，只是和你聊天的时候还是会很开心。”\n“ 日子不紧不慢的过着，我对那时很满足，不管你喜不喜欢我，但是能找我聊天就很开心的。后来你突然说要约我去看电影，我一开始很担心，我担心又是像大一时候一样，可是我却反复告诉自己你不是那样的人，所以我答应了你。 ”\n“ 很开心那天和你一起，那是我第一次和男生单独出去看电影。”\n“ 只是，那段时间，有另一个男生追我。他对我也很好，可是我却不喜欢他，但是我也不知道该怎么拒绝他，所以那段时间很烦，不愿意出去，基本没事就待在寝室了。因此拒绝了你后来两次约我出去，我当时感觉一点都搞不清楚自己真正的想法，脑子很乱。”\n\n“ 嗯 ” 子瑜突然给我说了这么多，我也有些懵了。\n\n“ 我们已经大三了，还记得上一次跟你出去的时候，你说你明年会直接出去工作，可是我要考研啊。所以我觉得即使我们在一起也早已晚了吧，明年还是要分道扬镳的。而且之后你突然又开始渐渐地远离我，我感觉的到，我觉得自己不应该再去想这些乱七八糟的呵。也许命中注定我们就不能在一起的吧。”\n\n子瑜的话让我突然觉得想笑，不是嘲笑，而是苦笑，这样俗不可耐的小说剧情就发生在了我的身上么。是不是两个人互相误解最终越走越远终究不能在一起呢？\n但这一次我想把握住机会，既然话已经挑明，她还是喜欢我的吧，那相互喜欢的两个人为什么不能在一起呢。\n就像之前一样，不管老师怎么说，不管同学怎么看，我喜欢她，她喜欢我，我们就在一起，即使没有走到最后，至少那段时光是快乐的，不是么。\n\n“ 好吧，那现在呢？我想告诉你，子瑜，我喜欢你，你会答应我么。 ” 我觉得现在表白，她应该不会再拒绝我了吧。\n“ 对不起 ” 她回了短短的三个字让我感觉仿佛瞬间堕入万丈冰渊。\n“ 为什么啊！你喜欢我，我也喜欢你，为什么我们不能在一起啊？ ” 我的手有些抖，打出这些话，还没发出去，又有新消息提示了。\n“ 不过呢，我也没说就拒绝你啦~ ” 她又恢复了俏皮的样子。\n“ 我之前不是说了么，马上我要准备考研了，每天又没有时间唉，怎么答应你啊。要不这样好了，我想要去厦大，我很喜欢那个城市，如果明年我们能在厦门相遇，我就答应做你女朋友怎么样n(*≧▽≦*)n ”\n\n“ 怎么了啦，你是不是不愿意啊 ”\n“ 你再不回我我要生气了啊 ”\n“ 我是真的没有办法，我不太能接受异地恋的，所以如果你接受不了我的条件，那我们也不能够在一起的。 ”\n\n“ 好，我答应你。 ” 过了许久，我才打出这几个字。\n“ 已经很晚了，作业明天再写吧，早点休息，晚安。 ”\n“ 晚安~ ”\n\n我盯着屏幕没有动，看着她的状态由wifi变成了离线。我想她现在应该挺开心的吧，可是她却不知道屏幕外的我满脸悲伤。\n\n我告诉过她我明年会直接出去工作，可是那是半年前呵，暑假回家之后，父母知道了我这个决定却勃然大怒。他们告诉我，如果我不继续读研的话以后就别进这个家门。我不知道他们为什么发这么大的火，也许因为我是家族里唯一一个考上好大学的人吧，所以他们想让我走的更远，就像他们常给我说的，现在这社会大学生一抓一大把，你不读研以后有什么用。\n我一向是一个不愿意让父母失望的孩子，所以我妥协了，明年我会出国，已经联系好了一所不错的大学，直博。\n\n所以当子瑜告诉我在一起的条件时，我却没敢告诉她真相。我不敢告诉她，让她等我回来，我觉得自己不是一个能够坚持几年异地的人，也许等我回来的时候，早已物是人非。\n我觉得这是上天给我开的一个玩笑，或许只是我今晚不该找子瑜聊天，或许大一的时候我就不该去聊一个不喜欢的人吧。\n\n我最后点进了子瑜的空间，给她留了一条言：三生有幸遇见你。\n\n## 徐子瑜\n寝室已经熄灯了，可是明天要交的报告还没有写完，还只能借着手电的光来与作业作斗争。哎，早知道下午就不该跟室友出去浪了。\n\n“ 叮咚—— ” 手机突然在这个时候想起来。\n“ 嘿！ ” 嗯哼？！好久没联系的他怎么会突然找我聊天呢？\n“ n(≧▽≦)n ” 我照惯例给他发一个可爱的表情。\n“ 这么晚了还没有睡么 ”\n“ 在补作业呢 ”\n“ 嗯 ” 他好像不知道该说些什么了。\n\n他叫余凡，是我的大学同学。我们不同学院，相识也只是因为高中在同一个学校，他说他当时在二班，我在七班，可是我们却没有见过面。刚到大学的时候，因为比较流行各种聚会，我们就是在同一个高中的同学聚会时认识的。他是那次聚会的负责人，负责安排好几十号人，看起来很厉害，而且他长得挺帅的。嗯，我必须得承认我有些颜控。\n\n“ 你还记得大一的时候么，我们刚认识的时候 ”\n“ 啊？” 他怎么突然说这么一句话，不会要讲故事了吧。\n\n自从第一次聚会之后，我们就相识了，偶尔我们会聊聊天。不出意外的，我发现他有女朋友，他空间里有他们的合影，他的女朋友真漂亮，眼睛很大，很好看，从他的动态也可以看出来，他很爱她。虽然我对他有点好感，但是我应该不会喜欢一个有女朋友的男生吧。\n可是，没过多久，他和她分手了。那一个月，他每天会发为她写的诗，诗的内容看出来他很悲伤，悲伤的让人心疼，我不知道如何去安慰他，也没有理由去安慰他，只能对他的动态默默点个赞。\n\n让我感到又喜又惊的是，他越来越多的找我聊天。\n\n大一寒假的时候，我和他几乎每天都会聊天，他很爱睡懒觉，可是会每天早上定个闹钟起来给我说早安然后继续睡下，晚上的时候我也会等着他的晚安入睡。我们在那段时间互相了解了很多，我给他看我小时候的日记，他给我讲他小时候的故事，我告诉他我喜欢看书，尤其是古诗词，他告诉我他喜欢玩游戏，特别是射击类。。。。。。\n那个寒假我每天都过得很开心，因为有他的陪伴。当然，中间也有一点小插曲啦。\n那天早上我起床后发现QQ上却没有任何消息，我以为他可能是睡过了，可是他的状态显示他在线，没准他今天忘了呢，我这样想到。于是我给他道了声早安。可是过了很久他都没有回应，后来我又连续发了好几条消息，都没有回应。我突然有点慌，不知道他出了什么事情，如果他有什么事情，他应该会告诉我的啊。一上午，看了半天书却根本没有看下去什么，直到中午的时候他发来消息说他睡过了。我送给了口气，只要他没事就好啦。\n我不知道自己怎么会因为他的事情魂牵梦绕，虽然我们只能通过QQ聊天，可是他的每一句话却都能拨动我的心弦，我觉得这应该就是喜欢一个人的感觉吧。以前总被父母老师告诉要好好学习，千万不能早恋，所以有时看着身边的同学成双入对的打闹嬉戏，自己只能在题海里一遍又一遍的钻研，直到心里那青春期的萌动被题海淹没。到了大学，自己终于可以光明正大的谈恋爱了，我喜欢他，可是我却不知道他对我是什么感觉。\n\n“ 听到这里你是不是觉得我很讨厌？ ” 余凡果然给我说了一大堆，都是关于我们之间故事。只是我没想到的是，他接近我并不是因为喜欢我。\n我有些难受，现在已经完全没有心思继续写我的报告了。\n\n他继续讲，说出了那天我们约好看电影他却爽约的原因。\n\n我一直以为他是喜欢我的。所以，当他约我出去的时候，我毫不犹豫的答应了，即使第二天我有一节课。\n我有些兴奋，甚至有些小激动，我想了很多小说里的约会情节，期待着我和他的见面应该会符合哪一种。\n可是，他却没有出现。我从下午两点等到六点，余凡都没有来，中途我给他打过电话，却也没有人接。我觉得我不应该有任何不好的想法，也许只是他今天临时有事，可是我的心里却有点慌。\n晚上我很早就躺在了床上，可是却没有任何睡意，因为直到现在，他都还没有上线。\n“ 你今天是不是很忙啊，我等了你好久的，你下次再这样我就不理你了￣へ￣  ” 我试着给他发了一条消息。\n“ 嗯，不好意思啊 ” 他很快的回复了我，他的状态还是离线。\n我不知道为什么他要隐身，也没有去问他爽约的原因，只是心里很难过，可是我不应该表现出来不是么？\n“ 好啦，没事的，晚安啦~ ” 我假装没有什么事情，给他道了晚安。\n“ 晚安 ”\n\n“ 你知道么，那天我本来是有课的，但是我逃了那一节课。” 我不知道该怎么表达现在的心情，我想过很多原因，可是就是没有想过他是因为不喜欢我所以才失约的。\n“ 对不起 ” 如果说女生最不想听到男生说的话，应该莫过于这三个字吧。\n\n余凡开始给我讲他和她的故事。从他们最初的相遇，他讨厌她，到最后经历一些挫折，他慢慢喜欢她，最后他们在一起。这是一段很长的故事，很曲折，也很美好，因为有情人终成眷属了啊。\n他们在一起的时候，她爱他，爱到为之疯狂；他们在一起的时候，他宠她，宠到世界融化。\n可是爱情有时来的太快，散的也太快，他们很快就分手了，因为异地的缘故。\n听到这里我有些怅然，再甜蜜美好的爱情都无法跨过天涯相隔的槛么。\n\n余凡告诉我在后来疏远我的那段时间里，他会经常做梦，梦中都是她的影子，每次想她的时候，他都会把自己的思念写到日记里。十个月，他写了一百零六篇日记。\n\n“ 她真幸福 ” 我有些羡慕他和她的甜蜜爱情，也有些嫉妒她，曾拥有这样的他。\n\n在余凡渐渐疏远的日子里，我有些不知所措，不知道应该怎么去处理自己对他的情感。只是希望如室友所说，时间会冲淡一切。我以为我们就会至此而已，以后不会再见面，也不会再有过多交谈。曾经向往的恋爱夭折在了襁褓之中，原来爱情并不都像小说里面那样美好，原来大学里也不是随便就可以找到自己的爱情。\n\n我没想到的是他又突然找我说话了，距离我们上一次说话五个月十二天。\n\n“ 你怎么了？ ” 他突然问我这么一句话，看到熟悉的名字我有些吃惊。\n“ ( ⊙ o ⊙ )啊！没事啦，就是肚子疼。。。。。。” 我想他肯定是看到了我发的动态，因为大姨妈的缘故，不知道为什么今天疼的要命。\n“ 好吧，那我陪你聊聊天吧，分散一下注意力应该会好一点 ” 我不知道他为什么突然找我说话，也不知道他为什么这样做，也许只是朋友间的关心吧。\n“ (⊙v⊙)嗯，好哒~ ”\n\n余凡陪我聊了一下午，不知是心里作祟还是怎样，和他聊天的时候确实没有感到那么疼，可能分散注意力确是一个不错的办法吧。虽然我觉得自己已经不再去想与恋爱有关的事情，不过在自己最难受无助的时候有一个人能够站出来还是很开心的，所以我发了一个动态：\n“ 谢谢你。 ”\n我知道他会看，几乎我的每一条动态他都会点赞。\n\n后来他总会隔三差五的找我聊天，虽然不似关系最近时候的一天一说，但也比之前长久不理好了一些。只是我不太明白他的意图，所以不会去主动找他聊天啦，或许他只是跟之前一样，无聊了想找人聊天的吧。\n即使自己尽力的去克制，可是和他聊天的时候还是不自觉的就觉得很开心，我觉得自己越来越危险了，那快被时间消磨殆尽的情感又渐渐萌出了芽。\n我把这些告诉室友，室友告诉我，stay away！不要再上当了。可是我却不相信他是这样的人，我给室友讲他的好，为他辩解。不知不觉我发现，问室友只是为了让自己更加的相信他吧。\n\n“ 明天你有时间么，要不要一起去看电影啊  ” 余凡又一次约我出去。\n我的心里当然是愿意的啊，可是想起上一次，自己心里又有些打退堂鼓。那就听天由命吧，看看课表，如果有课，那就不去，这一次不会再翘课了。我最终这样做了决定。\n明天正巧没有课。我不知道是他幸运还是我幸运，我答应了他。\n已经很久没有见面了，明天该穿什么衣服好呢。女生的那点小心思，我也避免不了。\n\n第二天见到他的时候，在阳光下白衬衣和他好像融在了一起，他静静地站在那里，看着我笑，露出一口洁白的牙齿。是不是女生对穿白衬衣男生的好感度都会飙升？\n“ 怎么了，不认识了么 ” 我对他开了个玩笑。\n“ 没有，只是你今天太好看了 ” 他吐了吐舌头。\n\n我们如约一起看了场电影，出来的时候刚好是晚饭时间，就一起又吃了个饭。\n吃完饭已经八点了，从下午两点到八点，我不知道我们怎么花了这么久的时间。他说送我回寝室，我嘴上说不用了，可是心里的想法却一点都不一样。\n\n第一次约会，虽然平平淡淡，却也很美好。\n\n可是我记得那天我问余凡他明年的计划，他告诉我他想要直接找工作。我以为如果他能够陪我一起考研，然后一起去一个学校，或许我们还能在一起吧。现在我们都已经大三了呵，马上就要忙各自的事情了，即使在一起，也总会分离的吧。\n想到这些，我又有些难过，却不敢将内心真正的想法说出来。\n\n“ 可是，后来我连续两次约你出去都失败时，我就觉得可能是自己自我感觉太良好了吧。而且那段时间你和我聊天时也有了变化，总是心不在焉的，这让我更加失望。我就想也许是你对所有人都挺好呢，也许你和其他人聊天也会发可爱的表情呢，也许有那么一个人你会主动找他聊天呢。可能只是因为我对你好，所以你才会答应上次跟我出去的吧。” 余凡给我说了他的想法，也是他后来又疏远我的原因。\n“ 不是这样的。” 我不知道余凡竟然会这样想。\n\n我把自己的所有想法都告诉了余凡。\n\n原来我们一直相互喜欢着对方，却又相互误会，不愿意将心里的话说出来，而是以沉默来互相伤害，互相难过。\n\n“ 好吧，那现在呢？我想告诉你，子瑜，我喜欢你，你会答应我么。” 在我说完一切之后，余凡问我。\n\n我犹豫了一下，但是理智最后还是战胜了情感。\n“ 对不起 ”\n“ 为什么啊！你喜欢我，我也喜欢你，为什么我们不能在一起啊？”\n“ 不过呢，我也没说就拒绝你啦~ ”\n“ 我之前不是说了么，马上我要准备考研了，每天又没有时间唉，怎么答应你啊。要不这样好了，我想要去厦大，我很喜欢那个城市，如果明年我们能在厦门相遇，我就答应做你女朋友怎么样n(≧▽≦)n ”\n我告诉余凡，我会考研去厦大，如果他能够去厦门工作，我就答应他。\n\n余凡没有立即回复我。\n\n“ 怎么了啦，你是不是不愿意啊 ”\n“ 你再不回我我要生气了啊 ”\n“ 我是真的没有办法，我不太能接受异地恋的，所以如果你接受不了我的条件，那我们也不能够在一起的。 ”\n我不知道为什么余凡不太愿意接受这个条件，可是如果相恋的两个人不能在一起，有多少能够走到最后呢。\n\n“ 好，我答应你。 ”\n“ 已经很晚了，作业明天再写吧，早点休息，晚安 ”\n“ 晚安~ ”\n余凡终于是答应了我，看来是我多想了呢刚才。\n\n我松了口气，只是感觉这一切来的有点突然。突然余凡就找我聊天，然后就讲了很多事情，然后发现原来我们一直误会着对方，原来我们一直喜欢着对方，虽然这段爱情来得有点晚，可是最终是赶上了不是么？\n我捏了捏自己的脸，还蛮真实的，这么离谱的事情竟然不是在做梦唉。\n我退了QQ，收拾了一下作业，说了那么多话，作业都没写完。\n\n“ 叮咚—— ” 我刚躺下，手机又响了。\n\n余凡给我留了一条留言：三生有幸遇见你。\n我皱了皱眉头，我记得，他曾经给我推荐过一篇故事，故事的最后是两句话：三生有幸遇见你，纵使悲凉也是情。我不知道余凡是不是想要说这句话，或许是他有什么事情没有告诉我么？\n\n“ 呵—— ” 我打了一个长长的哈欠，有些困了。\n算了啦，别想那么多了，也许他就是想简单的告诉我前半句话呢。我告诉自己，又定了一个闹铃，然后睡下了。\n\n\n\n\n\n\n\n","tags":["故事"],"categories":["故事"]},{"title":"清风徐来，水波不兴","url":"%2F2016%2F11%2F13%2Fscene-1%2F","content":"<blockquote class=\"blockquote-center\">清风徐来，水波不兴。良辰美景，依偎佳人。</blockquote>\n\n![图片加载失败](http://oetmrek6t.bkt.clouddn.com/story_1_title.jpg)\n\n<!--more-->\n\n厦门世茂海峡大厦。\n![图片加载失败](http://oetmrek6t.bkt.clouddn.com/story_1_1.png)\n\n厦大新校区周围的景色，非常喜欢它这样的房子。\n![图片加载失败](http://oetmrek6t.bkt.clouddn.com/story_1_2.jpg)\n\n![图片加载失败](http://oetmrek6t.bkt.clouddn.com/story_1_6.jpg)\n\n![图片加载失败](http://oetmrek6t.bkt.clouddn.com/story_1_11.jpg)\n\n快要日落的时候拍的，这两天的天气很凉爽，非常舒适。\n![图片加载失败](http://oetmrek6t.bkt.clouddn.com/story_1_12.JPG)\n\n我在南方的艳阳里四季如春，你在北方的寒风中大雪纷飞。\n![图片加载失败](http://oetmrek6t.bkt.clouddn.com/story_1_3.JPG)\n\n同伴说这是椰子树，我问他，为什么树上没有长椰子。\n![图片加载失败](http://oetmrek6t.bkt.clouddn.com/story_1_5.JPG)\n\n这个是榕树吧，这一片树林会不会都是这一棵树。\n![图片加载失败](http://oetmrek6t.bkt.clouddn.com/story_1_7.jpg)\n\n晚上我们骑车沿海边转了一圈。\n![图片加载失败](http://oetmrek6t.bkt.clouddn.com/story_1_8.JPG)\n\n![图片加载失败](http://oetmrek6t.bkt.clouddn.com/story_1_9.JPG)\n\n![图片加载失败](http://oetmrek6t.bkt.clouddn.com/story_1_14.JPG)\n\n已经很晚了，但是还有不少人在露营和烧烤。\n![图片加载失败](http://oetmrek6t.bkt.clouddn.com/story_1_10.JPG)\n\n背着吉他，带她去流浪。\n![图片加载失败](http://oetmrek6t.bkt.clouddn.com/story_1_13.JPG)\n\n嗯，我一直觉得这个很像“大菠萝”。\n![图片加载失败](http://oetmrek6t.bkt.clouddn.com/story_1_15.JPG)\n\n夜晚的海面总是黑黢黢的，只有远远的桥上闪着灯光。\n![图片加载失败](http://oetmrek6t.bkt.clouddn.com/story_1_16.JPG)\n\n![图片加载失败](http://oetmrek6t.bkt.clouddn.com/story_1_17.JPG)\n\n\n","tags":["游记"],"categories":["故事"]},{"title":"起源","url":"%2F2016%2F11%2F11%2Fstory-1%2F","content":"<blockquote class=\"blockquote-center\">我喜欢听故事，可是我没有酒。</blockquote>\n\n![图片加载失败](http://oetmrek6t.bkt.clouddn.com/story_0_title.jpg)\n\n<!--more-->\n\n只是一个简单的想法，希望能够记录一些什么。\n\n我不太喜欢做一个没有人文气息的工科生，所以想要在茫茫代码之外寻求一点文学的气息。\n\n可能只是俗套的爱情剧，可能只是简单的告白语，也可能只是无厘头的牢骚，但是比起冰冷的代码，至少也是有些感情的吧。\n\n我不是一个好的写手，只想写下一些心中的故事与想说的话。\n\n这些故事也许是发生在我身边的，也许是发生在你身边的。\n\n这就是 “故事” 这个栏目的起源，有着美好的初衷，也希望能够善始善终。","tags":["故事"],"categories":["故事"]},{"title":"你或许不知道的CSS性能提高","url":"%2F2016%2F11%2F02%2Farticle-24%2F","content":"在最近给自己的博客换了个CSS3动画背景之后，发现打开博客会导致CPU占用暴增，而且还会有卡顿现象，于是乎去查了一下CSS动画的相关优化，发现了不少好文，以前从来没有想过CSS还能够进行优化，一下子就涨知识了。\n\n<!--more-->\n\n我找到了几个写的比较好点的前辈们的文章，链接如下：\n[前端性能优化](https://segmentfault.com/a/1190000000490328)\n[CSS动画之性能优化](http://www.w3cplus.com/css3/introduction-to-hardware-acceleration-css-animations.html)\n[高性能CSS3动画](https://www.qianduan.net/high-performance-css3-animations/)\n[使用will-change来提高页面性能](http://www.zhangxinxu.com/wordpress/2015/11/css3-will-change-improve-paint/)\n\n下面我就总结一下CSS性能提高的一些原理和方法。\n\n# 是什么影响了CSS性能\n## 图层\n当浏览器在渲染一个页面时，会先将页面分为很多个图层，每个图层上有一个或多个DOM节点，然后再去渲染具体的每个DOM节点。\n\n在渲染DOM的时候，浏览器所做的工作实际上是：\n\n* 获取DOM后分割为多个图层\n* 对每个图层的节点计算样式结果（Recalculate style--样式重计算）\n* 为每个节点生成图形和位置（Layout--回流和重布局）\n* 将每个节点绘制填充到图层位图中（Paint Setup和Paint--重绘）\n* 图层作为纹理上传至GPU\n* 符合多个图层到页面上生成最终屏幕图像（Composite Layers--图层重组）\n\n而在Chrome中，满足以下任意情况就会创建图层：\n\n* 3D或透视变换（perspective transform）CSS属性\n* 使用加速视频解码的`<video>`节点\n* 拥有3D（WebGL）上下文或加速的2D上下文的`<canvas>`节点\n* 混合插件（如Flash）\n* 对自己的opacity做CSS动画或使用一个动画webkit变换的元素\n* 拥有加速CSS过滤器的元素\n* 元素有一个包含复合层的后代节点（一个元素拥有一个子元素，该子元素在自己的层里）\n* 元素有一个z-index较低且包含一个复合层的兄弟元素（换句话说就是该元素在复合层上面渲染）\n\n需要注意的是，如果图层中某个元素需要重绘，那么整个图层都需要重绘。因此当图层较大的时候，只刷新图层中的某个元素而刷新整个图层自然会多花费一些时间。\n\n## 重布局\n有些节点，当你改变它时，会需要重新布局（这也意味着需要重新计算其他被影响的节点的位置和大小）。这种情况下，被影响的DOM树越大（可见节点），重绘所需要的时间就会越长，而渲染一帧动画的时间也相应变长。\n\n盒子模型相关属性会触发重布局：\n\n* width\n* height\n* padding\n* margin\n* display\n* border-width\n* border\n* min-height\n\n定位属性及浮动也会触发重布局：\n\n* top\n* bottom\n* left\n* right\n* position\n* float\n* clear\n\n改变节点内部文字结构也会触发重布局：\n\n* text-align\n* overflow-y\n* font-weight\n* overflow\n* font-family\n* line-height\n* vertival-align\n* white-space\n* font-size\n\n这么多常用属性都会触发重布局，可以看到，他们的特点就是可能修改整个节点的大小或位置，所以会触发重布局。\n\n## 重绘\n前面已经说了，重绘就是将每个节点重新绘制到它的所在图层之中。\n\n修改时只触发重绘的属性有：\n\n* color\n* border-style\n* border-radius\n* visibility\n* text-decoration\n* background\n* background-image\n* background-position\n* background-repeat\n* background-size\n* outline-color\n* outline\n* outline-style\n* outline-width\n* box-shadow\n\n这样可以看到，这些属性都不会修改节点的大小和位置，自然不会触发重布局，但是节点内部的渲染效果进行了改变，所以只需要重绘就可以了。\n\n## GPU加速\n虽然只是运行在浏览器中的动画，但是依然可以调用硬件GPU来提高动画渲染和绘制的性能。\n\n浏览器接收到页面文档后，会将文档中的标记语言解析为DOM树。DOM树和CSS结合后形成浏览器构建页面的渲染树。渲染树中包含了大量的渲染元素，每一个渲染元素会被分到一个图层中，每个图层又会被加载到GPU形成渲染纹理。\n\n需要注意的是：\n\n* 如果GPU加载了大量的纹理，那么很容易就会发生内容问题，这一点在移动端浏览器上尤为明显，所以，一定要牢记不要让页面的每个元素都使用硬件加速。\n\n* 使用GPU渲染会影响字体的抗锯齿效果。这是因为GPU和CPU具有不同的渲染机制。即使最终硬件加速停止了，文本还是会在动画期间显示得很模糊。\n\n# 对症下药——对CSS进行性能提升\n## 减少重布局和重绘\n为了减少重布局和重绘，只需要针对相应的属性做出变化即可。\n所以一般来说，CSS动画中为了提高性能和效率，尽量使用如下四个方面的属性：\n\n* 改变位置\n* 改变大小\n* 旋转\n* 改变透明度\n\n同时应该避免让元素处于文档流之中，这样可以减少重布局的时间；采用扁平化设计风格，少用box-shadow、gradients等属性以减少重绘的时间等。\n\n需要注意的是，上面那些触发重绘的属性里面没有opacity（透明度），很奇怪不是吗？实际上透明度的改变后，GPU在绘画时只是简单的降低之前已经画好的纹理的alpha值来达到效果，并不需要整体的重绘。不过这个前提是这个被修改opacity本身必须是一个图层，如果图层下还有其他节点，GPU也会将他们透明化。\n\n## 开启硬件的GPU加速\n前面我们说了是否使用GPU来渲染图层会影响CSS动画的性能，那么我们如何开启GPU加速呢？\n\n方法比较简单，使用transform属性中的translate来强制开启GPU加速：\n\n```css\ndiv {\n\ttransform: translateZ(0);\t//这两种方法都可以，选一个即可\n\ttransform: translate3d(0,0,0);\n}\n```\n\n## 还有什么方法？\n使用比较新的元素属性will-change。\n顾名思义，will-change属性就是为了告诉浏览器接下来我想要浏览器做什么事情，这样浏览器就可以提前准备好，从而提高CSS的性能。\n\nwill-change虽然可以加速，但是，一定一定要适度使用。那种全局都开启will-change等待模式的做法，无疑是死路一条。尼玛，用脚趾头想想也知道，你让浏览器各个元素都随时GPU渲染加速待命，还是妥妥搞死！\n","tags":["前端优化"],"categories":["前端"]},{"title":"CSS使文字一行显示，超出显示省略号","url":"%2F2016%2F11%2F02%2Farticle-23%2F","content":"经常用到的功能，就只有小小的几个属性，但是老是记不住。\n\n当文字较多时，让这些文字都在一行显示，并且超出容器之后显示省略号。\n\n<!--more-->\n\n```css\ndiv {\n\twidth: 100px;\t//容器限制一定的宽度\n\twhite-space: nowrap;\t//让文字不换行显示\n\toverflow: hidden;\t//容器超出部分不显示\n\ttext-overflow: ellipsis;\t//文本超出部分显示省略号\n}\n```\n","tags":["CSS"],"categories":["前端"]},{"title":"MAC出现“无法使用此Apple ID进行更新”的解决办法","url":"%2F2016%2F10%2F20%2Farticle-22%2F","content":"今天在使用AppStore进行更新的时候报错了如下错误：\n\n![AppleID无法使用](http://oetmrek6t.bkt.clouddn.com/article_22_1.png)\n\n<!--more-->\n\n点击一下之后出现\n\n![AppleID无法使用](http://oetmrek6t.bkt.clouddn.com/article_22_2.png)\n\n## 解决办法\n如果你仔细观察之后会发现，不能更新的是Xcode，终于找到原因了，因为我的Xcode是从别人那里拷来的，而不是自己从AppStore下载的，所以会报错。只需要重新从AppStore下载Xcode就可以更新了，不过我觉得这个方法还是挺蛋疼的，但是没有找到其他的办法。\n\n虽然不知道你们的问题是不是由于Xcode造成的，但是我估计也是因为软件是从别人那里拷的缘故，大家也可以试试该方法。","tags":["mac"],"categories":["mac"]},{"title":"NodeJS报错socket hang up的解决办法","url":"%2F2016%2F10%2F14%2Farticle-21%2F","content":"之前在使用NodeJS模拟HTTP请求向JAVA的Socket转发的时候报了如下错误：\n\n```js\nevents.js:48\n    throw arguments[1]; // Unhandled 'error' event\n        ^\nError: socket hang up\n    at createHangUpError (http.js:1091:15)\n    at Socket.onend (http.js:1154:27)\n    at TCP.onread (net.js:363:26)\n```\n\n<!--more-->\n\n找了半天没有找到错误的解决办法，后来终于在stackoverflow中找到了这个问题的解决答案——[How to debug a socket hang up error in NodeJS?](http://stackoverflow.com/questions/10814481/how-to-debug-a-socket-hang-up-error-in-nodejs/11542134#11542134)。\n\n原来是因为HTTP请求与Socket的不能正常连接，链接请求和接受必须是同类型的才可以。即HTTP的请求只能以HTTP的方式来接受，Socket的请求只能和Socket的端口来建立连接。所以，我把我的HTTP请求换成了Socket之后就解决了上述的错误。\n","tags":["Socket"],"categories":["NodeJS"]},{"title":"使用CSS设置元素背景固定","url":"%2F2016%2F10%2F14%2Farticle-20%2F","content":"有时我们需要一个元素的背景成为固定的，比如让body的背景固定等,我们这里提供两种解决办法。\n\n<!--more-->\n\n我们通常的解决办法是给元素添加一个背景，同时设置该元素为固定定位：\n\n```css\ndiv {\n\tposition: fixed;\n\tbackground: url(images/bg.jpg);\n}\n```\n\n除此之外，我们还可以有其他的解决办法，就是利用一个background-attachment属性:\n\n```css\ndiv {\n\tbackground: url(images/bg.jpg);\n\tbackground-attachment: fixed;\t/*页面滚动时，背景固定。*/\n\t/*  background-attachment: scroll;   页面滚动时，背景滚动。  */\n}\n```\n","tags":["CSS"],"categories":["前端"]},{"title":"NodeJS报错[Error:listen EADDRINUSE]","url":"%2F2016%2F10%2F11%2Farticle-19%2F","content":"NodeJS服务器运行的时候报出错误：\n\n\tError:listen EADDRINUSE xxxxxxx\n\n原因：\n\n\t服务器的端口被占用\n\n<!--more-->\n\n解决办法：\n\n\t杀死其他占用端口的进程。\n\n一般都由于前一次node服务器进程没有杀死造成，可以使用 \n\n\tkillall -9 node \n\n命令来杀死所有node进程。\n\n也可以先查看自己的端口占用情况再根据端口占用进程的PID来杀死进程。\n\n\tnetstat -anp | grep 8080 \t//linux  查看8080端口的进程使用情况\n\n如果后面的PID显示的 - 的话说明没有权限，需要在命令之前加上 sudo 来提升权限。\n\n之后可以使用下面命令直接杀死相应的进程即可：\n\n\tkillall -9 PID\n\n","tags":["linux"],"categories":["NodeJS"]},{"title":"Git实用入门教程","url":"%2F2016%2F10%2F10%2Farticle-18%2F","content":"<blockquote class=\"blockquote-center\">“任何新技术的使用都是由需求所决定！”</blockquote>\n\n以不同实例场景来讲解Git的使用，通俗易懂，不是简单的文档式教程。\n\n<!--more-->\n\n## 场景一——第一次使用git\n现在我们需要使用github来建立一个自己的代码仓库，方便存储和管理自己的代码。\n\n### 命令行操作\n\n1、新建一个文件夹，作为本地存放代码的git仓库。\n\n\tmkdir my_repository   //linux 新建文件夹\n\n2、在新建的文件夹下面进行git初始化操作。\n\n\tcd my_repository\t//打开新建的文件夹\n\n\tgit init\t// 进行git初始化将该文件夹变成git仓库\n\t\n   新建完成之后在该文件夹下回多一个.git文件夹\n\n3、在本地的git仓库中添加文件。\n\t\n\ttouch test.txt    //linux 新建文件\n\n\tvi text.txt    //linux 编辑文件 添加内容\n\n4、到github自己的目录去创建一个git仓库。\n\n![创建自己仓库](http://oetmrek6t.bkt.clouddn.com/article_18_1.png)\n\n![创建自己仓库](http://oetmrek6t.bkt.clouddn.com/article_18_2.png)\n\n![创建自己仓库](http://oetmrek6t.bkt.clouddn.com/article_18_3.png)\n\n5、复制github上面的仓库链接并将其与本地仓库连接。\n\n![创建自己仓库](http://oetmrek6t.bkt.clouddn.com/article_18_4.png)\n\n\tgit remote add origin https://github.com/helianthuswhite/my_repository.git\n\t//将远程仓库与本地仓库连接\n\n6、将本地代码和修改提交commit。\n\n\tgit add -A\t//-A是提交本地所有修改的意思，可以指定\n\n\tgit commit -m'这是第一次提交'\t//这里填写提交时的信息\n\n   这里第6步和第5步的顺序可以对调。\n\n7、将刚才的commit push 到远程仓库。\n\n\tgit push origin master\t//master是提交到远程仓库的master分支\n\n![创建自己仓库](http://oetmrek6t.bkt.clouddn.com/article_18_5.png)\n\n到这里，我们已经把自己的代码提交到远程的github仓库了。之后在本地修改代码完成后，只需要重复上面的第6步和第7步就可以完成仓库的更新了。\n\n### 客户端操作\n\n1、使用客户端新建一个本地git仓库。\n\n![创建自己仓库](http://oetmrek6t.bkt.clouddn.com/article_18_6.png)\n\n![创建自己仓库](http://oetmrek6t.bkt.clouddn.com/article_18_7.png)\n\n2、在刚才新建好的本地仓库里面添加自己的文件，这时可以在客户端中看到自己添加的文件及其内容。\n\n![创建自己仓库](http://oetmrek6t.bkt.clouddn.com/article_18_8.png)\n\n3、在下面输入commit的信息内容，然后点击按钮即可完成commit。\n\n![创建自己仓库](http://oetmrek6t.bkt.clouddn.com/article_18_9.png)\n\n4、完成commit之后在history里面可以看到自己的commit，但是此时代码还是在本地，需要点击右上角的publish把本地仓库提交到github上面。\n\n![创建自己仓库](http://oetmrek6t.bkt.clouddn.com/article_18_10.png)\n\n在提交时会填写一些信息，这是github上面仓库的信息。客户端在上传时会自动创建远程仓库。\n\n![创建自己仓库](http://oetmrek6t.bkt.clouddn.com/article_18_11.png)\n\n最后在远程仓库就可以看到自己上传的内容了。\n\n从上面我们可以看出，客户端在新手使用的时候确实是十分方便的。因为它操作比较简单，并且能够随时看到自己是否完成commit，以及代码变化的内容（这点在以后也是十分好用的）。然而客户端的功能并不是很全，有些必须要命令行来完成。\n\n<font style=\"color:#f00\">最后提示一下：要善于变通，有时候将命令行和客户端结合起来用会方便很多。</font>\n\n## 场景二——git克隆到本地\n我们本地的git仓库不小心丢失了，可能是因为系统重装或是硬盘损坏等原因。此时我们如何继续我们未完成的工作呢。\n\n### 命令行操作\n\n通过git clone命令将远程仓库克隆到本地，然后再进行工作。\n\n\tgit clone https://github.com/helianthuswhite/my_repository.git\n\t//将远程代码克隆到本地仓库\n\n之后可以继续修改、add、commit、push操作。\n\n### 客户端操作\n\n客户端操作更加简单，只需要点击添加按钮即可看到当前登录账号的远程仓库，选择clone就好。\n\n![创建自己仓库](http://oetmrek6t.bkt.clouddn.com/article_18_12.png)\n\n## 场景三——解决push时的冲突\n前两个场景只是单人仓库存储的使用，之后介绍的就是如何使用git来进行团队协作。\n\n现在我们要与其他人一起完成一个项目，每个人完成的部分是不一样的。如果大家都把远程仓库克隆到本地，然后完成自己的内容再提交到远程仓库，那样第一个提交的人不会出错，但其他人就会遇到如下错误：\n\n\t! [rejected] master -> master (non-fast-forward)\n\n这是因为，在我们提交本地代码之前，仓库里面的代码已经发生了变化。\n那么，如何解决我们遇到的这个问题？\n\n### 命令行操作\n\n1、clone远程仓库到本地。\n\n2、新建一个本地分支。\n\t\n\tgit branch dev\t//新建一个名为dev的分支\n\n3、查看当前仓库的分支。\n\n\tgit branch\t\t//查看当前仓库的分支\n\n4、切换到dev分支上面。\n\n\tgit checkout dev\t//切换到dev分支\n\n5、修改仓库内容，然后顺序执行add、commit。\n\n\ttouch heh.txt    //linux 新建一个文件\n\tvi heh.txt    //linux 修改文件内容\n\tgit add -A\t\t//git 操作\n\tgit commit -m'新建分支'\t\t//git 操作\n\n6、执行push操作将本地分支推送到远程仓库。\n\n\tgit push origin dev\t\t//这里不是master了，因为我们从master分支切换到了dev分支\n\n7、如果当前处于工作之中并且需要临时查看一下demo的话，可以切换到master分支，然后同步一下其他分支的内容。\n\n\tgit checkout master\t\t//切换到master分支\n\tgit pull origin dev\t\t//将dev中新修改的内容同步到master的本地分支\n\n最后别忘了再将master本地仓库推送到远程仓库。这样操作之后，就可以把其他分支中的内容同步到主分支上面。所以在实际的开发中，团队协作时可以每人各建一个分支，需要合并时与他人分支进行合并即可。\n\n8、除了同步可以解决分支的问题，也可以采用合并分支的办法，来将不同的分支进行合并。\n\n\tgit checkout master\t\t//切换到master分支\n\tgit merge dev\t\t//将dev分支merge到master分支上面\n\n将本地改变推送到远程仓库中。\n\n9、当任务都完成之后，我们需要将多余的分支给删掉。\n\n\tgit checkout master\t\t//切换到主分支\n\tgit branch -d dev\t\t//删除本地dev分支\n\tgit branch \t\t//查看所有的分支\n\tgit branch -r -d origin/dev\t\t//删除远程仓库的分支\n\tgit push origin :dev\t//将删除远程分支的操作同步到远程仓库\n\n### 客户端操作\n\n1、创建新的分支。\n\n![创建自己仓库](http://oetmrek6t.bkt.clouddn.com/article_18_13.png)\n\n2、切换到自己新建的分支上面。\n\n![创建自己仓库](http://oetmrek6t.bkt.clouddn.com/article_18_14.png)\n\n3、完成自己工作，并且提交到远程仓库。\n\n![创建自己仓库](http://oetmrek6t.bkt.clouddn.com/article_18_15.png)\n\n![创建自己仓库](http://oetmrek6t.bkt.clouddn.com/article_18_16.png)\n\n4、从客户端发送pull request请求，可以请求合并分支。\n\n![创建自己仓库](http://oetmrek6t.bkt.clouddn.com/article_18_17.png)\n\n5、点击客户端右上角按钮可以看到自己刚才提交的pull request。\n\n![创建自己仓库](http://oetmrek6t.bkt.clouddn.com/article_18_18.png)\n\n6、仓库的拥有者可以查看他人提交的Pull request，并且选择是否merge，merge之后两个分支的内容就完成了合并。\n\n![创建自己仓库](http://oetmrek6t.bkt.clouddn.com/article_18_19.png)\n\n![创建自己仓库](http://oetmrek6t.bkt.clouddn.com/article_18_20.png)\n\n7、客户端是无法删除分支的，但是可以从github上面删除分支。\n\n![创建自己仓库](http://oetmrek6t.bkt.clouddn.com/article_18_21.png)\n\n![创建自己仓库](http://oetmrek6t.bkt.clouddn.com/article_18_22.png)\n\n## 场景四——第一次pull request\n上面讲解的是比较简单的团队协作以及以自己仓库为主的pull request。还有很多复杂的协作情况需要大家掌握git的使用。\n\n接下来的场景是如何向别人的仓库的master分支发起Pull request。\n\n### 命令行操作\n\n1、先到github网站上面进入到别人的仓库里面，点击右上角的fork选项将该仓库fork到自己的github里面。\n\n![创建自己仓库](http://oetmrek6t.bkt.clouddn.com/article_18_23.png)\n\n2、进入到自己刚才fork的仓库里面，使用命令行clone到本地，然后进行修改、add、commit、push等操作。\n\n3、此时在自己的远程仓库里面已经可以看到刚才自己提交的更新了，但是现在只是提交到了自己fork的仓库里面，还没有到他人的仓库里。\n\n这时点击右上角的New pull request选项，就可以发起新的pull request了，之后仓库的拥有者就可以选择是否合并你的操作。\n\n![创建自己仓库](http://oetmrek6t.bkt.clouddn.com/article_18_24.png)\n\n### 客户端操作\n\n与命令行操作一样先到网页的进行fork操作，之后再按照情景三里面一步步进行即可。\n\n## 场景五——合并commit\n有时，我们发现自己的commit提交的乱七八糟的，有很多提交内容基本都差不多，想要把这些commit合并为一个。\n\n### 命令行操作\n\n1、查看自己提交的commit情况。\n\n\tgit log\t\t//查看commit情况\n\n![创建自己仓库](http://oetmrek6t.bkt.clouddn.com/article_18_25.png)\n\n2、获得需要合并的commit的序列号，并且进入合并页面。\n\n\tgit rebase -i abc123\t//abc123为想要合并的多个commit的前一个commit序列号\n\n![创建自己仓库](http://oetmrek6t.bkt.clouddn.com/article_18_26.png)\n\n3、修改rebase文件，可以直接按照注释的说明进行。\n\n\tpick \t\t//使用该commit\n\treword\t\t//使用该commit,修改该commit的信息\n\tedit\t\t//修改该commit\n\tsquash\t\t//将该commit合并到前一个commit\n\tfixup\t\t//与squash相似，不过会丢弃commit的日志信息\n\texec\t\t//运行剩下的命令\n\tdrop\t\t//删除commit\n\n4、修改完成保存退出之后，可以再次查看commit信息就会发现已经发生了更改。但是还需要把本地的修改提交到远程服务器。\n\n\tgit push --force origin master \t\t//--force 是强制合并，否则会把远程commit同步到本地，就无法合并了\n\n5、可以去网站查看发现，已经完成了commit的合并。如果发现之前对commit的操作有问题，可以执行以下代码来恢复。\n\n\tgit rebase --abort\t\t//撤销之前的git rebase操作\n\n## 情景六——拉取远程分支代码\n一般来说，对于多人合作的项目，我们不会直接在master分支上面进行开发操作，而是会在其他的分支进行操作。比如：master分支为项目的主要分支，是项目的主要可用版本，而dev分支为项目的开发分支，所以我们操作的时候就应该在dev分支上面进行操作。\n\n但是现在问题就来了，我们如何把远程仓库的dev分支给clone下来呢？\n\n### 命令行操作\n1、将远程分支上面的仓库clone到本地，此时clone下来的代码是只有master分支的。\n\n\tgit clone https://github.com/helianthuswhite/my_repository.git    //克隆远程仓库\n\n2、创建一个分支，创建远程origin的dev分支到本地。\n\n\tgit checkout -b dev origin/dev\t\t//创建一个远程dev分支\n\n3、此时可以看到本地已经有这个dev分支了，切换到该分支下。\n\n\tgit branch\t\t//查看当前分支\n\tgit checkout dev\t\t//切换到开发分支\n\n4、将远程仓库的开发分支代码同步到本地。\n\n\tgit pull origin dev\t\t//拉取远程分支代码\n\n5、此时可以发现本地的代码就是远程dev分支的代码了，可以直接进行开发和提交就好。\n\n","tags":["个人作品"],"categories":["个人作品"]},{"title":"OpenCV中waitKey()函数","url":"%2F2016%2F09%2F27%2Farticle-17%2F","content":"OpenCV中waitKey()函数的详细说明。\n\n<!--more-->\n\nwaitKey(x):\n\n参数x：等待x ms，如果在此期间有按键按下，则立即结束并返回按下按键的\nASCII码，否则返回-1。\n\n如果x=0，那么无限等待下去，直到有按键按下。\n\n<font style=\"color:#f00\">注意：\n\nwaitKey仅对窗口机制起作用，即namedWindow产生的窗口。若在此之前没有产生窗口，则waitKey相当于未执行。\n\n另外，在imshow之后如果没有waitKey语句则不会正常显示图像。</font>","tags":["图像处理"],"categories":["OpenCV"]},{"title":"Flex布局的用法","url":"%2F2016%2F09%2F25%2Farticle-16%2F","content":"关于Flex布局的用法，在阮一峰老师的博客中讲的十分详细，可以直接参考[Flex 布局教程：语法篇](http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html?utm_source=tuicool)。\n\n我补充一下上诉文章中没有讲到的部分，主要是关于子元素部分的flex属性。\n\n<!--more-->\n\n首先明确一点是，flex 是 flex-grow、flex-shrink、flex-basis的缩写。\n\nflex 的默认值是以上三个属性值的组合。假设以上三个属性同样取默认值，则 flex 的默认值是 0 1 auto。同理，如下是等同的：\n\n```css\n.item {flex: 2333 3222 234px;}\n.item {\n    flex-grow: 2333;\n    flex-shrink: 3222;\n    flex-basis: 234px;\n}\n```\n\n当 flex 取值为 none，则计算值为 0 0 auto，如下是等同的：\n\n```css\n.item {flex: none;}\n.item {\n    flex-grow: 0;\n    flex-shrink: 0;\n    flex-basis: auto;\n}\n```\n\n当 flex 取值为 auto，则计算值为 1 1 auto，如下是等同的：\n\n```css\n.item {flex: auto;}\n.item {\n    flex-grow: 1;\n    flex-shrink: 1;\n    flex-basis: auto;\n}\n```\n\n当 flex 取值为一个非负数字，则该数字为 flex-grow 值，flex-shrink 取 1，flex-basis 取 0%，如下是等同的：\n\n```css\n.item {flex: 1;}\n.item {\n    flex-grow: 1;\n    flex-shrink: 1;\n    flex-basis: 0%;\n}\n```\n\n当 flex 取值为一个长度或百分比，则视为 flex-basis 值，flex-grow 取 1，flex-shrink 取 1，有如下等同情况（注意 0% 是一个百分比而不是一个非负数字）：\n\n```css\n.item-1 {flex: 0%;}\n.item-1 {\n    flex-grow: 1;\n    flex-shrink: 1;\n    flex-basis: 0%;\n}\n.item-2 {flex: 24px;}\n.item-1 {\n    flex-grow: 1;\n    flex-shrink: 1;\n    flex-basis: 24px;\n}\n```\n\n当 flex 取值为两个非负数字，则分别视为 flex-grow 和 flex-shrink 的值，flex-basis 取 0%，如下是等同的：\n\n```css\n.item {flex: 2 3;}\n.item {\n    flex-grow: 2;\n    flex-shrink: 3;\n    flex-basis: 0%;\n}\n```\n\n当 flex 取值为一个非负数字和一个长度或百分比，则分别视为 flex-grow 和 flex-basis 的值，flex-shrink 取 1，如下是等同的：\n\n```css\n.item {flex: 2333 3222px;}\n.item {\n    flex-grow: 2333;\n    flex-shrink: 1;\n    flex-basis: 3222px;\n}\n```\n\nflex-basis 规定的是子元素的基准值。所以是否溢出的计算与此属性息息相关。flex-basis 规定的范围取决于 box-sizing。\n\n这里主要讨论以下 flex-basis 的取值情况：\n\nauto：首先检索该子元素的主尺寸，如果主尺寸不为 auto，则使用值采取主尺寸之值；如果也是 auto，则使用值为 content。\n\ncontent：指根据该子元素的内容自动布局。有的用户代理没有实现取 content 值，等效的替代方案是 flex-basis 和主尺寸都取 auto。\n\n百分比：根据其包含块（即伸缩父容器）的主尺寸计算。如果包含块的主尺寸未定义（即父容器的主尺寸取决于子元素），则计算结果和设为 auto 一样。\n\n举一个不同的值之间的区别：\n\n```html\n<div class=\"parent\">\n    <div class=\"item-1\"></div>\n    <div class=\"item-2\"></div>\n    <div class=\"item-3\"></div>\n</div>\n<style type=\"text/css\">\n    .parent {\n        display: flex;\n        width: 600px;\n    }\n    .parent > div {\n        height: 100px;\n    }\n    .item-1 {\n        width: 140px;\n        flex: 2 1 0%;\n        background: blue;\n    }\n    .item-2 {\n        width: 100px;\n        flex: 2 1 auto;\n        background: darkblue;\n    }\n    .item-3 {\n        flex: 1 1 200px;\n        background: lightblue;\n    }\n</style>\n```\n\n- 主轴上父容器总尺寸为 600px\n- 子元素的总基准值是：0% + auto + 200px = 300px，其中\n```\n0% 即 0 宽度\nauto 对应取主尺寸即 100px\n```\n- 故剩余空间为 600px - 300px = 300px\n- 伸缩放大系数之和为： 2 + 2 + 1 = 5\n- 剩余空间分配如下：\n```\nitem-1 和 item-2 各分配 2/5，各得 120px\nitem-3 分配 1/5，得 60px\n```\n- 各项目最终宽度为：\n```\nitem-1 = 0% + 120px = 120px\nitem-2 = auto + 120px = 220px\nitem-3 = 200px + 60px = 260px\n```\n- 当 item-1 基准值取 0% 的时候，是把该项目视为零尺寸的，故即便声明其尺寸为 140px，也并没有什么用，形同虚设。\n- 而 item-2 基准值取 auto 的时候，根据规则基准值使用值是主尺寸值即 100px，故这 100px 不会纳入剩余空间。\n\n这里细说了一下子元素flex的取值问题，还有关于flex布局的实例用法，也可以参考阮一峰老师的文章[Flex 布局教程：实例篇](http://www.ruanyifeng.com/blog/2015/07/flex-examples.html)。\n","tags":["响应式设计"],"categories":["前端"]},{"title":"CSS子元素垂直居中","url":"%2F2016%2F09%2F21%2Farticle-15%2F","content":"如何实现一个CSS子元素的垂直居中，这里有完备的解决方案！\n\n<!--more-->\n\n### 当父元素为浏览器窗口时，子元素垂直居中：\n```css\ndiv {\n\tposition: fixed;\n\tleft: 0;\n\tright: 0;\n\ttop: 0;\n\tbottom: 0;\n\tmargin: auto;\n}\n```\n\n### 父元素为块级元素，子元素已知大小（假设为300*400）：\n```css\n.child {\n\tposition: absolute;\n\ttop: 50%;\n\tleft: 50%;\n\tmargin-top: -200px;\n\tmargin-left: -150px;\n}\n```\n\n### 父元素为块级元素，子元素未知大小：\n   解决方案一：\n   ```css\n   .child {\n   \tpositon: absolute;\n   \tleft: 0;\n   \tright: 0;\n   \ttop: 0;\n   \tbottom: 0;\n   \tmargin: auto;\n   }\n   ```\n\n   解决方案二：\n   ```css\n   .father {\n   \tdisplay: table;\n   }\n   .child {\n   \tdisplay:table-cell;\n   \tvertical-align: middle;\n   }\n   ```\n\n   解决方案三：\n   ```css\n   .father {\n   \tdisplay:flex;\n   \tflex-flow:row nowrap;\n   \tjustify-content: center;\n   \talign-items: center;\n   }\n   .child {\n   \tflex: 1;\n   }\n   ```","tags":["CSS"],"categories":["前端"]},{"title":"Xcode运行《学习Opencv》代码","url":"%2F2016%2F09%2F20%2Farticle-14%2F","content":"使用Xcode编译运行Opencv代码。\n\n<!--more-->\n\n先从书中给的网站将代码示例下载下来并解压。\n\n在Xcode中闯将新的Project，选择Command  Line Tool。\n\n创建好之后先将下图所示修改完好。\n\n![图片加载失败](http://oetmrek6t.bkt.clouddn.com/article_14_1.png)\n\n之后再按下图所示修改。\n\n![图片加载失败](http://oetmrek6t.bkt.clouddn.com/article_14_2.png)\n\n\n修改完成之后右键点击项目，New Group，取名随意，因为要放置opencv的包，所以我取名为Opencv lib。\n\n右键Opencv lib，Add files to ……，在选择文件的时候command+shift+G,搜索/usr/local/lib，将里面Opencv的包全部导入进去，那个python的文件夹不能导入，否则可能会出现问题。\n\n现在就可以在main.cpp中测试一下opencv的代码了。如果没有问题，OK，开始导入之前下载的例子代码。\n\n这里我又新建了一个Group叫samples，同样用Add files to….的方法把代码全部导入了（注意，在导入的时候下面有个Option选项，把target内容取消，否则每次都要编译全部文件）。\n\n![图片加载失败](http://oetmrek6t.bkt.clouddn.com/article_14_3.png)\n\n之后就是如何使用这些代码了。\n\n这些代码有一个问题就是，在运行的时候不能使用图片的相对路径，必须使用绝对路径，这一点很烦人，因为每次都要输入那么长的地址。\n\n后来琢磨了一下，发现每份代码里面都会引入highgui.hpp这个头文件。\n\n于是我就把测试图片当成常量定义在了highgui.hpp中，这样在所有的代码中都可以直接使用了。\n\n![图片加载失败](http://oetmrek6t.bkt.clouddn.com/article_14_4.png)\n\n![图片加载失败](http://oetmrek6t.bkt.clouddn.com/article_14_5.png)\n\n最后就是代码的编译运行问题。\n\n之前因为没有选中target，所以目前编译运行时应该只有main.cpp一个文件。\n\n我们在运行某份代码时，只需要将右上角的那个target选中即可。（记得把main.cpp的target取消掉)\n\n![图片加载失败](http://oetmrek6t.bkt.clouddn.com/article_14_6.png)\n\n至此，就可以开开心心的学习OPENCV了。\n\n最后，安利一下我的学习计划，我是将每一个例子的每一句代码都加上了注释，这样的话可以让其他人通过直接看代码便能初步的掌握Opencv的各种包和库的用法。\n\ngithub地址为：[https://github.com/helianthuswhite/Opencv-notes](https://github.com/helianthuswhite/Opencv-notes)\n\n\n\n\n\n","tags":["图像处理"],"categories":["Xcode"]},{"title":"mac安装OpenCV","url":"%2F2016%2F09%2F20%2Farticle-13%2F","content":"mac下安装opencv，本来在网上看的教程，结果发现一直出现问题，琢磨了半天终于搞定了。\n\n先去官网下载OPENCV,然后解压。\n\n再去下载cmake，这里要注意了，最好不要下载*.dmg文件，我就是因为下载的这个导致安装好之后没有环境变量，整了半天，最后换成了.tar就好了。\n\n<!--more-->\n\n下载好cmake之后，解压。在解压的cmake文件夹内输入：\n\n./bootstrap\n\nmake\n\nmake install\n\n如果提示权限不够，前面加上sudo即可。安装好后输入cmake测试，如果不是commond not found则说明安装成功。\n\n之后命令行进入到解压后的opencv文件夹内，分别输入：\n\nsudo cmake -G \"Unix Makefiles\"\nsudo make -j8\nsudo make install\n \n等待安装完成。\n接下来就可以找一段opencv代码进行测试啦~","tags":["OpenCV"],"categories":["OpenCV"]},{"title":"mac显示隐藏文件","url":"%2F2016%2F09%2F20%2Farticle-12%2F","content":"defaults write com.apple.finder AppleShowAllFiles -bool true //显示隐藏文件\n\n执行命令后强制退出finder\n\n<!--more-->\n\n\n","tags":["mac"],"categories":["mac"]},{"title":"MongoDB数据库的安装","url":"%2F2016%2F09%2F20%2Farticle-11%2F","content":"最近在学习Node方面的内容，需要用到MongoDB数据库。本来已经能够熟练安装SQL Server和MySQL的我看着Mongo那“娇小”的身躯，以为很快就能够完事，结果==竟然装了辣么久。。。。。。把坑先记下来吧，免得以后再装的时候又步后尘。\n\n<!--more-->\n\nMongoDB数据库可以直接从官网下载[https://www.mongodb.org/](https://www.mongodb.org/)，最新的版本好像要收费，可以直接下载后面的版本。不过我试了一下，发现我这里好像不怎么能连接到资源，所以就另外找了下载地址。这个是开源中国提供的一个下载地址，可以直接下载： [https://www.mongodb.org/dl/win32/x86_64-2008plus-ssl](https://www.mongodb.org/dl/win32/x86_64-2008plus-ssl)。\n\n下载之后直接打开安装就行，最新版的安装目录是这样的：\n\n![图片加载失败](http://oetmrek6t.bkt.clouddn.com/article_11_1.png)\n\n然后打开cmd命令行，进入到安装目录中的/bin目录下。然后输入启动命令：mongod.exe，然后就会出现一大堆的东西；之后再输入连接命令：mongo.exe；然后不出意料你应该就会看到如下界面：\n\n![图片加载失败](http://oetmrek6t.bkt.clouddn.com/article_11_2.png)\n\n这是什么意思呢，显然是连接失败了，连接失败的原因又是什么呢？\n\n主要是因为这个版本的MongoDB没有自动配置数据存放文件夹，所以在启动时无法找到数据库存放的地方，就会出现上面的错误。\n\n解决方法的话就是在任意磁盘的根目录，对！没错！就是在根目录！根目录！根目录！不要问我为什么这么激动，因为我被坑惨了T T。在根目录下建一个名为data的文件夹，然后在data文件夹中建立一个db文件夹。例如：D:/data/db。（说一下为什么是根目录，因为如果不是根目录的话，在后面的操作时会报错：file or repositories not found.)\n\n完成以上的步骤之后命令行进入/bin目录下，输入：mongod –dbpath D:/data/db .也就是你刚才建立db文件夹的目录。然后你就会惊奇的发现又是一大堆东西出现，不过已经没有之前的错误了。\n\n你需要等呀等呀直到出现下面的情况：\n\n![图片加载失败](http://oetmrek6t.bkt.clouddn.com/article_11_3.png)\n\n这时它在等待你连接27017端口，所以你需要做的就是去浏览器中输入：localhost:27017。如果你看到以下内容，那就说明mongo已经启动成功了。\n\n\tIt looks like you are trying to access MongoDB over HTTP on the native driver port.  \n\n之后再另外打开一个命令行窗口，切记！前面那个窗口不能关闭，否则又要重新打开。进入之前的/bin目录下，输入mongo.exe，然后就能够成功进入MongoDB的命令行中了：\n\n![图片加载失败](http://oetmrek6t.bkt.clouddn.com/article_11_4.png)\n\n到此为止，MongoDB就算安装成功了。不过如果不喜欢命令行的话，也可以使用图形化管理界面，推荐的比较多的就是Robomongo,直接去其官网下载就行https://robomongo.org/download。下载安装完成之后，打开可以看到如下界面：\n\n![图片加载失败](http://oetmrek6t.bkt.clouddn.com/article_11_5.png)\n\n点击左上角的create按钮，需要填写的直接默认就行，然后如果你点击了左下角的Test按钮，你会发现出现了下面的一个错误：\n\n![图片加载失败](http://oetmrek6t.bkt.clouddn.com/article_11_6.png)\n\n出现这个错误要淡定，不要方，直接忽略掉就好。这个是因为你的数据库没有开启验证功能，如果你想知道如何开启MongoDB的验证功能可以查看我的另一篇博文——MongoDB数据库开启验证。如果前面你用命令行能够成功进入mongo的话，那么用这个图形化工具也能成功进入的。\n\n\n","tags":["数据库"],"categories":["数据库"]},{"title":"CSS中的黑科技——calc()","url":"%2F2016%2F09%2F19%2Farticle-10%2F","content":"帮别人调试代码的时候看到的这个属性，然后就去了解了一下，发现真的是CSS中的黑科技。。。。。。\n\n它能够使在CSS中进行四则运算成为可能，不要说四则运算有什么了不起，在CSS中能进行四则运算可是能帮助我们解决很多问题的。虽然在IE浏览器中也有一个CSS属性能够使用JS代码——expression，然而仅限于IE，还是旧版本。所以当我知道这个属性的时候内心还是蛮激动==\n\n<!--more-->\n\n不扯那些没用的了，还是早点进入正题吧。\n\n### <font style=\"color:#f00\">calc()能做什么？</font>\n\n前面已经介绍过了，进行四则运算。不过它是用于长度的单位运算的，em、px、rem都可以用来计算。最重要的一点是能够对百分比也进行计算！！比如我们经常会遇到这样的问题，对body设置了宽度100%，但是又要对盒子设置边框，于是，在设置完边框之后我们会发现浏览器的下面多了一行滚动条。这当然不是我们想要的，所以我们就可以用calc()来解决。我们可以这样做：\n\n\tbody{ width: calc(100% – 2px); border: solid 1px #000; }\n\n<font style=\"color:#f00;\">注意一点！运算符前后的空格必须，不然会无效！</font>\n\n然后，之前的问题就完美解决了。还有很多类似这样的例子我们都可以用这种方法进行解决。\n\n### <font style=\"color:#f00;\">calc()的运算规则</font>\n\n使用 + – * / 四则运算符\n\n","tags":["CSS3"],"categories":["前端"]},{"title":"什么是CSS栅格布局","url":"%2F2016%2F09%2F19%2Farticle-9%2F","content":"这个问题的出现来自于百度前端技术学院的一个小任务——响应式栅格布局。其实很早之前我就接触了一点响应式的设计，但无奈当时懵懂，并没有真正理解其中的奥妙。今天再次接触到这个，决定把它记录下来。\n\n<!--more-->\n\n栅格布局原理最早出现在BootStrap框架之中，由于它的响应式布局和友好的设计风格，栅格布局很快成为了前端布局中最流行的布局之一。关于栅格布局原理，BootStrap文档中也有解释，不过个人觉得那个不是很容易理解，所以在查找之后，在木的树博客中看到一篇文章，感觉很好，特此摘录。【转自——[木的树博客](http://www.cnblogs.com/dojo-lzz/p/4621627.html)】\n\n### <font style=\"color:#f00;\">栅格系统的原理</font>\n\n![图片加载失败](http://oetmrek6t.bkt.clouddn.com/article_9_1.png)\n\n假设：Flowline的宽度为W，column的宽度为c，Gutter的宽度为g，Margin的宽度为m，栅格列数为N\n\nW = c*N + g*(N-1) + 2m；g的宽度通常为m的两倍，所以：\n\nW = (c+g) * N；把c+g记为C，得：\n\nW = C * N;\n\n大部分的栅格系统都是此公式的变体。\n\n### <font style=\"color:#f00;\">BootStrap栅格系统</font>\n\n下面我们将一起来看一下常见的栅格布局的设计和bootstrap中的设计实现。BootStrap中合理的使用栅格布局，必须将列放入row中，而row必须放入container中。container类在布局中主要有两个作用：\n\n在不同的宽度区间内（响应式断点）提供宽度限制。当宽度变化时，采用不同的宽度。\n提供一个padding，阻止内部内容触碰到浏览器边界。\n\nBootstrap中使用padding代替上文中的margin。大小为15px，如下图所示，粉红色为padding大小。\n\n![图片加载失败](http://oetmrek6t.bkt.clouddn.com/article_9_2.png)\n\nRow是column的容器，每个row中的column之和必须为12，不过我们可以通过嵌套的方式扩展。Row的左右margin都为-15px，用来抵消container中的padding，如下图蓝色部分所示：\n\n![图片加载失败](http://oetmrek6t.bkt.clouddn.com/article_9_3.png)\n\n<font style=\"color:#f00\">Row的这种设计则是方便嵌套。</font>\n\nColomn是栅格系统的主角，每个column左右padding都为15px，上文中row的负margin抵消了container的 padding，所以为每个column设置padding就是为了防止内容直接触碰边界，同时不同的column之间拥有30px的卡槽 （Gutter）。如下图黄色部分所示：\n\n![图片加载失败](http://oetmrek6t.bkt.clouddn.com/article_9_4.png)\n\n现在想想上文中提到的公式：W = C * N;\n\n上文提到row的负margin设计主要为了嵌套，如果要在column中嵌套column首先 要把被嵌套的column放到row中，把row放到作为容器的column中，而不需要在放置一个container。如下图中蓝色所示，是放入 column中的row的负margin区域。\n\n![图片加载失败](http://oetmrek6t.bkt.clouddn.com/article_9_5.png)\n\n现在将被嵌套的column放入row中，如下图所示，上层column便是起到了container的作用。\n\n![图片加载失败](http://oetmrek6t.bkt.clouddn.com/article_9_6.png)\n\n以上便是栅格系统和BootStrap栅格布局系统的原理。  \n\n而在完成这个任务的时候，还遇到宽度百分比的问题，因为目前大部分盒子模型width都不包括padding，所以当设置宽度百分比的时候会出现容器内部盒子超出的问题。我的解决方案是使用CSS3的一个“黑科技”属性吧，也是今天才知道的——[CSS中神奇的calc()](/2016/09/19/article-10/)。不过我看了大牛的简单写法，就是用box-sizing更改盒子模型。。。。。。好吧，这个我倒是知道，但是从来没有想起来用过==。\n\n\n\n","tags":["BootStrap"],"categories":["前端"]},{"title":"java.lang.ClassNotFoundException:com.mysql.jdbc.Driver 关于JAVAEE连接Mysql典型错误","url":"%2F2016%2F09%2F18%2Farticle-8%2F","content":"今天做javaee的第一次作业，要用到Mysql，好久没有用过了，只好重新拾起。\n\n结合同学和我的问题，对javaee报错 java.lang.ClassNotFoundException: com.mysql.jdbc.Driver 进行总结。\n\n<!--more-->\n\n这个问题显然是java找不到mysql的驱动包。\n\n先检查项目看看是否导入了mysql驱动包，如果导入，再看该驱动包是否加入项目的编译路径中。\n\n<font style=\"color:#f00;\">先看驱动包是否导入：</font>\n\n![图片加载失败!](http://oetmrek6t.bkt.clouddn.com/article_8_1.png)\n\n<font style=\"color:#f00;\">是否解决？——》是，结束 | | 否，将驱动包加入路径：</font>\n\n驱动包——》右键——》build path——》add to build path——》Configure build path——》select all ——》ok：\n\n![图片加载失败!](http://oetmrek6t.bkt.clouddn.com/article_8_2.png)\n\n<font style=\"color:#f00;\">问题是否解决？——》是，结束 | | 否，将mysql驱动包加入到tomcat的lib中：</font>\n\n![图片加载失败!](http://oetmrek6t.bkt.clouddn.com/article_8_3.png)\n\n<font style=\"color:#f00;\">是否解决？——》是，结束 | | 否，那我也没招了。</font>\n\n### 在该问题中，主要需要注意的一点就是，在java中能够连接到Mysql数据库而javaEE无法连接的时候，这是因为Tomcat服务器不会根据JAVA类中的代码去寻找驱动包，所以需要手动将驱动包加入到Tomcat的类库中。\n\n\n\n","tags":["Mysql"],"categories":["JavaEE"]},{"title":"JS闭包——经典实例循环取i详解","url":"%2F2016%2F09%2F18%2Farticle-7%2F","content":"在segmentfault上面看到这篇文章，不是主要讲闭包，但是通过一个面试的经典实例将闭包的问题讲解的更加具体，更容易理解。\n\n主要需要注意的方法有：\n\n<!--more-->\n\n方法一和方法二是最经典的解决办法，必须掌握。\n\n更高级的做法比较有意思的是：\n\n方法三、方法六、方法七和方法九。\n\n文章链接：<a href=\"https://segmentfault.com/a/1190000003818163\" target=\"_blank\">https://segmentfault.com/a/1190000003818163</a>\n","tags":["面试"],"categories":["前端"]},{"title":"JavaScript程序的解析与执行顺序","url":"%2F2016%2F09%2F18%2Farticle-6%2F","content":"JavaScript是一种描述型脚本语言，它不同于java或C#等编译性语言,它不需要进行编译成中间语言,而是由浏览器进行动态地解析与执行。所以它的执行顺序和其他语言有所不同。\n\n<!--more-->\n\n## 一、函数的解析与执行\n### 1.1 代码块\nJavaScript的代码块即是指的在html中被<script></script>标签所包裹的内容，例如：\n\n```js\n<script type=\"text/javascript\">\n    alert(\"这是代码块一\");\n</script>\n<script type=\"text/javascript\">\n\talert(\"这是代码块二\");\n</script>\n```\n\nJS是按照代码块来进行编译和执行的，代码块间相互独立，但变量和方法共享。 举个例子：\n\n```js\n<script type=\"text/javascript\">\n    alert(str);//因为没有定义str，所以浏览器会出错，下面的不能运行\n    alert(\"我是代码块一\");//没有运行到这里\n    var test = \"我是代码块一变量\";\n</script>\n<script type=\"text/javascript\">\n\talert(\"我是代码块二\"); //这里有运行到\n\talert(test); //弹出\"我是代码块一变量\"\n</script>\n```\n上面的代码中代码块一中运行报错，但不影响代码块二的执行，这就是代码块间的独立性，而代码块二中能调用到代码一中的变量，则是块间共享性。 但是如果把代码块一放置在代码块二的下方，代码块二依然会报错。因为代码块之间的共享性只能是由位于下方的块共享上方块的内容，这也符合了javascript从上到下解析的特点。\n\n### 1.2 函数的声明和赋值\nJS中的函数分为两类，一类是声明式函数，一类是赋值式函数。例如：\n\n```js\n<script type=\"text/javascript\">\n    function Fn(){ //声明式函数\n             \n    }\n         \n    var Fn = function{  //赋值式函数\n             \n    }\n</script>\n```\n页面加载过程中，浏览器会对页面上或载入的每个js代码块(或文件)进行扫描，如果遇到声明式函数，则进行预处理(类似于C等的编译)，处理完成之后再开 始由上至下执行；遇到赋值式函数，则只是将函数赋给一个变量，不进行预处理(类似1中变量必须先定义后引用的原则)，待调用到的时候才进行处理。\n\n### 1.3 预编译期和执行期\n事实上，JS的解析过程分为两个阶段：预编译期(预处理)与执行期。\n\n预编译期JS会对本代码块中的所有声明的变量和函数进行处理（类似与C语言的编译），但需要注意的是此时处理函数的只是声明式函数，而且变量也只是进行了声明但未进行初始化以及赋值。\n   \n```js\n<script type=\"text/javascript\">\n\tFn();  //执行结果：\"执行了函数2\",同名函数后者会覆盖前者\n\tfunction Fn(){ //函数1\n\t    alert(\"执行了函数1\");\n\t}\n\t         \n\tfunction Fn(){  //函数2\n\t    alert(\"执行了函数2\");\n\t}\n</script>\n```\n```js\n<script type=\"text/javascript\">\n\tFn();  //执行结果：\"执行了声明式函数\",在预编译期声明函数及被处理了，所以即使Fn()调用函数放在声明函数前也能执行。\n\tfunction Fn(){ //声明式函数\n\t    alert(\"执行了声明式函数\");\n\t}\n\t         \n\tvar Fn = function(){  //赋值式函数\n\t    alert(\"执行了赋值式函数\");\n\t}\n</script> \n```\n\n我们上面说了JS引擎是按照代码块来顺序执行的，其实完整的说应该是按照代码块来进行预处理和执行的，也就是说预处理的只是执行到的代码块的声明函数和变量，而对于还未加载的代码块，是没法进行预处理的，这也是边编译边处理的核心所在。\n\n## 二、变量的解析与执行\n一般的变量声明与函数的解析与执行顺序相同，都是声明在执行之前。例如：\n\n```js\n<script>\n\tvar a=1;\n\talert(a); //输出为1\n</script>\n```\n```js\n<script>\n\talert(a); //输出为undefined\n\tvar a=1;\n</script>\n```\n\n变量的声明比函数的声明更加严格，它通常要按照一定的顺序来执行，并且每个变量都有它的作用范围。类似于其他语言中的全局变量与局部变量的区别，函数内部声明的变量在函数之外便无法使用，但是函数之外的变量在函数内部却可以调用。例如：\n   \n```js\n<script>\n\tfunction A()\n\t{\n\t\tvar a=1;\n\t\tfunction B()\n\t\t{\n\t\t    alert(a); //输出结果为1\n\t\t}\n\t\tB();\n\t}\n\tA();\n</script>\n```\n\n但是，如果在函数的外部和内部都同时声明了一个变量呢？结果又会是什么样的？\n   \n```js\n<script>\n\tfunction A()\n\t{\n\t\tvar a=1;\n\t\tfunction B()\n\t\t{\n\t\t    var a = 2;//变量的声明在执行之前\n\t\t    alert(a)；//输出结果为2\n\t\t}\n\t\tB();\n\t}\n\tA();\n</script>\n```\n   \n从上面的例子可以看出，对于函数内外都声明了的变量，函数优先使用自己的变量。\n\n## 三、JavaScript中的线程\n有很多有其他编程语言经验的人都知道有“线程”这个概念，单线程主要是指程序按照顺序依次执行，而多线程主要是用来解决一些程序中并发的问题，能够允许在同一时间多个方法同时执行。那么，在Javascript中是否有线程的说法呢？严格的来说是没有的，javascript中所有的方法都是按照顺序执行的。有些人可能会问，ajax的异步加载，定时器的延时执行等不是多线程么？例如：\n   \n```js\n<script>\n\tfunction fn1(){\n\t\tsetTimeout(function(){\n\t\t\talert(\"我先调用\")\n\t\t},1000);\n\t}\n\tfunction fn2(){\n\t\talert(\"我后调用\");\n\t}\n\tfn1();// 先弹出：“我后调用”，\n\tfn2();// 1秒后弹出：“我先调用”\n</script>\n```\n   \n从上面的例子来看，fn1()先于fn2()声明和调用，为什么fn2()先执行呢？这其实是由于Javascript中的“回调”机制在作用，就是让当前的方法先中断，然后过段时间再回调该函数使其执行。这种机制就好比操作系统中的“中断”机制，先执行fn1()函数，发现当中的定时器存在，使该执行“中断”，等到1s之后再次开始执行。\n\n## 四、总结\n而根据HTML文档流的执行顺序，需要在页面元素渲染前执行的js代码应该放在前面的script代码块中，而需要在页面元素加载完后的js放在元素后面，body标签的onload事件是在最后执行的。 对于代码块中的代码也是从上到下的顺序进行解析和执行的。下面分步讲述一下具体机制：\n\n<strong>step 1. 读入第一个代码块。</strong>\n   \n<strong>step 2. 做语法分析，有错则报语法错误（比如括号不匹配等），并跳转到step5。</strong>\n   \n<strong>step 3. 对var变量和function定义做“预编译处理”（永远不会报错的，因为只解析正确的声明）。</strong>\n\n<strong>step 4. 执行代码段，有错则报错（比如变量未定义）。</strong>\n\n<strong>step 5. 如果还有下一个代码段，则读入下一个代码段，重复step2。</strong>\n\n<strong>step 6. 结束</strong>\n\n总之，我们在书写javascript中的方法时，应当注意几点：不要书写同名函数；对于许多方法都会使用的变量写在最外面，其他内部变量应该根据调用的层次分层来声明；减少声明式函数和赋值式函数的混用，尽量统一写法。\n\n\n","tags":["个人作品"],"categories":["前端"]},{"title":"JS中函数执行顺序","url":"%2F2016%2F09%2F18%2Farticle-5%2F","content":"浏览器对HTML文件的解析是从上至下的，先解析文档中的DOM节点，然后依次加载css和图片等。\n\n所以，一般我们都把引入的js文件放置在body的最后面，目的是能够在文档完全解析之后再去解析并执行js中的函数。虽然在顶部引入js可以同样通过onload方法执行，但是这样的方法是不提倡的，因为当存在两个js文件中的函数都需要进行DOM操作时，就无法设定两个onload方法。\n\n<!--more-->\n\n通常来说，js中我们需要注意的函数执行顺序主要是onload函数，自执行的函数，以及DOMContentLoaded事件，这里我们不说JavaScript整个的解析和执行过程，如不了解，请传送—— JavaScript程序的解析与执行顺序。\n\n自执行的函数是在解析javascript的时候执行的。onload方法是在整个html页面的全部元素都加载完成之后执行。而DOMContentLoaded事件，顾名思义是发生在文档的DOM结构加载完成，此时页面的CSS样式以及图片都未加载。这三个函数的执行顺序是：自执行函数 > DOMContentLoaded > onload。\n\n自执行函数的优先级最高，通常可以用来动态的产生页面中的DOM元素，而DOMContentLoaded用法不多，因为在实际的项目中，我们需要的往往都是在不同的加载时间段内执行不同的函数。所以可以直接在相应的DOM结构中定义需要执行的方法从而来控制加载进度执行的方法。onload函数最常用，为了确保整个页面加载完成，从而防止js中DOM操作在节点未加载完时运行导致出错。\n","tags":["JavaScript"],"categories":["前端"]},{"title":"Web前端规范开发手册","url":"%2F2016%2F09%2F14%2Farticle-4%2F","content":"\n个人收集总结的Web前端规范开发手册，实际工作和面试的时候都很有用。\n\n<!--more-->\n\n## 一、文件命名规则\n   文件名称统一用小写的英文字母、数字和下划线组合，其中不得包含汉字、空格和特殊字符；命名原则的指导思想是使得你自己和工作组的每个成员能够方便的理解每一个文件的意义，二是当我们在文件夹中使用“按名称排列”的命令时，同一大类的文件能够排列在一起，以便我们查找、修改、替换等操作。\n\n### 1.1 HTML命名规则\n   主文件一般使用index来进行命名。\n\n   各个页面的命名应该以该页面的内容英文为主，如果英文过长可以考虑首字母代替，通常都为“性质_描述”来表示，并且是使用小写字母。\n\n   每个目录之下应该有一个默认的html文件，用来标识无法访问的地址，以defaut来命名。\n\n### 1.2 图片命名规则\n   图片的名称分为首尾两个部分，中间用下划线隔开，头部分通常表示的是大类的性质，尾部分是该图片的名称。\n\n   例如：广告、标识、菜单、按钮等。\n\n   放置在页面顶部的广告、装饰图案等取名为：banner。\n\n   标志性的图片的命名为：logo。\n\n   在页面位置不固定并且带有链接的小图片我们取名为：button。\n\n   在页面的某一个位置连续出现，性质相同的链接栏目的图片我们取名为：menu。\n\n   不带链接的表示标题的图片取名为：title。\n\n   其他装饰用的图片我们命名为：pic。\n\n   范例：\n\n      banner_baidu.gif logo_hit.gif menu_shine.gif等等。\n\n### 1.3 JavaScript和CSS命名规则\n   javascript和css文件的命名需要分开来进行，css文件一般与对应的html文件命名相同，若为特效的样式，则直接以特效效果命名。\n\n   javascript的命名与css特效一样，用来描述该文件的作用，如滑动：slide.js，异步请求：ajax.js等。\n\n## 二、文件存放位置规范\n### _Root \n\n| - | 文件夹 | 备注 |\n|:-------------:|:-------------:|:-----:|\n|\t+\t|\tcn\t|\t存放中文HTML文件\t|\n|\t+\t|\ten\t|\t存放英文HTML文件\t|\n|\t+\t|\tflash\t|\t存放flash文件\t\t|\n|\t+\t|\timages\t|\t存放图片文件\t|\n|\t+\t|\timagestudio\t|\t存放PSD源文件\t\t|\n|\t+\t|\tflashstudio\t|\t存放flash源文件\t\t|\n|\t+\t|\tinc\t|\t存放include的文件\t\t|\n|\t+\t|\tlibrary\t|\t存放库文件\t\t|\n|\t+\t|\tmedia\t|\t存放多媒体文件\t\t|\n|\t+\t|\tproject\t|\t存放工程文件资料\t\t|\n|\t+\t|\ttemp\t|\t\t存放客户原始资料\t\t|\n|\t+\t|\tjs\t|\t\t存放javascript文件\t\t|\n|\t+\t|\tcss\t|\t\t存放css文件\t\t|\n\n## 三、CSS书写规范\n### 3.1 基本原则\n   CSS样式主要可以分为2类：自定义样式和重新定义全局样式。\n\n   1、自定义样式为设计师自定义的新CSS样式，影响被使用本样式的区域，用于完成网页中布局样式的设定。\n\n   2、全局样式通常为网页的基本样式，用base.css表示，用于统一网页中的字体，行距等等样式。\n\n   页面内的样式加载必须用链接方式\n\n      <link rel=\"stylesheet\" type=\"text/css\" href=\"style/style.css\">\n\n   一般不推荐在HTML内直接使用CSS定义样式。\n\n### 3.2 注意细则\n   1、class与id的使用：id是唯一的通常是父级的，class常表示多标签用相同的样式。所以id常使用在大的模块上，class可以重复使用在子级模块上。\n\n   2、class与id的命名：避免class与id重名。可以按照从属关系命名，如:\n\n   \t<div id=\"father\"><div class=\"son\"></div></div>\n   \n   也可以使用加父级前缀进行命名，如:\n   \n   \t<div id=\"nav\"><div class=\"nav_search\"></div></div>\n\n   3、CSS属性的书写顺序，建议遵循：布局定位属性——》自身属性——》文本属性——》其他属性。尽量保持相同类型的属性书写在一起。\n\n   布局定位属性主要包括：margin、padding、float、position、top、left、right、bottom、display、visibility、overflow等；自身属性主要包括：width、height、background、border等；\n   文本属性主要包括：font、color、text-align、text-decoration、text-indent等；\n   其他属性有：list-style、vertical-align、cursor、z-index、zoom等。\n\n   4、书写代码前，考虑并提高样式的重复使用率，利用自身继承来减少代码量。\n\n   5、样式表中的中文字体名，转码成unicode码，以避免编码错误时的乱码。\n\n   6、背景图片尽可能使用sprite技术，减少http请求。\n\n   7、在用png图片作为透明背景时，对ie6应单独定义背景：\n\n   \tbackground:none;_filter:progid:DXImageTransform.Microsoft.AlphaImageLoader(sizingMethod=crop, src=’img/bg.png’)\n\n   8、减少或者避免兼容性属性的使用。\n\n   9、必须为大块的样式添加注释，代码建议单行书写。\n\n## HTML书写规范\n### 4.1 网页制作细节 ——head区代码规范 \n   head区是指html中<head></head>之间的内容。\n\n   必须加入的标签:\n   a. 公司版权注释  \n   b. 网页显示字符集 \n\n   简体中文：\n\n   \t<META HTTP-EQUIV=\"Content-Type\" CONTENT=\"text/html; charset=gb2312\">\n\n   繁体中文：\n\n   \t<META HTTP-EQUIV=\"Content-Type\" CONTENT=\"text/html; charset=utf-8\">\n\n   英 语：\n\n   \t<META HTTP-EQUIV=\"Content-Type\" CONTENT=\"text/html; charset=utf-8\">\n\n   a. 网页制作者信息  \n\n    <META name=\"author\" content=\"webmaster@maketown.com\"> \n\n   b. 网站简介  \n\n   \t<META NAME=\"DESCRIPTION\" CONTENT=\"xxxxxxxxxxxxxxxxxxxxxxxxxx\">\n\n   c. 搜索关键字  \n\n   \t<META NAME=\"keywords\" CONTENT=\"xxxx,xxxx,xxx,xxxxx,xxxx,\">\n\n   d. 网页的css规范  \n\n   \t<LINK href=\"../css/style.css\" rel=\"stylesheet\" type=\"text/css\">\n\n   e. 网页标题  \n\n   \t<title>xxxxxxxxxxxxxxxxxx</title>\n\n   可以选择加入的标签:\n\n   a. 设定网页的到期时间。一旦网页过期，必须到服务器上重新调阅。 \n\n   \t<META HTTP-EQUIV=\"expires\" CONTENT=\"Wed, 26 Feb 1997 08：21：57 GMT\">\n\n   b. 禁止浏览器从本地机的缓存中调阅页面内容。 \n\n   \t<META HTTP-EQUIV=\"Pragma\" CONTENT=\"no-cache\">\n\n   c. 用来防止别人在框架里调用你的页面。\n\n   \t<META HTTP-EQUIV=\"Window-target\" CONTENT=\"_top\">\n\n   d. 自动跳转。\n\n   \t<META HTTP-EQUIV=\"Refresh\" CONTENT=\"5;URL=http：//www.yahoo.com\">\t//5指时间停留5秒\n\n   e. 网页搜索机器人向导。用来告诉搜索机器人哪些页面需要索引，哪些页面不需要索引。\n\n   \t<META NAME=\"robots\" CONTENT=\"none\">\t//CONTENT的参数有all,none,index,noindex,follow,nofollow。默认是all。\n\n### 4.2 网页制作细节 ——字体运用规范\n   1、在设定字体样式时对于文字字号样式和行间距应必须使用CSS样式表。禁止在页面中出现 <font size=?> 标记。\n\n   2、在网页中中文应首选使用宋体。英文和数字首选使用verdana 和arial 两种字体。一般使用中文宋体的9pt 和11pt 或12px 和14.7px 这是经过优化的字号，黑体字或者宋体字加粗时，一般选用11pt 和14.7px 的字号比较合适。\n\n   3、为了最大程度的发挥浏览器自动排版的功能，在一段完整的文字中请尽量不要使用<br> 来人工干预分段。\n\n   4、不同语种的文字之间应该有一个半角空格，但避头的符号之前和避尾的符号之后除外，汉字之间的标点要用全角标点，英文字母和数字周围的括号应该使用半角括号。\n\n   5、请不要在网页中连续出现多于一个的   也尽量少使用全角空格（英文字符集下，全角空格会变成乱码），空白应该尽量使用 text-indent, padding, margin, hspace, vspace 以及透明的gif 图片来实现。\n\n   6、行距建议用百分比来定义，常用的两个行距的值是line-height:120%/150%。\n\n   7、排版中我们经常会遇到需要进行首行缩进的处理，不要使用   或者全角空格来达到效果，规范的做法是在样式表中定义 p { text-indent: 2em; } 然后给每一段加上p标记，注意，一般情况下，请不要省略/p结束标记 。\n\n### 4.3 网页制作细节 ——链接 \n   1、 网站中的链接路径全部采用相对路径，一般链接到某一目录下的缺省文件的链接路径不必写全名，如我们不必这样：\n\n   \t<a href=”aboutus/index.htm”> \n\n   而应该这样：\n\n   \t<a href=”aboutus/”>\n\n   所有内页指向首页的链接写成:\n\n   \t<a href=”/”>。\n\n   2、在浏览器里，当我们点击空链接时，它会自动将当前页面重置到首端，从而影响用户正常的阅读内容，我们用代码“javascript:void(null)”代替原来的“#”标记。\n\n### 4.4 网页制作细节 ——表格\n   1、在写 table 互相嵌套时，严格按照的规范，对于单独的一个 table 来说，table tr 对齐，td 缩进两个半角空格，td 中如果还有嵌套的表格， table 也缩进两个半角空格，如果 td 中没有任何嵌套的表格，/td 结束标记应该与 td 处于同一行，不要换行。\n\n   2、一个网页要尽量避免用整个一张大表格，所有的内容都嵌套在这个大表格之内，因为浏览器在解释页面的元素时，是以表格为单位逐一显示，如果一张网页是嵌套在一个大表格之内，那么很可能造成的后果就是，当浏览者敲入网址，他要先面对一片空白很长时间，然后所有的网页内容同时出现。如果必须这样做，请使用 tbody 标记，以便能够使这个大表格分块显示。\n\n### 4.5 网页制作细节 ——ALT和Title\n   在我们浏览网页时，当鼠标停留在图片对象或文字链接上时，在鼠标的右下角有时会出现一个提示信息框。对目标进行一定的注释说明。在一些场合，它的作用是很重要的。 \n\n   alt 用来给图片来提示的。Title用来给链接文字或普通文字提示的。 \n\n   用法如下： \n\n   \t<p Title=\"给链接文字提示\">文字</p> \n\n   \t<a href=\"#\" Title=\"给链接文字提示\">文字</a>\n\n   \t<img src=\"图片.gif\" alt=\"给图片提示\"> \n\n### 4.6 网页制作细节 ——LOGO的国际标准\n   为了便于INTERNET上信息的传播，一个统一的国际标准是需要的。实际上已经有了这样的一整套标准。其中关于网站的LOGO，目前有三种规格：\n\n   \t88*31 这是互联网上最普遍的LOGO规格。\n\n   \t120*60 这种规格用于一般大小的LOGO。\n\n   \t120*90 这种规格用于大型LOGO。\n\n### 4.7 网页制作细节 ——其他规范细节\n   1、语义化html, 如 标题根据重要性用h(同一页面只能有一个h1), 段落标记用p, 列表用ul, 内联元素中不可嵌套块级元素。\n\n   2、尽可能减少div嵌套。\n\n   3、书写链接地址时, 必须避免重定向，例如：href=”HTTP://www.example.com/”, 即须在URL地址后面加上“/”。\n\n## 五、JavaScript书写规范\n   5.1、 书写过程中, 每行代码结束必须有分号; 原则上所有功能均根据XXX项目需求原生开发, 以避免网上down下来的代码造成的代码污染(沉冗代码 || 与现有代码冲突 || …)。\n\n   5.2、库引入: 原则上仅引入jQuery库, 若需引入第三方库, 须与团队其他人员讨论决定。\n\n   5.3、 变量命名: 驼峰式命名. 原生JavaScript变量要求是纯英文字母, 首字母须小写, 如iTaoLun; jQuery变量要求首字符为'_', 其他与原生JavaScript 规则相同, 如: _iTaoLun; 另, 要求变量集中声明, 避免全局变量。\n\n   5.4、类命名: 首字母大写, 驼峰式命名. 如 ITaoLun。\n\n   5.5、函数命名: 首字母小写驼峰式命名. 如iTaoLun()。\n\n   5.6、命名语义化, 尽可能利用英文单词或其缩写。\n\n   5.7、尽量避免使用存在兼容性及消耗资源的方法或属性, 比如eval() & innerText。\n\n   5.8、后期优化中, JavaScript非注释类中文字符须转换成unicode编码使用, 以避免编码错误时乱码显示。\n\n   5.9、代码结构明了, 加适量注释. 提高函数重用率。\n\n   5.10、注重与html分离, 减小reflow, 注重性能。\n\n## 六、图片规范\n   6.1、所有页面元素类图片均放入img文件夹, 测试用图片放于img/demoimg文件夹。\n\n   6.2、图片格式仅限于gif || png || jpg。\n\n   6.3、命名全部用小写英文字母 || 数字 || _ 的组合，其中不得包含汉字 || 空格 || 特殊字符；尽量用易懂的词汇, 便于团队其他成员理解; 另, 命名分头尾两部分, 用下划线隔开, 比如ad_left01.gif || btn_submit.gif。\n\n   6.4、在保证视觉效果的情况下选择最小的图片格式与图片质量, 以减少加载时间。\n\n   6.5、尽量避免使用半透明的png图片(若使用, 请参考css规范相关说明)。\n\n   6.6、运用css sprite技术集中小的背景图或图标, 减小页面http请求, 但注意, 请务必在对应的sprite psd源图中划参考线, 并保存至img目录下。\n\n## 七、总结\n   对一个编码人员来说，在编码时候注意自己的编码规范是十分有必要的。一方面，良好的编码习惯能够让自己有清晰的编码思路和代码结构，以后回顾代码时也能够更容易想起自己的思路。另一方面，在实际的项目开发中，通常都是与他人一同进行开发，所以良好的编码规范有利于编码人员之间的沟通和交流，统一的编码规范也有利于编码的展开和进行。\n\n\n\n\n\n\n\n\n\n\n","tags":["个人作品"],"categories":["前端"]},{"title":"清除canvas画布的内容","url":"%2F2016%2F09%2F14%2Farticle-3%2F","content":"有时候，我们需要对canvas画布进行不断的刷新来改变绘制的内容，而刷新的办法目前我知道的有两种。\n\n<!--more-->\n\n第一种：\n对canvas重新绘制，把新绘制的颜色覆盖在原来内容上，设置绘制颜色与背景相同即可。\n\n```javascript\ncontext.fillStyle=\"#ffffff\";//白色为例子；\ncontext.fillRect(400,100,400,100);\n```\n\n第二种：\n利用clearRect() 方法清空给定矩形内的指定像素。\n\n```javascript\ncontext.clearRect(x,y,width,height);\n//x,y是要清除的矩形的左上角坐标，width和height是要清除的矩形的宽和高\n```\n","tags":["HTML5"],"categories":["前端"]},{"title":"canvas绘图，出现图片放大模糊问题","url":"%2F2016%2F09%2F14%2Farticle-2%2F","content":"html5中的canvas画布标签在利用drawImage()方法绘图时，不能够在css中定义canvas的宽和高，否则就会导致绘制的图片被放大的问题，应该直接在canvas标签内部定义。\n\n<!--more-->\n\n---\n\n```html\n<!DOCTYPE html>\n<html>\n\t<head>\n    <meta charset=\"utf-8\">\n\t<script type=\"text/javascript\" src=\"js/index.js\"></script>\n\t<script type=\"text/javascript\" src=\"js/star.js\"></script>\n\t<style type=\"text/css\">\n\t    * {\n            margin: 0px;\n            padding: 0px;\n        }\n        #main {\n\t        width: 1000px;\n \t        height: 600px;\n\t\t    background: #000;\n        }\n    </style>\n\t</head>\n\t<body>\n\t    <div id=\"main\">\n\t        <canvas id=\"canvas\"></canvas>\n\t    </div>\n\t</body>\n</html>\n```\n\n---\n\n显示的结果如下所示：\n\n![图片加载失败!](http://oetmrek6t.bkt.clouddn.com/article_2_1.png)\n\n---\n\n修改后的代码如下：\n```html\n<!DOCTYPE html>\n<html>\n    <head>\n        <meta charset=\"utf-8\">\n        <script type=\"text/javascript\" src=\"js/index.js\"></script>\n        <script type=\"text/javascript\" src=\"js/star.js\"></script>\n        <style type=\"text/css\">\n            * {\n                margin: 0px;\n                padding: 0px;\n            }\n            #main {\n                width: 1000px;\n                margin: 28px auto;\n            }\n            #canvas {\n                background: #000;\n            }\n        </style>\n    </head>\n    <body>\n        <div id=\"main\">\n            <canvas id=\"canvas\" width=\"1000px\" height=\"600px\"></canvas>\n        </div>\n    </body>\n</html>\n```\n\n---\n\n显示的结果如下所示：\n\n![图片加载失败!](http://oetmrek6t.bkt.clouddn.com/article_2_2.png)\n","tags":["HTML5"],"categories":["前端"]},{"title":"关于编写个人Resume所遇到的一些问题","url":"%2F2016%2F09%2F13%2Farticle-1%2F","content":"这是之前写的一个个人简历网页版，有兴趣的朋友可以查看一下。\n\n预览地址：http://htmlpreview.github.io/?https://github.com/helianthuswhite/Resume/blob/master/index.html\n\n代码地址：https://github.com/helianthuswhite/Resume.git\n\n<!--more-->\n\n----\n\n页面的构造比较简单，主要是由六个大的div组成，由上到下采用流式布局，每一个模块显示相应的内容。\n\n在编写过程遇到挺多问题，相当于把学的都复习了一遍。\n\n以下是遇到的一些问题以及解决方法：\n\n[position定位中的relative和absolute两种定位分析不够清楚。](/2016/12/12/article-25/#more)\n\n[CSS3中的旋转属性，rotate()，旋转角度问题。](http://www.w3school.com.cn/css3/css3_3dtransform.asp)\n\n[盒子阴影box-shadow的使用，参数作用。](http://www.w3school.com.cn/cssref/pr_box-shadow.asp)\n\n[CSS选择器相关。](http://www.w3school.com.cn/cssref/css_selectors.asp)\n\n关于浮动的使用和清除。\n\nbackground背景属性在CSS3中的用法。\n\n如何形成带三角的边框，即说明框。\n\n[文字超出的自动换行，超出省略等。](/2016/11/02/article-23/)\n\n[利用box-shadow和background产生3D按钮。](http://www.w3school.com.cn/cssref/pr_box-shadow.asp)\n\n[CSS3动画各属性结合使用，@Keyframe为主的。](http://www.w3school.com.cn/css3/css3_animation.asp)\n\n利用透视加翻转制作3D旋转效果。\n\n[js获取一些区域的宽和高。](/2017/03/10/article-36/)\n\n页面滚动显示动画插件——scrollReveal.js。\n\n----\n\n","tags":["CSS3"],"categories":["个人作品"]},{"title":"Hello World","url":"%2F2016%2F01%2F01%2Fhello-world%2F","content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n<!--more-->\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n","tags":["Hexo"]}]